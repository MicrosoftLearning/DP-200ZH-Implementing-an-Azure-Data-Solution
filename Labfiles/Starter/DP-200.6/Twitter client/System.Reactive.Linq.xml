<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>System.Reactive.Linq</name>
    </assembly>
    <members>
        <member name="T:System.Reactive.Joins.NamespaceDoc">
            <summary>该 <b>System.Reactive.Joins</b> 命名空间包含使用流畅方法语法在可观察序列上表示连接模式的类。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.VirtualTimeSchedulerExtensions">
            <summary>为虚拟时间调度提供一组扩展方法。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerExtensions.ScheduleRelative``2(System.Reactive.Concurrency.VirtualTimeSchedulerBase{``0,``1},``1,System.Action)">
            <summary>分配在 dueTime 时执行的操作。</summary>
            <typeparam name="TAbsolute">绝对时间表示类型。</typeparam>
            <typeparam name="TRelative">相对时间表示类型。</typeparam>
            <param name="scheduler">操作调度程序。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerExtensions.ScheduleAbsolute``2(System.Reactive.Concurrency.VirtualTimeSchedulerBase{``0,``1},``0,System.Action)">
            <summary>分配在 dueTime 时执行的操作。</summary>
            <typeparam name="TAbsolute">绝对时间表示类型。</typeparam>
            <typeparam name="TRelative">相对时间表示类型。</typeparam>
            <param name="scheduler">操作调度程序。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="T:System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute">
            <summary>应用于静态类的属性，提供查询方法的表达树形式，将这些形式映射到对应的方法，以便在指定的目标类类型上执行本地查询。</summary>
        </member>
        <member name="M:System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute.#ctor(System.Type)">
            <summary>创建指向本地执行查询方法实现类型的新映射。</summary>
            <param name="targetType">实现本地运行的查询方法类型。</param>
        </member>
        <member name="P:System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute.TargetType">
            <summary>获取实现本地查询方法的类型。</summary>
        </member>
        <member name="T:System.Reactive.Linq.Observable">
            <summary>提供一组静态方法，用于在可观察序列上写入内存查询。</summary>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEachAsync``1(System.IObservable{``0},System.Action{``0})">
            <summary>为可观察序列中的每个元素调用一个动作，并返回一个“任务”对象，该对象将在序列终止时发出信号。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <returns>表示序列终止的任务。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEachAsync``1(System.IObservable{``0},System.Action{``0},System.Threading.CancellationToken)">
            <summary>为可观察序列中的每个元素调用一个动作，并返回一个“任务”对象，该对象将在序列终止时发出信号。通过设置指定的取消令牌，可以提前退出循环。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="cancellationToken">取消令牌用于停止循环。</param>
            <returns>表示序列终止的任务。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEachAsync``1(System.IObservable{``0},System.Action{``0,System.Int32})">
            <summary>为可观察序列中的每个元素调用一个动作，合并元素的索引，并返回一个“任务”对象，该对象将在序列终止时发出信号。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <returns>表示序列终止的任务。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEachAsync``1(System.IObservable{``0},System.Action{``0,System.Int32},System.Threading.CancellationToken)">
            <summary>为可观察序列中的每个元素调用一个动作，合并元素的索引，并返回一个“任务”对象，该对象将在序列终止时发出信号。通过设置指定的取消令牌，可以提前退出循环。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="cancellationToken">取消令牌用于停止循环。</param>
            <returns>表示序列终止的任务。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Case``2(System.Func{``0},System.Collections.Generic.IDictionary{``0,System.IObservable{``1}},System.IObservable{``1})">
            <summary>使用 <paramref name="selector"/> 确定返回 <paramref name="sources"/> 中的哪个源，如果找不到匹配项，则选择 <paramref name="defaultSource"/>。</summary>
            <typeparam name="TValue">选择器函数返回的数值类型，用于查找生成的源。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="selector">调用选择器函数以确定要在<paramref name="sources"/> 字典中查找的源。</param>
            <param name="sources">基于<paramref name="selector"/>调用结果的所选源字典。</param>
            <param name="defaultSource">如果没有匹配的源，则选择默认源 <paramref name="sources"/>。</param>
            <returns>基于<paramref name="selector"/>调用结果从<paramref name="sources"/>字典导出的可观察序列，如果没有找到匹配项，则为<paramref name="defaultSource"/>。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 或<paramref name="sources"/>或<paramref name="defaultSource"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Case``2(System.Func{``0},System.Collections.Generic.IDictionary{``0,System.IObservable{``1}},System.Reactive.Concurrency.IScheduler)">
            <summary>使用 <paramref name="selector"/> 确定返回 <paramref name="sources"/> 中的哪个来源，如果找不到匹配项，则选择指定调度程序上的空序列。</summary>
            <typeparam name="TValue">选择器函数返回的数值类型，用于查找生成的源。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="selector">调用选择器函数以确定要在<paramref name="sources"/> 字典中查找的源。</param>
            <param name="sources">基于<paramref name="selector"/>调用结果的所选源字典。</param>
            <param name="scheduler">如果<paramref name="sources"/>中没有匹配的源，则调度程序将生成一个空序列。</param>
            <returns>基于<paramref name="selector"/>调用结果从<paramref name="sources"/>字典导出的可观察序列，如果没有找到匹配项，则为可序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 或<paramref name="sources"/>或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Case``2(System.Func{``0},System.Collections.Generic.IDictionary{``0,System.IObservable{``1}})">
            <summary>使用<paramref name="selector"/>确定返回<paramref name="sources"/>中的哪个源，如果找不到匹配项，则选择空序列。</summary>
            <typeparam name="TValue">选择器函数返回的数值类型，用于查找生成的源。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="selector">调用选择器函数以确定要在<paramref name="sources"/> 字典中查找的源。</param>
            <param name="sources">基于<paramref name="selector"/>调用结果的所选源字典。</param>
            <returns>基于<paramref name="selector"/>调用结果从<paramref name="sources"/>字典导出的可观察序列，如果没有找到匹配项，则为可序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 或 <paramref name="sources"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DoWhile``1(System.IObservable{``0},System.Func{System.Boolean})">
            <summary>只要<paramref name="condition"/>保持不变，重复给定的<paramref name="source"/>，其中每个重复的<paramref name="source"/>被订阅之前<paramref name="condition"/>已评估完成。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">只要<paramref name="condition"/>函数求值为 true，则重复源。</param>
            <param name="condition">通过<paramref name="source"/>完成迭代后将评估的条件，确定是否需要重复源。</param>
            <returns>通过连接<paramref name="source"/>序列获取可观察序列，前提是<paramref name="condition"/> 保持不变。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或 <paramref name="condition"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.For``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>通过运行给定枚举<paramref name="source"/>中每个元素的<paramref name="resultSelector"/>，连接获取的可观察序列。</summary>
            <typeparam name="TSource">可枚举源序列中元素的类型。</typeparam>
            <typeparam name="TResult">可观察结果序列中元素的类型。</typeparam>
            <param name="source">对于可枚举的源，每个元素将映射到将在结果序列中连接的可观察源。</param>
            <param name="resultSelector">在<paramref name="source"/>中为每个元素选择一个可观察源的函数 。</param>
            <returns>通过连接<paramref name="source"/>中<paramref name="resultSelector"/>为每个元素返回的源，获取可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或 <paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.If``1(System.Func{System.Boolean},System.IObservable{``0},System.IObservable{``0})">
            <summary>如果指定的<paramref name="condition"/>求值为 true，选择<paramref name="thenSource"/>序列。否则，请选择<paramref name="elseSource"/>序列。</summary>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="condition">评估条件以决定返回哪个序列。</param>
            <param name="thenSource"><paramref name="condition"/>评估为 true 时返回的序列。</param>
            <param name="elseSource"><paramref name="condition"/>评估为 false 时返回的序列。</param>
            <returns><paramref name="thenSource"/> 如果<paramref name="condition"/>评估为 true；<paramref name="elseSource"/>否则。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或<paramref name="thenSource"/>或<paramref name="elseSource"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.If``1(System.Func{System.Boolean},System.IObservable{``0})">
            <summary>如果指定的<paramref name="condition"/>求值为 true，选择<paramref name="thenSource"/>序列。否则，返回一个空序列。</summary>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="condition">评估条件以决定返回哪个序列。</param>
            <param name="thenSource"><paramref name="condition"/>评估为 true 时返回的序列。</param>
            <returns><paramref name="thenSource"/> 如果<paramref name="condition"/>评估为 true；否则返回一个空序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或 <paramref name="thenSource"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.If``1(System.Func{System.Boolean},System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>如果指定的<paramref name="condition"/>求值为 true，选择<paramref name="thenSource"/>序列。否则，返回指定调度程序上生成的空序列。</summary>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="condition">评估条件以决定返回哪个序列。</param>
            <param name="thenSource"><paramref name="condition"/>评估为 true 时返回的序列。</param>
            <param name="scheduler">如果<paramref name="condition"/>评估为 false，则指定调度程序生成一个序列。</param>
            <returns><paramref name="thenSource"/> 如果<paramref name="condition"/>评估为 true；否则返回一个空序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或<paramref name="thenSource"/>或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.While``1(System.Func{System.Boolean},System.IObservable{``0})">
            <summary>只要指定的<paramref name="condition"/>保持不变，重复给定的<paramref name="source"/>，其中每个重复的<paramref name="source"/>被订阅之前<paramref name="condition"/>已评估完成。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">只要<paramref name="condition"/>函数求值为 true，则重复源。</param>
            <param name="condition">订阅<paramref name="source"/>之前完成评估的条件用于确定是否需要重复源。</param>
            <returns>通过连接<paramref name="source"/>序列获取可观察序列，前提是<paramref name="condition"/> 保持不变。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或 <paramref name="source"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或 <paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``5(System.Func{``0,``1,``2,``3,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``4})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``6(System.Func{``0,``1,``2,``3,``4,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``5})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``7(System.Func{``0,``1,``2,``3,``4,``5,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``6})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``8(System.Func{``0,``1,``2,``3,``4,``5,``6,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``7})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``8})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``9})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``10})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``11})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给“开始委托”的第十一个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``12})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给“开始委托”的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给“开始委托”的第十二个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``13})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给“开始委托”的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给“开始委托”的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给“开始委托”的第十三个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``14})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给“开始委托”的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给“开始委托”的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给“开始委托”的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给“开始委托”的第十四个参数的类型。</typeparam>
            <typeparam name="TResult">”结束委托“返回的结果类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``4(System.Func{``0,``1,``2,``3,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``5(System.Func{``0,``1,``2,``3,``4,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``6(System.Func{``0,``1,``2,``3,``4,``5,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``7(System.Func{``0,``1,``2,``3,``4,``5,``6,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给“开始委托”的第十一个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给“开始委托”的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给“开始委托”的第十二个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给“开始委托”的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给“开始委托”的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给“开始委托”的第十三个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>将 Begin/End 调用函数对转换为异步函数。</summary>
            <typeparam name="TArg1">传递给“开始委托”的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给“开始委托”的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给“开始委托”的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给“开始委托”的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给“开始委托”的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给“开始委托”的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给“开始委托”的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给“开始委托”的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给“开始委托”的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给“开始委托”的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给“开始委托”的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给“开始委托”的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给“开始委托”的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给“开始委托”的第十四个参数的类型。</typeparam>
            <param name="begin">开始异步操作的委托。</param>
            <param name="end">结束异步操作的委托。</param>
            <returns>可用于启动异步操作并将结果（表示为 Unit 值）检索为可观察序列的函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> 或<paramref name="end"/>为空。</exception>
            <remarks>每次调用结果函数都将启动异步操作。对结果序列的订阅没有可观察到的副作用，每次序列都将产生异步操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})">
            <summary>异步调用指定的函数，通过可观察的序列显示结果。</summary>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">异步运行的函数。</param>
            <returns>暴露函数结果值或例外值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
            <remarks>
            <list type="bullet">
            <item><description>立即调用该函数，而不是在订阅结果序列期间调用。</description></item>
            <item><description>多次订阅结果序列时可以观察函数的结果。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>在指定的调度程序上异步调用指定的函数，通过可观察的序列显示结果</summary>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">异步运行的函数。</param>
            <param name="scheduler">运行该功能的调度程序。</param>
            <returns>暴露函数结果值或例外值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或 <paramref name="scheduler"/>为空。</exception>
            <remarks>
            <list type="bullet">
            <item><description>立即调用该函数，而不是在订阅结果序列期间调用。</description></item>
            <item><description>多次订阅结果序列时可以观察函数的结果。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>调用异步函数，通过可观察的序列显示结果。</summary>
            <typeparam name="TResult">异步函数返回的结果类型。</typeparam>
            <param name="functionAsync">要运行的异步函数。</param>
            <returns>暴露函数结果值或例外值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionAsync"/> 为空。</exception>
            <remarks>
            <list type="bullet">
            <item><description>该函数立即启动，而不是在订阅结果序列期间启动。</description></item>
            <item><description>多次订阅结果序列时可以观察函数的结果。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>调用异步函数，通过可观察的序列显示结果。CancellationToken 由生成的可观察序列上的所有订阅共享。有关详细信息，请参阅备注部分。</summary>
            <typeparam name="TResult">异步函数返回的结果类型。</typeparam>
            <param name="functionAsync">要运行的异步函数。</param>
            <returns>暴露函数结果值或例外值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionAsync"/> 为空。</exception>
            <remarks>
            <list type="bullet">
            <item><description>该函数立即启动，而不是在订阅结果序列期间启动。</description></item>
            <item><description>多次订阅结果序列时可以观察函数的结果。</description></item>
            <item><description>如果处理了对结果序列的任何订阅，则完成对 CancellationToken 的设置。与处理的订阅相关联的观察者将看不到 TaskCanceledException，但其他观察者将会看到。您可以使用 Catch 运算符来防止这种情况。由于此行为，在分发结果序列时要小心。最常见的做法是单次订阅控制 CancellationToken 状态的结果序列。或者，您可以使用多播运算符控制订阅行为。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Start(System.Action)">
            <summary>异步调用操作，通过可观察的序列显示结果。</summary>
            <param name="action">异步运行的操作。</param>
            <returns>在完成操作或异常时暴露单元值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
            <remarks>
            <list type="bullet">
            <item><description>立即调用该操作，而不是在订阅结果序列期间调用。</description></item>
            <item><description>多次订阅结果序列时可以操作的结果。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Start(System.Action,System.Reactive.Concurrency.IScheduler)">
            <summary>在指定的调度程序上异步调用操作，通过可观察的序列显示结果。</summary>
            <param name="action">异步运行的操作。</param>
            <param name="scheduler">运行该动作的调度程序。</param>
            <returns>在完成操作或异常时暴露单元值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <list type="bullet">
            <item><description>立即调用该操作，而不是在订阅结果序列期间调用。</description></item>
            <item><description>多次订阅结果序列时可以操作的结果。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>异步调用操作，通过可观察的序列显示结果。</summary>
            <param name="actionAsync">要运行的异步操作。</param>
            <returns>在完成操作或异常时暴露单元值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionAsync"/> 为空。</exception>
            <remarks>
            <list type="bullet">
            <item><description>立即开始操作，而不是在订阅结果序列期间开始操作。</description></item>
            <item><description>多次订阅结果序列时可以操作的结果。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartAsync(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>异步调用操作，通过可观察的序列显示结果。CancellationToken 由生成的可观察序列上的所有订阅共享。有关详细信息，请参阅备注部分。</summary>
            <param name="actionAsync">要运行的异步操作。</param>
            <returns>在完成操作或异常时暴露单元值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionAsync"/> 为空。</exception>
            <remarks>
            <list type="bullet">
            <item><description>立即开始操作，而不是在订阅结果序列期间开始操作。</description></item>
            <item><description>多次订阅结果序列时可以操作的结果。</description></item>
            <item><description>如果处理了对结果序列的任何订阅，则完成对 CancellationToken 的设置。与处理的订阅相关联的观察者将看不到 TaskCanceledException，但其他观察者将会看到。您可以使用 Catch 运算符来防止这种情况。由于此行为，在分发结果序列时要小心。最常见的做法是单次订阅控制 CancellationToken 状态的结果序列。或者，您可以使用多播运算符控制订阅行为。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>将异步函数转换为可观察的序列。每次订阅结果序列时都会启动函数。</summary>
            <typeparam name="TResult">异步函数返回的结果类型。</typeparam>
            <param name="functionAsync">要转换的异步函数。</param>
            <returns>一个可观察的序列，显示调用函数或异常的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionAsync"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>将异步函数转换为可观察的序列。每次订阅结果序列时都会启动函数。传递给异步函数的 CancellationToken 与可观察序列的订阅相关联，该订阅触发了函数的调用，可用于尽力消除。</summary>
            <typeparam name="TResult">异步函数返回的结果类型。</typeparam>
            <param name="functionAsync">要转换的异步函数。</param>
            <returns>一个可观察的序列，显示调用函数或异常的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionAsync"/> 为空。</exception>
            <remarks>当处理对结果序列的订阅时，将发信号通知馈送到异步函数的 CancellationToken。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>将异步操作转换为可观察序列。每次订阅结果序列时都会启动操作。</summary>
            <param name="actionAsync">要转换的异步操作。</param>
            <returns>在完成操作或异常时暴露单元值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionAsync"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsync(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>将异步操作转换为可观察序列。每次订阅结果序列时都会启动操作。传递给异步函数的 CancellationToken 与可观察序列的订阅相关联，该订阅触发了操作的调用，可用于尽力消除。</summary>
            <param name="actionAsync">要转换的异步操作。</param>
            <returns>在完成操作或异常时暴露单元值的可观察序列。</returns>
            <remarks>当处理对结果序列的订阅时，将发信号通知馈送到异步函数的 CancellationToken。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionAsync"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``1(System.Func{``0})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``1(System.Func{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``2(System.Func{``0,``1})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``2(System.Func{``0,``1},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``3(System.Func{``0,``1,``2})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``3(System.Func{``0,``1,``2},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``4(System.Func{``0,``1,``2,``3})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``4(System.Func{``0,``1,``2,``3},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``5(System.Func{``0,``1,``2,``3,``4},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``6(System.Func{``0,``1,``2,``3,``4,``5},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``7(System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``7(System.Func{``0,``1,``2,``3,``4,``5,``6},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给函数的第十三个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给函数的第十三个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给函数的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给函数的第十四个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给函数的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给函数的第十四个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给函数的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给函数的第十四个参数的类型。</typeparam>
            <typeparam name="TArg15">传递给函数的第十五个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给函数的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给函数的第十四个参数的类型。</typeparam>
            <typeparam name="TArg15">传递给函数的第十五个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16})">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给函数的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给函数的第十四个参数的类型。</typeparam>
            <typeparam name="TArg15">传递给函数的第十五个参数的类型。</typeparam>
            <typeparam name="TArg16">传递给函数的第十六个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步函数。每次调用生成的异步函数都会导致在指定的调度程序上调用原始同步函数。</summary>
            <typeparam name="TArg1">传递给函数的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给函数的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给函数的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给函数的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给函数的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给函数的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给函数的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给函数的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给函数的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给函数的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给函数的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给函数的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给函数的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给函数的第十四个参数的类型。</typeparam>
            <typeparam name="TArg15">传递给函数的第十五个参数的类型。</typeparam>
            <typeparam name="TArg16">传递给函数的第十六个参数的类型。</typeparam>
            <typeparam name="TResult">函数返回的结果类型。</typeparam>
            <param name="function">转换为异步函数的函数。</param>
            <param name="scheduler">调用原始函数的调度程序。</param>
            <returns>异步函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync(System.Action)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync(System.Action,System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``1(System.Action{``0})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``1(System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``2(System.Action{``0,``1})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``2(System.Action{``0,``1},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``3(System.Action{``0,``1,``2})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``3(System.Action{``0,``1,``2},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``4(System.Action{``0,``1,``2,``3})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``4(System.Action{``0,``1,``2,``3},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``5(System.Action{``0,``1,``2,``3,``4})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``5(System.Action{``0,``1,``2,``3,``4},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``6(System.Action{``0,``1,``2,``3,``4,``5})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``6(System.Action{``0,``1,``2,``3,``4,``5},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``7(System.Action{``0,``1,``2,``3,``4,``5,``6})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``7(System.Action{``0,``1,``2,``3,``4,``5,``6},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给该操作的第十三个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给该操作的第十三个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给该操作的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给该操作的第十四个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给该操作的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给该操作的第十四个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给该操作的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给该操作的第十四个参数的类型。</typeparam>
            <typeparam name="TArg15">传递给该操作的第十五个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给该操作的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给该操作的第十四个参数的类型。</typeparam>
            <typeparam name="TArg15">传递给该操作的第十五个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15})">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在默认调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给该操作的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给该操作的第十四个参数的类型。</typeparam>
            <typeparam name="TArg15">传递给该操作的第十五个参数的类型。</typeparam>
            <typeparam name="TArg16">传递给该操作的第十六个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},System.Reactive.Concurrency.IScheduler)">
            <summary>将函数转换为异步操作。每次调用生成的异步操作都会导致在指定的调度程序上调用原始同步操作。</summary>
            <typeparam name="TArg1">传递给该操作的第一个参数的类型。</typeparam>
            <typeparam name="TArg2">传递给该操作的第二个参数的类型。</typeparam>
            <typeparam name="TArg3">传递给该操作的第三个参数的类型。</typeparam>
            <typeparam name="TArg4">传递给该操作的第四个参数的类型。</typeparam>
            <typeparam name="TArg5">传递给该操作的第五个参数的类型。</typeparam>
            <typeparam name="TArg6">传递给该操作的第六个参数的类型。</typeparam>
            <typeparam name="TArg7">传递给该操作的第七个参数的类型。</typeparam>
            <typeparam name="TArg8">传递给该操作的第八个参数的类型。</typeparam>
            <typeparam name="TArg9">传递给该操作的第九个参数的类型。</typeparam>
            <typeparam name="TArg10">传递给该操作的第十个参数的类型。</typeparam>
            <typeparam name="TArg11">传递给该操作的第十一个参数的类型。</typeparam>
            <typeparam name="TArg12">传递给该操作的第十二个参数的类型。</typeparam>
            <typeparam name="TArg13">传递给该操作的第十三个参数的类型。</typeparam>
            <typeparam name="TArg14">传递给该操作的第十四个参数的类型。</typeparam>
            <typeparam name="TArg15">传递给该操作的第十五个参数的类型。</typeparam>
            <typeparam name="TArg16">传递给该操作的第十六个参数的类型。</typeparam>
            <param name="action">转换为异步操作的操作。</param>
            <param name="scheduler">调用原始操作的调度程序。</param>
            <returns>异步操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Action{System.EventHandler},System.Action{System.EventHandler})">
            <summary>基于<see cref="T:System.EventHandler"/>将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或 <paramref name="removeHandler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Action{System.EventHandler},System.Action{System.EventHandler},System.Reactive.Concurrency.IScheduler)">
            <summary>基于<see cref="T:System.EventHandler"/>将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Action{``0},System.Action{``0})">
            <summary>基于已提供的事件将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>基于已提供的事件将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0})">
            <summary>基于<see cref="T:System.EventHandler`1"/>将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="conversion">将给定事件处理程序转换为与基础.NET 事件兼容的委托的函数。生成的委托用于调用 addHandler 和 removeHandler 操作参数。</param>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversion"/> 或<paramref name="addHandler"/>或<paramref name="removeHandler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>基于<see cref="T:System.EventHandler`1"/>将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="conversion">将给定事件处理程序转换为与基础.NET 事件兼容的委托的函数。生成的委托用于调用 addHandler 和 removeHandler 操作参数。</param>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversion"/> 或<paramref name="addHandler"/>或<paramref name="removeHandler"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``3(System.Action{``0},System.Action{``0})">
            <summary>使用强类型发送程序参数基于已提供的事件委托将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TSender">引发事件的发送程序的类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``3(System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>使用强类型发送程序参数基于已提供的事件委托将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TSender">引发事件的发送程序的类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Action{System.EventHandler{``0}},System.Action{System.EventHandler{``0}})">
            <summary>基于<see cref="T:System.EventHandler`1"/>将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Action{System.EventHandler{``0}},System.Action{System.EventHandler{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>基于<see cref="T:System.EventHandler`1"/>将符合标准.NET 事件模式的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Object,System.String)">
            <summary>使用<see cref="T:System.EventArgs"/>程序将符合标准.NET 事件模式的实例.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据目标对象类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <param name="target">公开要转换的事件的对象实例。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> 或<paramref name="eventName"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Object,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>使用<see cref="T:System.EventArgs"/>程序将符合标准.NET 事件模式的实例.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据目标对象类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <param name="target">公开要转换的事件的对象实例。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> 或<paramref name="eventName"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Object,System.String)">
            <summary>使用强类型事件参数将符合标准.NET 事件模式的实例.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据目标对象类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="target">公开要转换的事件的对象实例。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> 或<paramref name="eventName"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。- 或 - 事件的第二个参数类型不能分配给 TEventArgs。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Object,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>使用强类型事件参数将符合标准.NET 事件模式的实例.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据目标对象类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="target">公开要转换的事件的对象实例。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> 或<paramref name="eventName"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。- 或 - 事件的第二个参数类型不能分配给 TEventArgs。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Object,System.String)">
            <summary>使用强类型发送程序和强类型事件参数将符合标准.NET 事件模式的实例.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据目标对象类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TSender">引发事件的发送程序的类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="target">公开要转换的事件的对象实例。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> 或<paramref name="eventName"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。- 或 - 事件的第一个参数类型不能分配给 TSender。- 或 - 事件的第二个参数类型不能分配给 TEventArgs。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Object,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>使用强类型发送程序和强类型事件参数将符合标准.NET 事件模式的实例.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据目标对象类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TSender">引发事件的发送程序的类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="target">公开要转换的事件的对象实例。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> 或<paramref name="eventName"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。- 或 - 事件的第一个参数类型不能分配给 TSender。- 或 - 事件的第二个参数类型不能分配给 TEventArgs。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Type,System.String)">
            <summary>使用<see cref="T:System.EventArgs"/>参数将符合标准.NET 事件模式的静态.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据指定的类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <param name="type">显示要转换的静态事件的类型。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> 或<paramref name="eventName"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Type,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>使用<see cref="T:System.EventArgs"/>参数将符合标准.NET 事件模式的静态.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据指定的类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <param name="type">显示要转换的静态事件的类型。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> 或<paramref name="eventName"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Type,System.String)">
            <summary>使用强类型事件参数将符合标准.NET 事件模式的静态.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据指定的类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="type">显示要转换的静态事件的类型。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> 或<paramref name="eventName"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。- 或 - 事件的第二个参数类型不能分配给 TEventArgs。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Type,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>使用强类型事件参数将符合标准.NET 事件模式的静态.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据指定的类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="type">显示要转换的静态事件的类型。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> 或<paramref name="eventName"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。- 或 - 事件的第二个参数类型不能分配给 TEventArgs。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Type,System.String)">
            <summary>使用强类型发送程序和强类型事件参数将符合标准.NET 事件模式的静态.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据指定的类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TSender">引发事件的发送程序的类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="type">显示要转换的静态事件的类型。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> 或<paramref name="eventName"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。- 或 - 事件的第一个参数类型不能分配给 TSender。- 或 - 事件的第二个参数类型不能分配给 TEventArgs。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEventPattern 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEventPattern 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEventPattern 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Type,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>使用强类型发送程序和强类型事件参数将符合标准.NET 事件模式的静态.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。反射用于根据指定的类型和指定的事件名称发现事件。要转换不符合标准.NET 事件模式的事件，请改用任何 FromEvent 过载。</summary>
            <typeparam name="TSender">引发事件的发送程序的类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="type">显示要转换的静态事件的类型。</param>
            <param name="eventName">要转换的事件的名称。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含基础.NET 事件调用的数据表示法的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> 或<paramref name="eventName"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">无法找到该事件。- 或 - 该事件不符合标准.NET 事件模式。- 或 - 事件的第一个参数类型不能分配给 TSender。- 或 - 事件的第二个参数类型不能分配给 TEventArgs。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEventPattern 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEventPattern 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``2(System.Func{System.Action{``1},``0},System.Action{``0},System.Action{``0})">
            <summary>使用转换函数将.NET 事件转换为可观察序列从而获取事件委托。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换符合标准.NET 事件模式的事件，请改用任意 FromEventPattern 重载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="conversion">将给定事件处理程序转换为与基础.NET 事件兼容的委托的函数。生成的委托用于调用 addHandler 和 removeHandler 操作参数。</param>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含事件参数对象的可观察序列，该对象传递给基础.NET 事件的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversion"/> 或<paramref name="addHandler"/>或<paramref name="removeHandler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEvent 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEvent 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEvent 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``2(System.Func{System.Action{``1},``0},System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>使用转换函数将.NET 事件转换为可观察序列从而获取事件委托。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换符合标准.NET 事件模式的事件，请改用任意 FromEventPattern 重载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="conversion">将给定事件处理程序转换为与基础.NET 事件兼容的委托的函数。生成的委托用于调用 addHandler 和 removeHandler 操作参数。</param>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含事件参数对象的可观察序列，该对象传递给基础.NET 事件的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversion"/> 或<paramref name="addHandler"/>或<paramref name="removeHandler"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEvent 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEvent 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``2(System.Action{``0},System.Action{``0})">
            <summary>使用提供的事件委托类型将.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换符合标准.NET 事件模式的事件，请改用任意 FromEventPattern 重载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含事件参数对象的可观察序列，该对象传递给基础.NET 事件的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEvent 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEvent 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEvent 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``2(System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>使用提供的事件委托类型将.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换符合标准.NET 事件模式的事件，请改用任意 FromEventPattern 重载。</summary>
            <typeparam name="TDelegate">要转换的事件的委托类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含事件参数对象的可观察序列，该对象传递给基础.NET 事件的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEvent 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEvent 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``1(System.Action{System.Action{``0}},System.Action{System.Action{``0}})">
            <summary>将基于操作的通用.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换符合标准.NET 事件模式的事件，请改用任意 FromEventPattern 重载。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含事件参数对象的可观察序列，该对象传递给基础.NET 事件的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEvent 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEvent 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEvent 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``1(System.Action{System.Action{``0}},System.Action{System.Action{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>将基于操作的通用.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换符合标准.NET 事件模式的事件，请改用任意 FromEventPattern 重载。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含事件参数对象的可观察序列，该对象传递给基础.NET 事件的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEvent 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEvent 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent(System.Action{System.Action},System.Action{System.Action})">
            <summary>将基于操作的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换符合标准.NET 事件模式的事件，请改用任意 FromEventPattern 重载。</summary>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <returns>包含事件参数对象的可观察序列，该对象传递给基础.NET 事件的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>当前<see cref="T:System.Threading.SynchronizationContext"/>在调用 FromEvent 期间捕获，用于发布添加和删除处理程序调用。此行为可确保根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>如果调用 FromEvent 时不存在 SynchronizationContext，则分别在发出 Subscribe 或 Dispose 调用的线程上同步添加和删除处理程序调用。</para>
            <para>由于 Reactive Extensions 的自由线程特性，建议将事件流查询表达式之外的 FromEvent 调用解除。这样做可以使捕获的 SynchronizationContext 可预测。此最佳实践还可以减少查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent(System.Action{System.Action},System.Action{System.Action},System.Reactive.Concurrency.IScheduler)">
            <summary>将基于操作的.NET 事件转换为可观察序列。每次事件调用都通过结果序列中的 OnNext 消息显示。要转换符合标准.NET 事件模式的事件，请改用任意 FromEventPattern 重载。</summary>
            <param name="addHandler">将给定事件处理程序附加到基础.NET 事件的操作。</param>
            <param name="removeHandler">将给定事件处理程序与基础.NET 事件分离的操作。</param>
            <param name="scheduler">运行添加和删除事件处理程序逻辑的调度程序。</param>
            <returns>包含事件参数对象的可观察序列，该对象传递给基础.NET 事件的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> 或<paramref name="removeHandler"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>只要观察者数量增长到大于零，即可添加和删除处理程序调用。此时，事件处理程序可以由多个同时活动的观察者通过多播主题共享。</para>
            <para>添加和删除处理程序调用在指定调度程序上运行。此行为允许根据某些 UI 框架的要求，从相同的上下文访问线程仿射事件的添加和删除处理程序操作。</para>
            <para>建议将事件流查询表达式之外的 FromEvent 调用解除。这种最佳实践减少了查询中桥接代码的混乱，使查询表达式更简洁，更易于理解。这对于省略 Ischeduler 参数的 FromEvent 的重载具有额外的好处。有关更多信息，请参阅有关这些重载的备注部分。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Aggregate``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})">
            <summary>在可观察序列上应用累加函数，返回累加结果作为结果序列中的单个元素。指定的种子值用作初始累加值。有关增量中间结果的累加操作，请参阅 <see cref="M:System.Reactive.Linq.Observable.Scan``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})"/>。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TAccumulate">累加结果的类型。</typeparam>
            <param name="source">累加的可观察序列。</param>
            <param name="seed">初始累加值。</param>
            <param name="accumulator">要在每个元素上调用的累加函数。</param>
            <returns>包含具有最终累加值的单个元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="accumulator"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Aggregate``3(System.IObservable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <summary>在可观察序列上应用累加函数，返回累加结果作为结果序列中的单个元素。指定的种子值用作初始累加值，指定的结果选择函数用于选择结果值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TAccumulate">累加值的类型。</typeparam>
            <typeparam name="TResult">结果值的类型。</typeparam>
            <param name="source">累加的可观察序列。</param>
            <param name="seed">初始累加值。</param>
            <param name="accumulator">要在每个元素上调用的累加函数。</param>
            <param name="resultSelector">将最终累加值转换为结果值的函数。</param>
            <returns>包含具有最终累加值的单个元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="accumulator"/>或<paramref name="resultSelector"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Aggregate``1(System.IObservable{``0},System.Func{``0,``0,``0})">
            <summary>在可观察序列上应用累加函数，返回累加结果作为结果序列中的单个元素。有关增量中间结果的累加操作，请参阅 <see cref="M:System.Reactive.Linq.Observable.Scan``1(System.IObservable{``0},System.Func{``0,``0,``0})"/>。</summary>
            <typeparam name="TSource">源序列中元素的类型和累加结果。</typeparam>
            <param name="source">累加的可观察序列。</param>
            <param name="accumulator">要在每个元素上调用的累加函数。</param>
            <returns>包含具有最终累加值的单个元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="accumulator"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.All``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>确定可观察序列的所有元素是否满足条件。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">元素应用谓词的可观察序列。</param>
            <param name="predicate">用于测试条件的每个元素的函数。</param>
            <returns>包含单个元素的可观察序列，用于确定源序列中的所有元素是否通过指定谓词中的测试。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Any``1(System.IObservable{``0})">
            <summary>确定可观察序列是否包含任何元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">非空性检查所用的可观察序列。</param>
            <returns>包含单个元素的可观察序列，用于确定源序列是否包含任何元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Any``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>确定可观察序列的任何元素是否满足条件。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">元素应用谓词的可观察序列。</param>
            <param name="predicate">用于测试条件的每个元素的函数。</param>
            <returns>包含单个元素的可观察序列，用于确定源序列中的所有元素是否通过指定谓词中的测试。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Double})">
            <summary>计算<see cref="T:System.Double"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的<see cref="T:System.Double"/>值序列。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Single})">
            <summary>计算<see cref="T:System.Single"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的<see cref="T:System.Single"/>值序列。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Decimal})">
            <summary>计算<see cref="T:System.Decimal"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的<see cref="T:System.Decimal"/>值序列。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Decimal.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Int32})">
            <summary>计算<see cref="T:System.Int32"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的<see cref="T:System.Int32"/>值序列。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Int64})">
            <summary>计算<see cref="T:System.Int64"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的<see cref="T:System.Int64"/>值序列。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Double}})">
            <summary>计算可空<see cref="T:System.Double"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的可空<see cref="T:System.Double"/>值序列。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Single}})">
            <summary>计算可空<see cref="T:System.Single"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的可空<see cref="T:System.Single"/>值序列。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Decimal}})">
            <summary>计算可空<see cref="T:System.Decimal"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的可空<see cref="T:System.Decimal"/>值序列。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Decimal.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Int32}})">
            <summary>计算可空<see cref="T:System.Int32"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的可空<see cref="T:System.Int32"/>值序列。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Int64}})">
            <summary>计算可空<see cref="T:System.Int64"/>值可观察序列的平均值。</summary>
            <param name="source">用于计算平均值的可空<see cref="T:System.Int64"/>值序列。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Decimal})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取<see cref="T:System.Decimal"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Decimal.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Double})">
            <summary>通过调用输入序列上每个元素的转换即可获取<see cref="T:System.Double"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Single})">
            <summary>通过调用输入序列上每个元素的转换即可获取<see cref="T:System.Single"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Int32})">
            <summary>通过调用输入序列上每个元素的转换即可获取<see cref="T:System.Int32"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Int64})">
            <summary>通过调用输入序列上每个元素的转换即可获取<see cref="T:System.Int64"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含单个元素的可观察序列，其中包含值序列的平均值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>通过调用输入序列上每个元素的转换即可获取可空<see cref="T:System.Decimal"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Decimal.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>通过调用输入序列上每个元素的转换即可获取可空<see cref="T:System.Double"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>通过调用输入序列上每个元素的转换即可获取可空<see cref="T:System.Single"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>通过调用输入序列上每个元素的转换即可获取可空<see cref="T:System.Int32"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>通过调用输入序列上每个元素的转换即可获取可空<see cref="T:System.Int64"/>值，计算该值可观察序列的平均值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算平均值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>包含具有值序列平均值的单个元素的可观察序列，如果源序列为空或仅包含空值，则为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Contains``1(System.IObservable{``0},``0)">
            <summary>使用默认的等式比较器确定可观察序列是否包含指定元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于定位数值的可观察序列。</param>
            <param name="value">要在源序列中定位的值。</param>
            <returns>包含单个元素的可观察序列，用于确定源序列是否包含具有指定值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Contains``1(System.IObservable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>通过使用指定的 System.Collections.Generic.IEqualityComparer&lt;T&gt; 确定可观察序列是否包含指定元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于定位数值的可观察序列。</param>
            <param name="value">要在源序列中定位的值。</param>
            <param name="comparer">用于比较元素的等式比较器。</param>
            <returns>包含单个元素的可观察序列，用于确定源序列是否包含具有指定值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Count``1(System.IObservable{``0})">
            <summary>返回可观察序列，其内包含<see cref="T:System.Int32"/>的表示了可观察序列中元素的总数。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">包含待计数元素的可观察序列。</param>
            <returns>一个可观察序列，其中包含的元素包含输入序列中的元素数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中的元素数大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Count``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回可观察序列，其内包含的<see cref="T:System.Int32"/>表示了指定可观察序列中满足条件的元素数。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">包含待计数元素的可观察序列。</param>
            <param name="predicate">用于测试条件的每个元素的函数。</param>
            <returns>返回可观察序列，其内包含的元素表示了输入序列中满足判定函数条件的元素数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ElementAt``1(System.IObservable{``0},System.Int32)">
            <summary>返回序列中指定索引处的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">返回元素的可观察序列。</param>
            <param name="index">要检索的元素的索引从零开始。</param>
            <returns>在源序列中指定位置上生成元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> 小于零。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">（异步） <paramref name="index"/>大于或等于源序列中的元素数。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ElementAtOrDefault``1(System.IObservable{``0},System.Int32)">
            <summary>返回序列中指定索引处的元素，如果索引超出范围，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">返回元素的可观察序列。</param>
            <param name="index">要检索的元素的索引从零开始。</param>
            <returns>一个可观察序列在源序列指定位置上生成元素；如果索引在源序列的边界之外，则生成默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0})">
            <summary>返回可观察序列的第一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>包含可观察序列中第一个元素的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回满足谓词中条件的可观察序列的第一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>包含可观察序列中满足谓词条件的第一个元素的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）没有元素满足谓词中的条件。- 或 - 源序列为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstOrDefaultAsync``1(System.IObservable{``0})">
            <summary>返回可观察序列的第一个元素，如果不存在此类元素，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>包含可观察序列中第一个元素的序列，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回可观察序列中满足谓词中条件的第一个元素，如果不存在此类元素，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>包含可观察序列中满足谓词条件的第一个元素的序列，或者如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.IsEmpty``1(System.IObservable{``0})">
            <summary>确定可观察序列是否为空。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">可空性检查所用的可观察序列。</param>
            <returns>可观察序列中包含的元素可用于确定源序列是否为空。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastAsync``1(System.IObservable{``0})">
            <summary>返回可观察序列的最后一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>包含可观察序列中最后一个元素的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回可观察序列中满足谓词中条件的最后一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>包含可观察序列中满足谓词条件的最后一个元素的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）没有元素满足谓词中的条件。- 或 - 源序列为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastOrDefaultAsync``1(System.IObservable{``0})">
            <summary>返回可观察序列的最后一个元素，如果不存在此类元素，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>包含可观察序列中最后一个元素的序列，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回满足谓词中条件的可观察序列的最后一个元素，如果不存在此类元素，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>包含可观察序列中满足谓词条件的最后一个元素的序列，或者如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LongCount``1(System.IObservable{``0})">
            <summary>返回可观察序列，其内包含的<see cref="T:System.Int64"/>表示了可观察序列中元素的总数。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">包含待计数元素的可观察序列。</param>
            <returns>一个可观察序列，其中包含的元素包含输入序列中的元素数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中的元素数大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LongCount``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回可观察序列，其内包含的<see cref="T:System.Int64"/>表示了指定可观察序列中满足条件的元素数。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">包含待计数元素的可观察序列。</param>
            <param name="predicate">用于测试条件的每个元素的函数。</param>
            <returns>返回可观察序列，其内包含的元素表示了输入序列中满足判定函数条件的元素数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0})">
            <summary>返回可观察序列中的最大元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">确定最大元素的可观察序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>返回可观察序列中的最大值（指定比较器的示值）。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">确定最大元素的可观察序列。</param>
            <param name="comparer">比较器用于比较元素。</param>
            <returns>可观察序列中包含的元素含源序列中的最大元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Double})">
            <summary>返回<see cref="T:System.Double"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的<see cref="T:System.Double"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Single})">
            <summary>返回<see cref="T:System.Single"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的<see cref="T:System.Single"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Decimal})">
            <summary>返回<see cref="T:System.Decimal"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的<see cref="T:System.Decimal"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Int32})">
            <summary>返回<see cref="T:System.Int32"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的<see cref="T:System.Int32"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Int64})">
            <summary>返回<see cref="T:System.Int64"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的<see cref="T:System.Int64"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Double}})">
            <summary>返回可空<see cref="T:System.Double"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的可空<see cref="T:System.Double"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Single}})">
            <summary>返回可空<see cref="T:System.Single"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的可空<see cref="T:System.Single"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Decimal}})">
            <summary>返回可空<see cref="T:System.Decimal"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的可空<see cref="T:System.Decimal"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Int32}})">
            <summary>返回可空<see cref="T:System.Int32"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的可空<see cref="T:System.Int32"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Int64}})">
            <summary>返回可空<see cref="T:System.Int64"/>值可观察序列中的最大值。</summary>
            <param name="source">用于确定最大值的可空<see cref="T:System.Int64"/>值序列。</param>
            <returns>可观察序列中包含的元素含源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>在序列的每个元素上调用转换函数并返回最大值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">从源序列中元素导出的对象类型，以确定最大值。</typeparam>
            <param name="source">用于确定最小元素的可观察序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值对应源序列中的最大元素值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>在序列的每个元素上调用转换函数并根据返回指定比较器上的最大值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">从源序列中元素导出的对象类型，以确定最大值。</typeparam>
            <param name="source">用于确定最小元素的可观察序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <param name="comparer">比较器用于比较元素。</param>
            <returns>可观察序列中包含的元素值对应源序列中的最大元素值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>或<paramref name="comparer"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Double})">
            <summary>在序列的每个元素上调用转换函数并返回最大 <see cref="T:System.Double"/> 值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Double"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Single})">
            <summary>在序列的每个元素上调用转换函数并返回最大 <see cref="T:System.Single"/> 值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Single"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Decimal})">
            <summary>在序列的每个元素上调用转换函数并返回最大 <see cref="T:System.Decimal"/> 值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Decimal"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Int32})">
            <summary>在序列的每个元素上调用转换函数并返回最大 <see cref="T:System.Int32"/> 值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Int32"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Int64})">
            <summary>在序列的每个元素上调用转换函数并返回最大 <see cref="T:System.Int64"/> 值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Int64"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>在序列的每个元素上调用转换函数并返回最大可空<see cref="T:System.Double"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Double&gt;"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>在序列的每个元素上调用转换函数并返回最大可空<see cref="T:System.Single"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Single&gt;"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>在序列的每个元素上调用转换函数并返回最大可空<see cref="T:System.Decimal"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Decimal&gt;"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>在序列的每个元素上调用转换函数并返回最大可空<see cref="T:System.Int32"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Int32&gt;"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>在序列的每个元素上调用转换函数并返回最大可空<see cref="T:System.Int64"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最大值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Int64&gt;"/>对应源序列中的最大值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MaxBy``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>返回可观察序列中键值最大的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的键类型。</typeparam>
            <param name="source">获取最大元素的可观察序列。</param>
            <param name="keySelector">键选择器函数。</param>
            <returns>可观察序列中键值最大的零个或多个元素列表。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MaxBy``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>返回可观察序列中键值（指定比较器示值）最大的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的键类型。</typeparam>
            <param name="source">获取最大元素的可观察序列。</param>
            <param name="keySelector">键选择器函数。</param>
            <param name="comparer">比较器用于比较键值。</param>
            <returns>可观察序列中键值最大的零个或多个元素列表。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="comparer"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0})">
            <summary>返回可观察序列中的最小元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小元素的可观察序列。</param>
            <returns>可观察序列中包含源序列中元素值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>返回可观察序列中的最小元素（指定比较器的示意值）。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小元素的可观察序列。</param>
            <param name="comparer">比较器用于比较元素。</param>
            <returns>可观察序列中包含源序列中元素值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Double})">
            <summary>返回<see cref="T:System.Double"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的<see cref="T:System.Double"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Single})">
            <summary>返回<see cref="T:System.Single"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的<see cref="T:System.Single"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Decimal})">
            <summary>返回<see cref="T:System.Decimal"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的<see cref="T:System.Decimal"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Int32})">
            <summary>返回<see cref="T:System.Int32"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的<see cref="T:System.Int32"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Int64})">
            <summary>返回<see cref="T:System.Int64"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的<see cref="T:System.Int64"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Double}})">
            <summary>返回可空<see cref="T:System.Double"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的可空<see cref="T:System.Double"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Single}})">
            <summary>返回可空<see cref="T:System.Single"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的可空<see cref="T:System.Single"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Decimal}})">
            <summary>返回可空<see cref="T:System.Decimal"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的可空<see cref="T:System.Decimal"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Int32}})">
            <summary>返回可空<see cref="T:System.Int32"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的可空<see cref="T:System.Int32"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Int64}})">
            <summary>返回可空<see cref="T:System.Int64"/>值可观察序列中的最小值。</summary>
            <param name="source">用于确定最小值的可空<see cref="T:System.Int64"/>值序列。</param>
            <returns>可观察序列中包含源序列中数值最小的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>在序列的每个元素上调用转换函数并返回最小值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">从源序列中元素导出的对象类型，以确定最小值。</typeparam>
            <param name="source">用于确定最小元素的可观察序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值对应源序列中的最小元素值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>在序列的每个元素上调用转换函数并根据返回指定比较器上的最小值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">从源序列中元素导出的对象类型，以确定最小值。</typeparam>
            <param name="source">用于确定最小元素的可观察序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <param name="comparer">比较器用于比较元素。</param>
            <returns>可观察序列中包含的元素值对应源序列中的最小元素值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Double})">
            <summary>在序列的每个元素上调用转换函数并返回最小<see cref="T:System.Double"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Double"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Single})">
            <summary>在序列的每个元素上调用转换函数并返回最小<see cref="T:System.Single"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Single"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Decimal})">
            <summary>在序列的每个元素上调用转换函数并返回最小<see cref="T:System.Decimal"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Decimal"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Int32})">
            <summary>在序列的每个元素上调用转换函数并返回最小<see cref="T:System.Int32"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Int32"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Int64})">
            <summary>在序列的每个元素上调用转换函数并返回最小<see cref="T:System.Int64"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Int64"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>在序列的每个元素上调用转换函数并返回最小可空<see cref="T:System.Double"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Double&gt;"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>在序列的每个元素上调用转换函数并返回最小可空<see cref="T:System.Single"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Single&gt;"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>在序列的每个元素上调用转换函数并返回最小可空<see cref="T:System.Decimal"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Decimal&gt;"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>在序列的每个元素上调用转换函数并返回最小可空<see cref="T:System.Int32"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Int32&gt;"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>在序列的每个元素上调用转换函数并返回最小可空<see cref="T:System.Int64"/>值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于确定最小值的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含的元素值<see cref="T:System.Nullable&lt;System.Int64&gt;"/>对应源序列中的最小值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MinBy``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>返回可观察序列中键值最小的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的键类型。</typeparam>
            <param name="source">获取最小元素的可观察序列。</param>
            <param name="keySelector">键选择器函数。</param>
            <returns>可观察序列中键值最小的零个或多个元素列表。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MinBy``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>返回可观察序列中键值（指定比较器示值）最小的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的键类型。</typeparam>
            <param name="source">获取最小元素的可观察序列。</param>
            <param name="keySelector">键选择器函数。</param>
            <param name="comparer">比较器用于比较键值。</param>
            <returns>可观察序列中键值最小的零个或多个元素列表。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>通过比较元素对确定两个序列是否相等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">第一个进行比较的可观察序列。</param>
            <param name="second">第二个进行比较的可观察序列。</param>
            <returns>可观察序列中包含的元素可根据各自的默认等式比较器指示两个序列是否长度相等且对应元素相等。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.IObservable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>使用指定的等式比较器成对地比较元素，确定两个序列是否相等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">第一个进行比较的可观察序列。</param>
            <param name="second">第二个进行比较的可观察序列。</param>
            <param name="comparer">比较器用于比较两个序列的元素。</param>
            <returns>可观察序列中包含的元素可根据指定等式比较器指示两个序列是否长度相等且对应元素相等。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>或<paramref name="comparer"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>通过成对比较元素来确定可观察序列和可枚举序列是否相等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">第一个进行比较的可观察序列。</param>
            <param name="second">第二个进行比较的可观察序列。</param>
            <returns>可观察序列中包含的元素可根据各自的默认等式比较器指示两个序列是否长度相等且对应元素相等。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>使用指定的等式比较器成对地比较元素，确定可观察和可枚举序列是否相等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">第一个进行比较的可观察序列。</param>
            <param name="second">第二个进行比较的可观察序列。</param>
            <param name="comparer">比较器用于比较两个序列的元素。</param>
            <returns>可观察序列中包含的元素可根据指定等式比较器指示两个序列是否长度相等且对应元素相等。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleAsync``1(System.IObservable{``0})">
            <summary>返回可观察序列的唯一元素，如果可观察序列中没有此元素，则报告异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>包含可观察序列中单个元素的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列包含多个元素。- 或 - 源序列为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回满足可观察序列中谓词中条件的的唯一元素，如果可观察序列中没有此元素，则报告异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>包含可观察序列中满足谓词条件的单个元素的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）没有元素满足谓词中的条件。- 或 - 多个元素满足谓词中的条件。- 或 - 源序列为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleOrDefaultAsync``1(System.IObservable{``0})">
            <summary>返回可观察序列的唯一元素，如果可观察序列为空，则返回默认值；如果可观察序列中有多个元素，则报告异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>包含可观察序列中单个元素的序列，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）源序列包含多个元素。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回可观察序列中与谓词匹配的唯一元素，如果不存在此类元素，则返回默认值;如果可观察序列中有多个元素，则引发异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>包含可观察序列中满足谓词条件的单个元素的序列，或者如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">（异步）序列包含多个满足谓词条件的元素。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Double})">
            <summary>计算<see cref="T:System.Double"/> 值序列的总和。</summary>
            <param name="source">用于计算总和的<see cref="T:System.Double"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Single})">
            <summary>计算<see cref="T:System.Single"/> 值序列的总和。</summary>
            <param name="source">用于计算总和的<see cref="T:System.Single"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Decimal})">
            <summary>计算<see cref="T:System.Decimal"/> 值序列的总和。</summary>
            <param name="source">用于计算总和的<see cref="T:System.Decimal"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Decimal.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Int32})">
            <summary>计算<see cref="T:System.Int32"/> 值序列的总和。</summary>
            <param name="source">用于计算总和的<see cref="T:System.Int32"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Int32.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Int64})">
            <summary>计算<see cref="T:System.Int64"/> 值序列的总和。</summary>
            <param name="source">用于计算总和的<see cref="T:System.Int64"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Double}})">
            <summary>计算可空<see cref="T:System.Double"/>值序列的总和。</summary>
            <param name="source">用于计算总和的可空<see cref="T:System.Double"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Single}})">
            <summary>计算可空<see cref="T:System.Single"/>值序列的总和。</summary>
            <param name="source">用于计算总和的可空<see cref="T:System.Single"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Decimal}})">
            <summary>计算可空<see cref="T:System.Decimal"/>值序列的总和。</summary>
            <param name="source">用于计算总和的可空<see cref="T:System.Decimal"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Decimal.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Int32}})">
            <summary>计算可空<see cref="T:System.Int32"/>值序列的总和。</summary>
            <param name="source">用于计算总和的可空<see cref="T:System.Int32"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Int32.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Int64}})">
            <summary>计算可空<see cref="T:System.Int64"/>值序列的总和。</summary>
            <param name="source">用于计算总和的可空<see cref="T:System.Int64"/>值序列。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的总和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Double})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取<see cref="T:System.Double"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Single})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取<see cref="T:System.Single"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Decimal})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取<see cref="T:System.Decimal"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Decimal.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Int32})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取<see cref="T:System.Int32"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Int32.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Int64})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取<see cref="T:System.Int64"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取可空<see cref="T:System.Double"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取可空<see cref="T:System.Single"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取可空<see cref="T:System.Decimal"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Decimal.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取可空<see cref="T:System.Int32"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Int32.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>通过调用输入序列上每个元素的转换函数即可获取可空<see cref="T:System.Int64"/>值，计算该值序列的总和。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">用于计算总和的值序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>可观察序列中包含源序列中总和数值的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.OverflowException">（异步）源序列中元素的投影值之和大于 <see cref="M:System.Int64.MaxValue"/>。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToArray``1(System.IObservable{``0})">
            <summary>从可观察序列创建数组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素数组的源可观察序列。</param>
            <returns>可观察序列包含的元素含源序列中所有元素的数组。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToDictionary``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>根据指定的键选择器函数从可观察序列创建字典。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的字典键类型。</typeparam>
            <param name="source">用于创建字典的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <returns>可观察序列中包含的元素字典将唯一键值映射到相应的源序列元素上。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToDictionary``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器从可观察序列创建字典。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的字典键类型。</typeparam>
            <param name="source">用于创建字典的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="comparer">比较密钥的等式比较器。</param>
            <returns>可观察序列中包含的元素字典将唯一键值映射到相应的源序列元素上。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToDictionary``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>根据指定的键选择器函数和元素选择器函数从可观察序列创建字典。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的字典键类型。</typeparam>
            <typeparam name="TElement">源序列中每个元素计算得出的字典值类型。</typeparam>
            <param name="source">用于创建字典的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">用于从每个元素生成结果元素值的转换函数。</param>
            <returns>可观察序列中包含的元素字典将唯一键值映射到相应的源序列元素上。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToDictionary``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数、比较器和元素选择器函数从可观察序列创建字典。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的字典键类型。</typeparam>
            <typeparam name="TElement">源序列中每个元素计算得出的字典值类型。</typeparam>
            <param name="source">用于创建字典的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">用于从每个元素生成结果元素值的转换函数。</param>
            <param name="comparer">比较密钥的等式比较器。</param>
            <returns>可观察序列中包含的元素字典将唯一键值映射到相应的源序列元素上。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>或<paramref name="comparer"/>空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToList``1(System.IObservable{``0})">
            <summary>从可观察序列创建列表。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素列表的源可观察序列。</param>
            <returns>可观察序列包含的元素含源序列中所有元素的列表。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToLookup``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>根据指定的键选择器函数从可观察序列创建查找。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中每个元素计算得出的查找键类型。</typeparam>
            <param name="source">用于创建查找的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <returns>可观察序列中包含的元素查找将唯一键值映射到相应的源序列元素上。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToLookup``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器从可观察序列创建查找。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中每个元素计算得出的查找键类型。</typeparam>
            <param name="source">用于创建查找的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="comparer">比较密钥的等式比较器。</param>
            <returns>可观察序列中包含的元素查找将唯一键值映射到相应的源序列元素上。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToLookup``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>根据指定的键选择器函数和元素选择器函数从可观察序列创建查找。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中每个元素计算得出的查找键类型。</typeparam>
            <typeparam name="TElement">源序列中每个元素计算得出的查找值类型。</typeparam>
            <param name="source">用于创建查找的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">用于从每个元素生成结果元素值的转换函数。</param>
            <returns>可观察序列中包含的元素查找将唯一键值映射到相应的源序列元素上。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToLookup``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数，比较器和元素选择器函数，从可观察序列创建查找。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中每个元素计算得出的查找键类型。</typeparam>
            <typeparam name="TElement">源序列中每个元素计算得出的查找值类型。</typeparam>
            <param name="source">用于创建查找的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">用于从每个元素生成结果元素值的转换函数。</param>
            <param name="comparer">比较密钥的等式比较器。</param>
            <returns>可观察序列中包含的元素查找将唯一键值映射到相应的源序列元素上。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>或<paramref name="comparer"/>为空。</exception>
            <remarks>此运算符的返回类型与 Ienumerable 上的相应运算符不同，以便保留异步行为。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GetAwaiter``1(System.IObservable{``0})">
            <summary>获取一个 awaiter，它返回可观察序列的最后一个值，如果序列为空，则显示异常。此操作订阅可观察序列，使其变成热键。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">需等待的源序列。</param>
            <returns>可以等待的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GetAwaiter``1(System.Reactive.Subjects.IConnectableObservable{``0})">
            <summary>获取一个 awaiter，它返回可观察序列的最后一个值，如果序列为空，则显示异常。此操作订阅并连接到可观察序列，使其变热。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">需等待的源序列。</param>
            <returns>可以等待的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.RunAsync``1(System.IObservable{``0},System.Threading.CancellationToken)">
            <summary>获取一个 awaiter，它返回可观察序列的最后一个值，如果序列为空，则显示异常。此操作订阅可观察序列，使其变成热键。提供的 CancellationToken 可用于取消订阅。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">需等待的源序列。</param>
            <param name="cancellationToken">取消令牌。</param>
            <returns>可以等待的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.RunAsync``1(System.Reactive.Subjects.IConnectableObservable{``0},System.Threading.CancellationToken)">
            <summary>获取一个 awaiter，它返回可观察序列的最后一个值，如果序列为空，则显示异常。此操作订阅并连接到可观察序列，使其变热。提供的 CancellationToken 可用于取消订阅和连接。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">需等待的源序列。</param>
            <param name="cancellationToken">取消令牌。</param>
            <returns>可以等待的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Multicast``2(System.IObservable{``0},System.Reactive.Subjects.ISubject{``0,``1})">
            <summary>通过指定主题将源序列通知多播到生成的可连接的可观察对象。连接可连接的可观察对象时，主题正好订阅了一个源，并且消息被转发给在可连接的可观察对象中注册的观察者。对于具有固定主题的专业化，请参阅 Publish、PublishLast 和 Replay。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">其上元素将被推送至指定主题的源序列。</param>
            <param name="subject">接收源元素的主题。</param>
            <returns>可连接的可观察序列，在连接时导致源序列将结果推送至指定的主题。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="subject"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Multicast``3(System.IObservable{``0},System.Func{System.Reactive.Subjects.ISubject{``0,``1}},System.Func{System.IObservable{``1},System.IObservable{``2}})">
            <summary>通过实例化主题将源序列通知多播到选择器函数内的序列的所有应用中。每次订阅结果序列都会导致单独的多播调用，从而公开选择器函数调用产生的序列。对于具有固定主题的专业化，请参阅 Publish、PublishLast 和 Replay。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TIntermediate">中间主题产生的元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列将在指定的选择器函数中进行多播。</param>
            <param name="subjectSelector">工厂函数用于创建中间主题，源序列的元素将通过该主题多播到选择器函数。</param>
            <param name="selector">选择器函数，可以使用已创建主题强制执行的策略的多播源序列。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="subjectSelector"/>或<paramref name="selector"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Publish``1(System.IObservable{``0})">
            <summary>返回可连接的可观察序列，该序列共享对基础序列的单次订阅。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.Subject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>订阅者将在订阅时收到源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.Subject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Publish``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}})">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.Subject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将在订阅时收到源的所有通知。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <seealso cref="T:System.Reactive.Subjects.Subject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Publish``1(System.IObservable{``0},``0)">
            <summary>返回可连接的可观察序列，该序列共享对基础序列的单次订阅并使用 initialValue 启动。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.BehaviorSubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="initialValue">观察着在订阅时收到的初始值。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>订阅者将立即收到初始值，然后是订阅时所有源的通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.BehaviorSubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Publish``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},``0)">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅并使用 initialValue 启动。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.BehaviorSubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将立即收到初始值，然后是订阅时所有源的通知。</param>
            <param name="initialValue">观察着在订阅时收到的初始值。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <seealso cref="T:System.Reactive.Subjects.BehaviorSubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.PublishLast``1(System.IObservable{``0})">
            <summary>返回可连接的可观察序列，该序列共享对基础序列的单次订阅，而基础序列内仅包含最后一项通知。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.AsyncSubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>订阅者只会收到源的最后一项通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.AsyncSubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.PublishLast``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}})">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而基础序列内仅包含最后一项通知。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.AsyncSubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者只会收到源的最后一项通知。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <seealso cref="T:System.Reactive.Subjects.AsyncSubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.RefCount``1(System.Reactive.Subjects.IConnectableObservable{``0})">
            <summary>返回一个可观察序列，只要至少订阅一次，它就会保持与源的连接。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">可连接的可观察序列。</param>
            <returns>只要至少订阅一次可观察序列，它就会保持与源的连接。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0})">
            <summary>返回可连接的可观察序列，该序列共享对基础序列的单次订阅，而该基础序列重放所有通知。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>订阅者将收到源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>返回可连接的可观察序列，该序列共享对基础序列的单次订阅，而该基础序列重放所有通知。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="scheduler">将调用连接的观察者的调度程序。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <remarks>订阅者将收到源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}})">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而该基础序列重放所有通知。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将收到源的所有通知。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而该基础序列重放所有通知。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将收到源的所有通知。</param>
            <param name="scheduler">将调用选择器函数内连接的观察者的调度程序。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>或<paramref name="scheduler"/> 为空。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.TimeSpan)">
            <summary>返回一个可连接的可观察序列，该序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大时间长度的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <remarks>订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.TimeSpan)">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大时间长度的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可连接的可观察序列，该序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大时间长度的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <param name="scheduler">将调用连接的观察者的调度程序。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <remarks>订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大时间长度的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <param name="scheduler">将调用选择器函数内连接的观察者的调度程序。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>返回可连接的可观察序列，该序列共享对基础序列的单次订阅，而该基础序列重放 bufferSize 通知。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="scheduler">将调用连接的观察者的调度程序。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
            <remarks>订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大元素计数的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</param>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="scheduler">将调用选择器函数内连接的观察者的调度程序。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Int32)">
            <summary>返回一个可连接的可观察序列，该序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大元素计数的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
            <remarks>订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Int32)">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大元素计数的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</param>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Int32,System.TimeSpan)">
            <summary>返回一个可连接的可观察序列，该序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大时间长度和最大元素计数的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <remarks>订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Int32,System.TimeSpan)">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大时间长度和最大元素计数的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</param>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Int32,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可连接的可观察序列，该序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大时间长度和最大元素计数的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <param name="scheduler">将调用连接的观察者的调度程序。</param>
            <returns>可连接的可观察序列共享对基础序列的单次订阅。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <remarks>订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Int32,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察序列，该序列是在可连接的可观察序列上调用选择器的结果，该可连接序列共享对基础序列的单次订阅，而该基础序列受重放缓冲区最大时间长度和最大元素计数的影响。此运算符是对使用常规<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>的多播的专业化 。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型。</typeparam>
            <param name="source">源序列上的元素将通过单次共享订阅进行多播。</param>
            <param name="selector">选择器函数，可以根据需要多次使用多播源序列，而不会导致源序列的多次订阅。给定源的订阅者将收到符合指定重放缓冲区修剪策略的源的所有通知。</param>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <param name="scheduler">将调用选择器函数内连接的观察者的调度程序。</param>
            <returns>一个可观察序列，包含通过在选择器函数内多播源序列而产生的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Chunkify``1(System.IObservable{``0})">
            <summary>生成源序列的连续（可能为空）块的可枚举序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>在每次迭代时返回连续（可能为空）块的可枚举序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Collect``2(System.IObservable{``0},System.Func{``1},System.Func{``1,``0,``1})">
            <summary>生成一个可枚举的序列，该序列返回在连续迭代之间从源序列收集/聚集的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">收集期间合并操作生成的元素类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="newCollector">Factory 创建一个新的收集器对象。</param>
            <param name="merge">将序列元素与当前收集器合并。</param>
            <returns>可枚举序列，在每次迭代时从源序列返回收集/聚集的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="newCollector"/>或<paramref name="merge"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Collect``2(System.IObservable{``0},System.Func{``1},System.Func{``1,``0,``1},System.Func{``1,``1})">
            <summary>生成一个可枚举的序列，该序列返回在连续迭代之间从源序列收集/聚集的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">收集期间合并操作生成的元素类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="getInitialCollector">Factory 创建初始收集器对象。</param>
            <param name="merge">将序列元素与当前收集器合并。</param>
            <param name="getNewCollector">Factory 用新的收集器替换当前收集器。</param>
            <returns>可枚举序列，在每次迭代时从源序列返回收集/聚集的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="getInitialCollector"/>或<paramref name="merge"/>或<paramref name="getNewCollector"/>空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.First``1(System.IObservable{``0})">
            <summary>返回可观察序列的第一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可观察序列中的第一个元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">源序列为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.First``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回满足谓词中条件的可观察序列的第一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>可观察序列中的第一个元素，它满足谓词中的条件。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">没有元素满足谓词中的条件。- 或 - 源序列为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstOrDefault``1(System.IObservable{``0})">
            <summary>返回可观察序列的第一个元素，如果不存在此类元素，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可观察序列中的第一个元素，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.FirstOrDefaultAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstOrDefault``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回可观察序列中满足谓词中条件的第一个元素，如果不存在此类元素，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>可观察序列中的第一个元素，它满足谓词中的条件，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.FirstOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEach``1(System.IObservable{``0},System.Action{``0})">
            <summary>为可观察序列中的每个元素调用一个动作，并阻塞直到序列终止。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
            <remarks>由于其阻塞特性，该运算符主要用于测试。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEach``1(System.IObservable{``0},System.Action{``0,System.Int32})">
            <summary>采用元素的索引为可观察序列中的每个元素调用一个动作，并阻塞直到序列终止。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
            <remarks>由于其阻塞特性，该运算符主要用于测试。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GetEnumerator``1(System.IObservable{``0})">
            <summary>返回枚举可观察序列中所有值的枚举器。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取枚举器的可观察序列。</param>
            <returns>可用于枚举可观察序列中的元素的枚举器。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Last``1(System.IObservable{``0})">
            <summary>返回可观察序列的最后一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可观察序列中的最后一个元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">源序列为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.LastAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Last``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回可观察序列中满足谓词中条件的最后一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>可观察序列中的最后一个元素，它满足谓词中的条件。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">没有元素满足谓词中的条件。- 或 - 源序列为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.LastAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastOrDefault``1(System.IObservable{``0})">
            <summary>返回可观察序列的最后一个元素，如果不存在此类元素，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可观察序列中的最后一个元素，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.LastOrDefaultAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastOrDefault``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回满足谓词中条件的可观察序列的最后一个元素，如果不存在此类元素，则返回默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>可观察序列中的最后一个元素，它满足谓词中的条件，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.LastOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Latest``1(System.IObservable{``0})">
            <summary>返回一个可枚举的序列，其枚举返回源可观察序列中最新观察到的元素。结果序列上的枚举器绝不会重复生成相同的元素，并将阻塞直到下一个元素可用。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可枚举序列，在每次迭代时返回最后一个采样元素，然后阻塞，直到可观察源序列中的下一个元素变为可用。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MostRecent``1(System.IObservable{``0},``0)">
            <summary>返回一个可枚举的序列，其枚举返回源可观察序列中最近观察到的元素，如果尚未对元素进行采样，则使用指定的初始值。结果序列上的枚举器永远不会阻塞，并且可以重复生成相同的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="initialValue">如果尚未对任何元素进行采样，则可枚举序列将生成初始值。</param>
            <returns>可枚举序列，在每次迭代时返回最后一个采样元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Next``1(System.IObservable{``0})">
            <summary>返回一个可枚举的序列，其枚举将阻塞，直到源可观察序列中的下一个元素变为可用。结果序列上的枚举器将阻塞，直到下一个元素可用。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可枚举序列在每次迭代时阻塞，直到可观察源序列中的下一个元素变为可用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Single``1(System.IObservable{``0})">
            <summary>返回可观察序列的唯一元素，如果可观察序列中没有此类元素，则引发异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可观察序列中的单个元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">源序列包含多个元素。- 或 - 源序列为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.SingleAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Single``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回满足可观察序列中满足谓词中条件的的唯一元素，如果没有此元素，则引发异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>可观察序列中满足谓词条件的单个元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">没有元素满足谓词中的条件。- 或 - 多个元素满足谓词中的条件。- 或 - 源序列为空。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.SingleAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleOrDefault``1(System.IObservable{``0})">
            <summary>返回可观察序列的唯一元素，如果可观察序列为空，则返回默认值；如果可观察序列中有多个元素，则引发异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可观察序列中的单个元素，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">源序列包含多个元素。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.SingleOrDefaultAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleOrDefault``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>返回可观察序列中满足谓词条件的唯一元素，如果不存在此类元素，则返回默认值;如果可观察序列中有多个元素满足谓词条件，则引发异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <param name="predicate">用于评估源序列中元素的谓词函数。</param>
            <returns>可观察序列中的单个元素，它满足谓词中的条件，如果不存在此类元素，则为默认值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
            <exception cref="T:System.InvalidOperationException">该序列包含多个满足谓词条件的元素。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.SingleOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Wait``1(System.IObservable{``0})">
            <summary>等待可观察序列完成并返回序列的最后一个元素。如果序列终止时发出 OnError 通知，则引发异常。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源可观察序列。</param>
            <returns>可观察序列中的最后一个元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.InvalidOperationException">源序列为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ObserveOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>包装源序列，以便在指定的调度程序上运行观察者回调。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="scheduler">调度程序通知观察者。</param>
            <returns>观察发生在指定调度程序上的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <remarks>这仅调用调度程序上的观察者回调。如果订阅和/或取消订阅操作的副作用是需要在调度程序上运行，请使用<see cref="M:System.Reactive.Linq.Observable.SubscribeOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)"/>。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ObserveOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)">
            <summary>包装源序列，以便在指定的同步上下文运行观察者回调。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="context">同步上下文通知观察者。</param>
            <returns>观察发生在指定同步上下文中的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="context"/>为空。</exception>
            <remarks>这仅在同步上下文调用观察者回调。如果订阅和/或取消订阅操作的副作用是需要在同步上下文上运行，请使用<see cref="M:System.Reactive.Linq.Observable.SubscribeOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)"/>。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SubscribeOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>包装源序列，以便在指定的调度程序上运行其订阅和取消订阅逻辑。此操作不常用；有关 SubscribeOn 和 ObserveOn 之间区别的更多信息，请参阅备注部分。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="scheduler">调度程序执行订阅和取消订阅操作。</param>
            <returns>订阅和取消订阅发生在指定调度程序上的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <remarks>这仅对指定的调度程序执行订阅和取消订阅的副作用。要在调度程序上调用观察者回调，请使用 <see cref="M:System.Reactive.Linq.Observable.ObserveOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)"/>。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SubscribeOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)">
            <summary>包装源序列，以便在指定的同步上下文运行订阅和取消订阅逻辑。此操作不常用；有关 SubscribeOn 和 ObserveOn 之间区别的更多信息，请参阅备注部分。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="context">用于执行订阅和取消订阅操作的同步上下文。</param>
            <returns>订阅和取消订阅发生在指定同步上下文的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="context"/>为空。</exception>
            <remarks>这仅对指定的同步上下文执行订阅和取消订阅的副作用。要在同步上下文调用观察者回调，请使用 <see cref="M:System.Reactive.Linq.Observable.ObserveOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)"/>。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Synchronize``1(System.IObservable{``0})">
            <summary>同步可观察序列，以便无法同时传递观察者通知。此重载对于“修复”一个可观察序列非常有用，该序列在各个观察者上展示并发回调，但这对查询处理器来说是无效行为。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <returns>对观察者的传出调用进行同步的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>根据观察者语法，序列在给定的观察者上展示并发回调是无效的行为。此运算符可用于“修复”不符合此规则的源。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Synchronize``1(System.IObservable{``0},System.Object)">
            <summary>同步可观察序列，以便无法使用指定的门对象同时传递观察者通知。在编写 n 元查询运算符时，此重载非常有用，以便通过在公共门对象上进行同步来防止来自不同源的并发回调。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="gate">门对象用于同步每个观察者调用。</param>
            <returns>在给定门对象上同步观察者的传出调用的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="gate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Subscribe``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0})">
            <summary>为可枚举序列订阅观察者。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">订阅的可枚举序列。</param>
            <param name="observer">将从可枚举序列接收通知的观察者。</param>
            <returns>可用于从可枚举序列中取消订阅观察者的可处置对象</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="observer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Subscribe``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序为可枚举序列预订观察者以运行枚举循环。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">订阅的可枚举序列。</param>
            <param name="observer">将从可枚举序列接收通知的观察者。</param>
            <param name="scheduler">调度程序执行枚举。</param>
            <returns>可用于从可枚举序列中取消订阅观察者的可处置对象</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="observer"/>或<paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToEnumerable``1(System.IObservable{``0})">
            <summary>将可观察序列转换为可枚举序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">可转换为可枚举序列的可观察序列。</param>
            <returns>包含可观察序列中元素的可枚举序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})">
            <summary>使用基于操作的.NET 事件将可观察序列公开为对象。</summary>
            <param name="source">可观察的源序列。</param>
            <returns>事件源对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToEvent``1(System.IObservable{``0})">
            <summary>使用 Action&lt;TSource&gt;-based .NET 事件将可观察序列公开为对象。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">可观察的源序列。</param>
            <returns>事件源对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})">
            <summary>使用符合标准.NET 事件模式的.NET 事件将可观察序列公开为对象。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
            <param name="source">可观察的源序列。</param>
            <returns>事件源对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>将可枚举序列转换为可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">转换为可观察序列的可枚举序列。</param>
            <returns>可观察序列的元素从给定的可枚举序列中拉取。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序将可枚举序列转换为可观察序列以运行枚举循环。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">转换为可观察序列的可枚举序列。</param>
            <param name="scheduler">调度程序运行输入序列的枚举。</param>
            <returns>可观察序列的元素从给定的可枚举序列中拉取。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.IDisposable})">
            <summary>从指定的订阅方法实现创建可观察序列。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="subscribe">生成的可观察序列的订阅方法的实现。</param>
            <returns>具有订阅方法的指定实现的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribe"/> 为空。</exception>
            <remarks>使用此运算符优于手动实现 IObservable&lt;T&gt; interface。如果需要 IObservable&lt;T&gt; 而非匿名，则考虑使用 <see cref="T:System.Reactive.ObservableBase`1"/> 抽象基类。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Action})">
            <summary>从指定的订阅方法实现创建可观察序列。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="subscribe">生成可观察序列的订阅方法的实现，返回将包含在 Idisposable 中的操作委托。</param>
            <returns>具有订阅方法的指定实现的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribe"/> 为空。</exception>
            <remarks>使用此运算符优于手动实现 IObservable&lt;T&gt; interface。如果需要 IObservable&lt;T&gt; 而非匿名，则考虑使用 <see cref="T:System.Reactive.ObservableBase`1"/> 抽象基类。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>从指定的可取消异步订阅方法创建可观察序列。传递给异步订阅方法的 CancellationToken 与返回的可处置订阅绑定，允许尽力取消。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="subscribeAsync">用于生成元素的异步方法。</param>
            <returns>可观察序列表示异步方法生成的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> 为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
            <remarks>当处理对结果序列的订阅时，将发信号通知馈送到异步订阅函数的 CancellationToken。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.Tasks.Task})">
            <summary>从指定的异步订阅方法创建可观察序列。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="subscribeAsync">用于生成元素的异步方法。</param>
            <returns>可观察序列表示异步方法生成的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> 为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>从指定的可取消异步订阅方法创建可观察序列。传递给异步订阅方法的 CancellationToken 与返回的可处置订阅绑定，允许尽力取消。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="subscribeAsync">用于实现结果序列订阅方法的异步方法。</param>
            <returns>具有订阅方法的指定实现的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> 为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
            <remarks>当处理对结果序列的订阅时，将发信号通知馈送到异步订阅函数的 CancellationToken。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>从指定的异步订阅方法创建可观察序列。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="subscribeAsync">用于实现结果序列订阅方法的异步方法。</param>
            <returns>具有订阅方法的指定实现的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> 为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Action}})">
            <summary>从指定的可取消异步订阅方法创建可观察序列。传递给异步订阅方法的 CancellationToken 与返回的可处置订阅绑定，允许尽力取消。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="subscribeAsync">用于实现结果序列的订阅方法的异步方法，返回将包含在 Idisposable 中的操作委托。</param>
            <returns>具有订阅方法的指定实现的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> 为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
            <remarks>当处理对结果序列的订阅时，将发信号通知馈送到异步订阅函数的 CancellationToken。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.Tasks.Task{System.Action}})">
            <summary>从指定的异步订阅方法创建可观察序列。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="subscribeAsync">用于实现结果序列的订阅方法的异步方法，返回将包含在 Idisposable 中的操作委托。</param>
            <returns>具有订阅方法的指定实现的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> 为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Defer``1(System.Func{System.IObservable{``0}})">
            <summary>返回一个可观察的序列，只要新的观察者订阅，就会调用指定的工厂函数。</summary>
            <typeparam name="TResult">工厂函数返回的序列中元素的类型，以及生成的序列中元素的类型。</typeparam>
            <param name="observableFactory">被订阅生成序列的每个观察者调用的可观察的工厂函数。</param>
            <returns>一个可观察的序列，其观察者触发给定的可观察工厂函数的调用。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observableFactory"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Defer``1(System.Func{System.Threading.Tasks.Task{System.IObservable{``0}}})">
            <summary>返回一个可观察的序列，只要新的观察者订阅，它就会启动指定的异步工厂函数。</summary>
            <typeparam name="TResult">工厂函数返回的序列中元素的类型，以及生成的序列中元素的类型。</typeparam>
            <param name="observableFactoryAsync">为订阅结果序列的每个观察者启动异步工厂函数。</param>
            <returns>一个可观察的序列，其观察者触发要启动的给定异步可观察工厂函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observableFactoryAsync"/> 为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DeferAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IObservable{``0}}})">
            <summary>返回一个可观察序列，只要新观察者订阅，它就会启动指定的可取消异步工厂函数。传递给异步工厂函数的 CancellationToken 与返回的可处置订阅绑定，允许尽力取消。</summary>
            <typeparam name="TResult">工厂函数返回的序列中元素的类型，以及生成的序列中元素的类型。</typeparam>
            <param name="observableFactoryAsync">为订阅结果序列的每个观察者启动异步工厂函数。</param>
            <returns>一个可观察的序列，其观察者触发要启动的给定异步可观察工厂函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observableFactoryAsync"/> 为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
            <remarks>当处理对结果序列的订阅时，将发信号通知馈送到异步可观察工厂函数的 CancellationToken。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Empty``1">
            <summary>返回一个空的可观察序列。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <returns>一个没有元素的可观察序列。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Empty``1(``0)">
            <summary>返回一个空的可观察序列。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <param name="witness">仅用于推断<typeparamref name="TResult"/>类参数的对象。通常在创建匿名元素序列时使用此参数。</param>
            <returns>一个没有元素的可观察序列。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Empty``1(System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个空的可观察序列，使用指定的调度程序发出一条 OnCompleted 消息。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <param name="scheduler">调度程序发送终止调用。</param>
            <returns>一个没有元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Empty``1(System.Reactive.Concurrency.IScheduler,``0)">
            <summary>返回一个空的可观察序列，使用指定的调度程序发出一条 OnCompleted 消息。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <param name="scheduler">调度程序发送终止调用。</param>
            <param name="witness">仅用于推断<typeparamref name="TResult"/>类参数的对象。通常在创建匿名元素序列时使用此参数。</param>
            <returns>一个没有元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1})">
            <summary>通过运行生成序列元素的状态驱动循环来生成可观察序列。</summary>
            <typeparam name="TState">生成器循环中使用的状态类型。</typeparam>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="initialState">初始状态。</param>
            <param name="condition">终止生成的条件（返回 false 时）。</param>
            <param name="iterate">迭代步骤函数。</param>
            <param name="resultSelector">序列中生成结果的选择器函数。</param>
            <returns>生成的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或<paramref name="iterate"/>或<paramref name="resultSelector"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Reactive.Concurrency.IScheduler)">
            <summary>通过运行生成序列元素的状态驱动循环生成可观察序列，使用指定的调度程序发送观察者消息。</summary>
            <typeparam name="TState">生成器循环中使用的状态类型。</typeparam>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="initialState">初始状态。</param>
            <param name="condition">终止生成的条件（返回 false 时）。</param>
            <param name="iterate">迭代步骤函数。</param>
            <param name="resultSelector">序列中生成结果的选择器函数。</param>
            <param name="scheduler">用于运行生成器循环的调度程序。</param>
            <returns>生成的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或<paramref name="iterate"/>或<paramref name="resultSelector"/>或<paramref name="scheduler"/>空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Never``1">
            <summary>返回一个非终止可观察序列，它可用于表示无限持续时间（例如，当使用反应连接时）。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <returns>一个可观察的序列，其观察者永远不会被调用。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Never``1(``0)">
            <summary>返回一个非终止可观察序列，它可用于表示无限持续时间（例如，当使用反应连接时）。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <param name="witness">仅用于推断<typeparamref name="TResult"/>类参数的对象。通常在创建匿名元素序列时使用此参数。</param>
            <returns>一个可观察的序列，其观察者永远不会被调用。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Range(System.Int32,System.Int32)">
            <summary>生成指定范围内的可观察的整数序列。</summary>
            <param name="start">序列中第一个整数的值。</param>
            <param name="count">要生成的连续整数的数量。</param>
            <returns>包含一系列连续整数的可观察序列。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。-或- <paramref name="start"/> + <paramref name="count"/> - 1 大于 <see cref="M:System.Int32.MaxValue"/></exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Range(System.Int32,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序发出观察者消息，在指定范围内生成可观察的整数数列。</summary>
            <param name="start">序列中第一个整数的值。</param>
            <param name="count">要生成的连续整数的数量。</param>
            <param name="scheduler">运行生成器循环的调度程序。</param>
            <returns>包含一系列连续整数的可观察序列。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。-或- <paramref name="start"/> + <paramref name="count"/> - 1 大于 <see cref="M:System.Int32.MaxValue"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(``0)">
            <summary>生成一个可观察的序列，无限重复给定的元素。</summary>
            <typeparam name="TResult">将在生成的序列中重复的元素的类型。</typeparam>
            <param name="value">重复的元素。</param>
            <returns>一个可观察的序列，无限重复给定的元素。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(``0,System.Reactive.Concurrency.IScheduler)">
            <summary>生成一个无限重复给定元素的可观察序列，使用指定的调度程序发送观察者消息。</summary>
            <typeparam name="TResult">将在生成的序列中重复的元素的类型。</typeparam>
            <param name="value">重复的元素。</param>
            <param name="scheduler">运行创建者循环的调度程序。</param>
            <returns>一个可观察的序列，无限重复给定的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(``0,System.Int32)">
            <summary>生成一个可观察的序列，它重复给定元素指定次数。</summary>
            <typeparam name="TResult">将在生成的序列中重复的元素的类型。</typeparam>
            <param name="value">重复的元素。</param>
            <param name="repeatCount">元素的重复次数。</param>
            <returns>一个重复给定元素指定次数的可观察序列。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(``0,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>生成一个重复给定元素指定次数的可观察序列，使用指定的调度程序发送观察者消息。</summary>
            <typeparam name="TResult">将在生成的序列中重复的元素的类型。</typeparam>
            <param name="value">重复的元素。</param>
            <param name="repeatCount">元素的重复次数。</param>
            <param name="scheduler">运行创建者循环的调度程序。</param>
            <returns>一个重复给定元素指定次数的可观察序列。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount"/> 小于零。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Return``1(``0)">
            <summary>返回包含单个元素的可观察序列。</summary>
            <typeparam name="TResult">将在生成的序列中返回的元素的类型。</typeparam>
            <param name="value">结果可观察序列中的单个元素。</param>
            <returns>包含单个指定元素的可观察序列。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Return``1(``0,System.Reactive.Concurrency.IScheduler)">
            <summary>返回包含单个元素的可观察序列，使用指定的调度程序发送观察者消息。</summary>
            <typeparam name="TResult">将在生成的序列中返回的元素的类型。</typeparam>
            <param name="value">结果可观察序列中的单个元素。</param>
            <param name="scheduler">发送单个元素的调度程序。</param>
            <returns>包含单个指定元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)">
            <summary>返回以异常终止的可观察序列。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <param name="exception">用于序列终止的异常对象。</param>
            <returns>与指定异常对象异常终止的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="exception"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throw``1(System.Exception,``0)">
            <summary>返回以异常终止的可观察序列。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <param name="exception">用于序列终止的异常对象。</param>
            <param name="witness">仅用于推断<typeparamref name="TResult"/>类参数的对象。通常在创建匿名元素序列时使用此参数。</param>
            <returns>与指定异常对象异常终止的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="exception"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throw``1(System.Exception,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个异常终止的可观察序列，使用指定的调度程序发送一条 OnError 消息。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <param name="exception">用于序列终止的异常对象。</param>
            <param name="scheduler">调度程序发送异常终止调用。</param>
            <returns>与指定异常对象异常终止的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="exception"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throw``1(System.Exception,System.Reactive.Concurrency.IScheduler,``0)">
            <summary>返回一个异常终止的可观察序列，使用指定的调度程序发送一条 OnError 消息。</summary>
            <typeparam name="TResult">用于结果序列 IObservable&lt;T&gt; 类参数的类别。</typeparam>
            <param name="exception">用于序列终止的异常对象。</param>
            <param name="scheduler">调度程序发送异常终止调用。</param>
            <param name="witness">仅用于推断<typeparamref name="TResult"/>类参数的对象。通常在创建匿名元素序列时使用此参数。</param>
            <returns>与指定异常对象异常终止的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="exception"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Using``2(System.Func{``1},System.Func{``1,System.IObservable{``0}})">
            <summary>构建一个取决于资源对象的可观察序列，该资源对象的生命周期与生成的可观察序列的生命周期相关。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <typeparam name="TResource">生成序列期间使用的资源类型。需要实施 <see cref="T:System.IDisposable"/>。</typeparam>
            <param name="resourceFactory">工厂函数获取资源对象。</param>
            <param name="observableFactory">工厂函数获取取决于获得的资源的可观察序列。</param>
            <returns>一个可观察的序列，其生命周期控制从属资源对象的生命周期。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="resourceFactory"/> 或<paramref name="observableFactory"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Using``2(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IObservable{``0}}})">
            <summary>构建一个取决于资源对象的可观察序列，该资源对象的生命周期与生成的可观察序列的生命周期相关。通过异步方法获取和使用资源。传递给异步方法的 CancellationToken 与返回的可处置订阅绑定，在资源获取或使用的任何阶段均允许尽力取消。</summary>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <typeparam name="TResource">生成序列期间使用的资源类型。需要实施 <see cref="T:System.IDisposable"/>。</typeparam>
            <param name="resourceFactoryAsync">异步工厂函数获取资源对象。</param>
            <param name="observableFactoryAsync">异步工厂函数获取取决于获取的资源的可观察序列。</param>
            <returns>一个可观察的序列，其生命周期控制从属资源对象的生命周期。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="resourceFactoryAsync"/> 或<paramref name="observableFactoryAsync"/>为空。</exception>
            <remarks>此运算符与 C＃5.0 和 Visual Basic 11 中引入的异步编程功能结合时特别适用。</remarks>
            <remarks>当处理对结果序列的订阅时，将发信号通知馈送到异步资源工厂函数和可观察函数的 CancellationToken。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.And``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>创建一个在两个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TLeft">左序列中元素的类型。</typeparam>
            <typeparam name="TRight">右序列中元素的类型。</typeparam>
            <param name="left">可观察序列与右序列匹配。</param>
            <param name="right">可观察序列与左序列匹配。</param>
            <returns>创建一个在两个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> 或<paramref name="right"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Then``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投影元素时匹配。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source">应用选择器的可观察序列。</param>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.When``1(System.Reactive.Joins.Plan{``0}[])">
            <summary>将几种模式的结果合并。</summary>
            <typeparam name="TResult">结果序列中元素的类型，从指定的模式中获取。</typeparam>
            <param name="plans">通过在模式上使用 Then 运算符创建的一系列计划。</param>
            <returns>一个可观察的序列，其结果来自匹配的多个模式。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="plans"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.When``1(System.Collections.Generic.IEnumerable{System.Reactive.Joins.Plan{``0}})">
            <summary>将几种模式的结果合并。</summary>
            <typeparam name="TResult">结果序列中元素的类型，从指定的模式中获取。</typeparam>
            <param name="plans">通过在模式上使用 Then 运算符创建的一系列计划。</param>
            <returns>一个可观察的序列，其结果构成匹配的多个模式。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="plans"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>传播首先作出反应的可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">第一个可观察序列。</param>
            <param name="second">第二个可观察序列。</param>
            <returns>一个可观察序列，显示给定序列中首先作出反应的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0}[])">
            <summary>传播首先作出反应的可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">可观察源争先反应。</param>
            <returns>一个可观察序列，显示给定序列中首先作出反应的任意序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Amb``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>传播首先作出反应的可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">可观察源争先反应。</param>
            <returns>一个可观察序列，显示给定序列中首先作出反应的任意序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``2(System.IObservable{``0},System.Func{System.IObservable{``1}})">
            <summary>将可观察序列的每个元素投影至连续的非重叠缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <typeparam name="TBufferClosing">序列中指示缓冲区关闭事件的元素类型。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="bufferClosingSelector">调用函数用于定义生成的缓冲区边界。当前一个缓冲区关闭时，将启动一个新的缓冲区。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="bufferClosingSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``3(System.IObservable{``0},System.IObservable{``1},System.Func{``1,System.IObservable{``2}})">
            <summary>将可观察序列的每个元素投影至零个或多个缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <typeparam name="TBufferOpening">序列中指示缓冲区打开事件的元素类型，也传递给结束选择器以获取缓冲区关闭事件序列。</typeparam>
            <typeparam name="TBufferClosing">序列中指示缓冲区关闭事件的元素类型。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="bufferOpenings">可观察序列中表示创建新缓冲区的元素。</param>
            <param name="bufferClosingSelector">调用函数用于定义生成每个缓冲区的关闭。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="bufferOpenings"/>或<paramref name="bufferClosingSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>将可观察序列的每个元素投影至连续的非重叠缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <typeparam name="TBufferBoundary">序列中指示缓冲区边界事件的元素类型。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="bufferBoundaries">缓冲区边界标记的序列。关闭当前缓冲区并在接收边界标记时打开新缓冲区。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="bufferBoundaries"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Catch``2(System.IObservable{``0},System.Func{``1,System.IObservable{``0}})">
            <summary>使用由处理程序生成的可观察序列继续指定异常终止的可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型和异常处理函数返回的序列。</typeparam>
            <typeparam name="TException">捕获和处理的异常类型。需要导出<see cref="T:System.Exception"/>。</typeparam>
            <param name="source">源序列。</param>
            <param name="handler">异常处理函数，生成另一个可观察序列。</param>
            <returns>包含源序列元素的可观察序列，后跟由处理程序生成的可观察序列产生的元素，以防发生异常。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="handler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Catch``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>使用下一个可观察序列继续异常终止的可观察序列。</summary>
            <typeparam name="TSource">源序列和处理程序序列中元素的类型。</typeparam>
            <param name="first">异常（如果有）被捕获的第一个可观察序列。</param>
            <param name="second">第二个可观察序列用于在第一个序列中发生错误时生成结果。</param>
            <returns>包含第一序列元素的可观察序列，后跟第二序列的元素，以防发生异常。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Catch``1(System.IObservable{``0}[])">
            <summary>使用下一个可观察序列继续异常终止的可观察序列。</summary>
            <typeparam name="TSource">源和处理程序序列中元素的类型。</typeparam>
            <param name="sources">捕获异常的可观察序列。</param>
            <returns>可观察序列包含连续源序列产生的元素，直到源序列成功终止。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Catch``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>使用下一个可观察序列继续异常终止的可观察序列。</summary>
            <typeparam name="TSource">源和处理程序序列中元素的类型。</typeparam>
            <param name="sources">捕获异常的可观察序列。</param>
            <returns>可观察序列包含连续源序列产生的元素，直到源序列成功终止。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``3(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,``2})">
            <summary>每当一个可观察序列产生成一个元素时，使用选择器函数将两个可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="first">第一个可观察的源。</param>
            <param name="second">第二个可观察的源。</param>
            <param name="resultSelector">任何一个源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合两个源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``4(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.Func{``0,``1,``2,``3})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``5(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``6(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``7(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``8(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``9(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="resultSelector"/>为正。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``10(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``11(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``12(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``13(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``14(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="source13">第十三个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="source13"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``15(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="source13">第十三个可观察的源。</param>
            <param name="source14">第十四个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="source13"/>或<paramref name="source14"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``16(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.IObservable{``14},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource15">第十五个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="source13">第十三个可观察的源。</param>
            <param name="source14">第十四个可观察的源。</param>
            <param name="source15">第十五个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="source13"/>或<paramref name="source14"/>或<paramref name="source15"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``17(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.IObservable{``14},System.IObservable{``15},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource15">第十五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource16">第十六个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="source13">第十三个可观察的源。</param>
            <param name="source14">第十四个可观察的源。</param>
            <param name="source15">第十五个可观察的源。</param>
            <param name="source16">第十六个可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="source13"/>或<paramref name="source14"/>或<paramref name="source15"/>或<paramref name="source16"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{System.Collections.Generic.IList{``0},``1})">
            <summary>每当任意可观察序列产生成一个元素时，使用选择器函数将指定可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="sources">可观察的源。</param>
            <param name="resultSelector">任意源生成元素时调用的函数。为了提高效率，在选择器返回结果后重用输入列表。在函数调用期间聚集或复制数值。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>每当任意可观察序列生成一个元素时，通过发出包含最新源元素的列表，将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="sources">可观察的源。</param>
            <returns>一个可观察的序列，包含源的最新元素列表。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``1(System.IObservable{``0}[])">
            <summary>每当任意可观察序列生成一个元素时，通过发出包含最新源元素的列表，将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="sources">可观察的源。</param>
            <returns>一个可观察的序列，包含源的最新元素列表。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>在成功终止第一个可观察序列后，将第二个可观察序列连接到第一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">第一个可观察序列。</param>
            <param name="second">第二个可观察序列。</param>
            <returns>一个可观察序列，其内包含第一个序列的元素，其后跟第二个序列的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{``0}[])">
            <summary>只要先前的可观察序列成功终止，就连接所有指定的可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">要连接的可观察序列。</param>
            <returns>一个可观察的序列，按顺序包含每个给定序列的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>只要先前的可观察序列成功终止，就连接给定可枚举序列中的所有可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">要连接的可观察序列。</param>
            <returns>一个可观察的序列，按顺序包含每个给定序列的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{System.IObservable{``0}})">
            <summary>只要先前的可观察序列成功终止，就连接所有内部可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">内部可观察序列的可观察序列。</param>
            <returns>一个可观察的序列，按顺序包含每个观察到的内部序列的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{System.Threading.Tasks.Task{``0}})">
            <summary>只要上一个任务成功终止，就连接所有任务结果。</summary>
            <typeparam name="TSource">任务产生的结果类型。</typeparam>
            <param name="sources">可观察的任务序列。</param>
            <returns>一个可观察序列，按顺序包含每个任务的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
            <remarks>如果任务支持取消，请考虑使用<see cref="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})"/>手动转换任务，然后使用<see cref="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{System.IObservable{``0}})"/>进行连接操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})">
            <summary>将所有内部可观察序列的元素合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">内部可观察序列的可观察序列。</param>
            <returns>合并内部序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.Threading.Tasks.Task{``0}})">
            <summary>将所有源任务的结果合并为一个可观察序列。</summary>
            <typeparam name="TSource">源任务生成的结果类型。</typeparam>
            <param name="sources">可观察的任务序列。</param>
            <returns>合并源任务结果的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
            <remarks>如果任务支持取消，请考虑使用<see cref="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})"/>手动转换任务，然后使用<see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})"/>进行合并操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)">
            <summary>将所有内部可观察序列的元素合并为一个可观察序列，从而限制对内部序列的并发订阅数。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">内部可观察序列的可观察序列。</param>
            <param name="maxConcurrent">内部可观察序列的最大并发订阅数。</param>
            <returns>合并内部序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxConcurrent"/> 小于或等于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Int32)">
            <summary>将给定可枚举序列中所有可观察序列的元素合并为一个可观察序列，从而限制对内部序列的并发订阅数。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">可观察序列的可枚举序列。</param>
            <param name="maxConcurrent">可观察序列的最大并发订阅数。</param>
            <returns>合并可观察序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxConcurrent"/> 小于或等于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>将给定可枚举序列中所有可观察序列的元素合并为一个可观察序列，限制对内部序列的并发订阅数，并使用指定的调度程序对源进行枚举和订阅。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">可观察序列的可枚举序列。</param>
            <param name="maxConcurrent">可观察序列的最大并发订阅数。</param>
            <param name="scheduler">运行源序列枚举的调度程序。</param>
            <returns>合并可观察序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxConcurrent"/> 小于或等于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>将两个可观察序列的元素合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">第一个可观察序列。</param>
            <param name="second">第二个可观察序列。</param>
            <returns>合并给定序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{``0},System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>将两个可观察序列的元素合并为一个可观察序列，使用指定的调度程序对源进行枚举和订阅。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">第一个可观察序列。</param>
            <param name="second">第二个可观察序列。</param>
            <param name="scheduler">调度程序用于引入并发以对给定序列进行订阅。</param>
            <returns>合并给定序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{``0}[])">
            <summary>将所有指定可观察序列的元素合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">可观察序列。</param>
            <returns>合并可观察序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Reactive.Concurrency.IScheduler,System.IObservable{``0}[])">
            <summary>将所有指定可观察序列的元素合并为一个可观察序列，使用指定的调度程序对源进行枚举和订阅。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">可观察序列。</param>
            <param name="scheduler">运行源序列枚举的调度程序。</param>
            <returns>合并可观察序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="sources"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>将给定可枚举序列中所有可观察序列的元素合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">可观察序列的可枚举序列。</param>
            <returns>合并可观察序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>将给定可枚举序列中所有可观察序列的元素合并为一个可观察序列，使用指定的调度程序对源进行枚举和订阅。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">可观察序列的可枚举序列。</param>
            <param name="scheduler">运行源序列枚举的调度程序。</param>
            <returns>合并可观察序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.OnErrorResumeNext``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>在成功或异常终止第一个可观察序列时，将第二个可观察序列连接到第一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="first">异常（如果有）被捕获的第一个可观察序列。</param>
            <param name="second">用于在第一个序列终止后生成结果的第二个可观察序列。</param>
            <returns>即使第一个序列异常终止，也可以连接第一个和第二个序列的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.OnErrorResumeNext``1(System.IObservable{``0}[])">
            <summary>即使先前的可观察序列异常终止，仍连接所有指定的可观察序列，</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">要连接的可观察序列。</param>
            <returns>即使序列异常终止，也可以连接源序列的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.OnErrorResumeNext``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>即使先前的可观察序列异常终止，仍连接给定可枚举序列中的所有可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">要连接的可观察序列。</param>
            <returns>即使序列异常终止，也可以连接源序列的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipUntil``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>仅在另一个可观察序列生成元素之后，才返回源可观察序列中的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TOther">另一个指示跳过行为已结束的序列中的元素类型。</typeparam>
            <param name="source">传播元素的源序列。</param>
            <param name="other">触发源序列元素进行传播的可观察序列。</param>
            <returns>包含源序列元素的可观察序列，其中源序列元素始于另一序列触发传播。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="other"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Switch``1(System.IObservable{System.IObservable{``0}})">
            <summary>转换可观察序列使其从最近的可观察序列生成数值。每次收到新的内部可观察序列时，取消订阅先前的内部可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="sources">内部可观察序列的可观察序列。</param>
            <returns>该可观察序列在任何时间点生成的元素为已接收的最近内部可观察序列的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Switch``1(System.IObservable{System.Threading.Tasks.Task{``0}})">
            <summary>转换任务的可观察序列使其从最近的可观察序列生成数值。每次收到新任务时，都会忽略上一个任务的结果。</summary>
            <typeparam name="TSource">源任务生成的结果类型。</typeparam>
            <param name="sources">可观察的任务序列。</param>
            <returns>该可观察序列在任何时间点生成的结果为已接收的最近任务的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
            <remarks>如果任务支持取消，请考虑使用<see cref="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})"/>手动转换任务，然后使用<see cref="M:System.Reactive.Linq.Observable.Switch``1(System.IObservable{System.IObservable{``0}})"/>进行转换操作。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeUntil``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>另一个可观察序列生成元素之后，返回源可观察序列中的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TOther">另一个指示抓取行为已结束的序列中的元素类型。</typeparam>
            <param name="source">传播元素的源序列。</param>
            <param name="other">终止源序列元素进行传播的可观察序列。</param>
            <returns>可观察序列包含源序列元素，直到另一个序列中断进一步传播。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="other"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``2(System.IObservable{``0},System.Func{System.IObservable{``1}})">
            <summary>将可观察序列的每个元素投影至连续的非重叠窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <typeparam name="TWindowClosing">序列中指示窗口关闭事件的元素类型。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="windowClosingSelector">调用函数用于定义生成的窗口边界。当前一个窗口关闭时，将启动一个新的窗口。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="windowClosingSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``3(System.IObservable{``0},System.IObservable{``1},System.Func{``1,System.IObservable{``2}})">
            <summary>将可观察序列的每个元素投影至零个或多个窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <typeparam name="TWindowOpening">序列中指示窗口打开事件的元素类型，也传递给结束选择器以获取窗口关闭事件序列。</typeparam>
            <typeparam name="TWindowClosing">序列中指示窗口关闭事件的元素类型。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="windowOpenings">可观察序列中表示创建新窗口的元素。</param>
            <param name="windowClosingSelector">调用函数用于定义生成每个窗口的关闭。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="windowOpenings"/>或<paramref name="windowClosingSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>将可观察序列的每个元素投影至连续的非重叠窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <typeparam name="TWindowBoundary">序列中指示窗口边界事件的元素类型。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="windowBoundaries">窗口边界标记的序列。关闭当前窗口并在接收边界标记时打开新窗口。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="windowBoundaries"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``3(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,``2})">
            <summary>对元素进行成对组合从而将两个可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="first">第一个可观察的源。</param>
            <param name="second">第二个可观察的源。</param>
            <param name="resultSelector">从第一个和第二个源调用每个连续元素对的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数成对组合第一和第二个源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``4(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.Func{``0,``1,``2,``3})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``5(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``6(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``7(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``8(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``9(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="resultSelector"/>为正。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``10(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``11(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``12(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``13(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``14(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="source13">第十三个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="source13"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``15(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="source13">第十三个可观察的源。</param>
            <param name="source14">第十四个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="source13"/>或<paramref name="source14"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``16(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.IObservable{``14},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource15">第十五个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="source13">第十三个可观察的源。</param>
            <param name="source14">第十四个可观察的源。</param>
            <param name="source15">第十五个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="source13"/>或<paramref name="source14"/>或<paramref name="source15"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``17(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.IObservable{``14},System.IObservable{``15},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource15">第十五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource16">第十六个源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="source1">第一个可观察的源。</param>
            <param name="source2">第二个可观察的源。</param>
            <param name="source3">第三个可观察的源。</param>
            <param name="source4">第四个可观察的源。</param>
            <param name="source5">第五个可观察的源。</param>
            <param name="source6">第六个可观察的源。</param>
            <param name="source7">第七个可观察的源。</param>
            <param name="source8">第八个可观察的源。</param>
            <param name="source9">第九个可观察的源。</param>
            <param name="source10">第十个可观察的源。</param>
            <param name="source11">第十一个可观察的源。</param>
            <param name="source12">第十二个可观察的源。</param>
            <param name="source13">第十三个可观察的源。</param>
            <param name="source14">第十四个可观察的源。</param>
            <param name="source15">第十五个可观察的源。</param>
            <param name="source16">第十六个可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> 或<paramref name="source2"/>或<paramref name="source3"/>或<paramref name="source4"/>或<paramref name="source5"/>或<paramref name="source6"/>或<paramref name="source7"/>或<paramref name="source8"/>或<paramref name="source9"/>或<paramref name="source10"/>或<paramref name="source11"/>或<paramref name="source12"/>或<paramref name="source13"/>或<paramref name="source14"/>或<paramref name="source15"/>或<paramref name="source16"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{System.Collections.Generic.IList{``0},``1})">
            <summary>每当所有可观察序列在相应索引处生成元素时，使用选择器函数将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="sources">可观察的源。</param>
            <param name="resultSelector">在源中相应索引处调用每个元素系列的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数组合源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>通过在相应的索引处发出包含可观察序列的元素的列表，将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="sources">可观察的源。</param>
            <returns>包含相应索引处元素列表的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``1(System.IObservable{``0}[])">
            <summary>通过在相应的索引处发出包含可观察序列的元素的列表，将指定的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="sources">可观察的源。</param>
            <returns>包含相应索引处元素列表的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``3(System.IObservable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>使用选择器函数将可观察序列和可枚举序列合并为一个可观察序列。</summary>
            <typeparam name="TSource1">第一个可观察源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个可枚举源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="first">第一个可观察的源。</param>
            <param name="second">第二个可枚举源。</param>
            <param name="resultSelector">从第一个和第二个源调用每个连续元素对的函数。</param>
            <returns>一个可观察序列，包含使用指定结果选择器函数成对组合第一和第二个源元素的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> 或<paramref name="second"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.AsObservable``1(System.IObservable{``0})">
            <summary>隐藏可观察序列的标识。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">一个需隐藏标识的可观察序列。</param>
            <returns>一个隐藏源序列标识的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.Int32)">
            <summary>将可观察序列的每个元素投影至基于元素计数信息产生的连续非重叠缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="count">每个缓冲区的长度。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于或等于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.Int32,System.Int32)">
            <summary>将可观察序列的每个元素投影至零个或多个基于元素计数信息生成的缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="count">每个缓冲区的长度。</param>
            <param name="skip">在创建连续缓冲区期间跳过的元素数。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 或<paramref name="skip"/>小于等于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">
            <summary>取消可观察序列的显式通知值使其成为隐式通知值。</summary>
            <typeparam name="TSource">源序列通知对象中呈现的元素类型。</typeparam>
            <param name="source">可观察序列中所含的显式通知值必须转换为隐式通知值。</param>
            <returns>可观察序列中的行为与源序列的通知值相对应。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DistinctUntilChanged``1(System.IObservable{``0})">
            <summary>返回仅包含不同连续元素的可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">一个用于保留不同连续元素的可观察序列。</param>
            <returns>一个仅包含源序列中不同连续元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DistinctUntilChanged``1(System.IObservable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>返回的可观察序列仅包含比较器上的不同连续元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">一个用于保留不同连续元素的可观察序列。</param>
            <param name="comparer">源元素的等式比较器。</param>
            <returns>一个仅包含源序列中不同连续元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="comparer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DistinctUntilChanged``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>返回的可观察序列仅包含 keySelector 上的不同连续元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的鉴别器密钥类型。</typeparam>
            <param name="source">基于计算的键值保留不同连续元素的可观察序列。</param>
            <param name="keySelector">用于计算每个元素的比较键的函数。</param>
            <returns>一个可观察序列，仅包含源序列中基于计算键值的不同连续元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DistinctUntilChanged``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>返回的可观察序列根据 keySelector 和比较器仅包含不同的连续元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的鉴别器密钥类型。</typeparam>
            <param name="source">基于计算的键值保留不同连续元素的可观察序列。</param>
            <param name="keySelector">用于计算每个元素的比较键的函数。</param>
            <param name="comparer">计算键值的等式比较器。</param>
            <returns>一个可观察序列，仅包含源序列中基于计算键值的不同连续元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="comparer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0})">
            <summary>为可观察序列中的每个元素调用一个动作，并通过结果序列传播所有观察者消息。通过拦截消息流以对管道上的消息执行任意操作，此方法可用于查询行为的调试、日志记录等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <returns>应用了副作用行为的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0},System.Action)">
            <summary>为可观察序列中的每个元素调用一个动作，并在可观察序列正常终止时调用一个动作。通过拦截消息流以对管道上的消息执行任意操作，此方法可用于查询行为的调试、日志记录等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onCompleted">在可观察序列正常终止时调用的动作。</param>
            <returns>应用了副作用行为的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0},System.Action{System.Exception})">
            <summary>为可观察序列中的每个元素调用一个动作，并在可观察序列异常终止时调用一个动作。通过拦截消息流以对管道上的消息执行任意操作，此方法可用于查询行为的调试、日志记录等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onError">在可观察序列异常终止时调用的动作。</param>
            <returns>应用了副作用行为的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onError"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0},System.Action{System.Exception},System.Action)">
            <summary>为可观察序列中的每个元素调用一个动作，并在可观察序列正常或异常终止时调用一个动作。通过拦截消息流以对管道上的消息执行任意操作，此方法可用于查询行为的调试、日志记录等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onError">在可观察序列异常终止时调用的动作。</param>
            <param name="onCompleted">在可观察序列正常终止时调用的动作。</param>
            <returns>应用了副作用行为的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onError"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.IObserver{``0})">
            <summary>为源序列中的每条消息调用观察者方法。通过拦截消息流以对管道上的消息执行任意操作，此方法可用于查询行为的调试、日志记录等。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="observer">观察者方法作为源序列观察的一部分进行调用。</param>
            <returns>应用了副作用行为的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="observer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Finally``1(System.IObservable{``0},System.Action)">
            <summary>在源可观察序列正常或异常终止后调用指定的操作。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="finallyAction">源可观察序列终止后调用的动作。</param>
            <returns>应用了动作调用终止行为的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="finallyAction"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.IgnoreElements``1(System.IObservable{``0})">
            <summary>忽略可观察序列中的所有元素，只保留终止消息。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <returns>一个可观察的空序列用于指示源序列的终止、成功或异常。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">
            <summary>将可观察序列的隐式通知值呈现为显式通知值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取通知值的可观察序列。</param>
            <returns>包含源序列中的具体通知值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(System.IObservable{``0})">
            <summary>无限期重复可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">需重复的可观察序列。</param>
            <returns>重复且依序生成给定序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(System.IObservable{``0},System.Int32)">
            <summary>重复可观察序列指定的次数。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">需重复的可观察序列。</param>
            <param name="repeatCount">序列重复次数。</param>
            <returns>重复生成给定序列元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Retry``1(System.IObservable{``0})">
            <summary>重复源可观察序列，直到它成功终止。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">重复可观察序列，直到它成功终止</param>
            <returns>一个可观察序列在成功终止前重复生成给定序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Retry``1(System.IObservable{``0},System.Int32)">
            <summary>重复源可观察序列指定的次数或直到它成功终止。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">重复可观察序列，直到它成功终止</param>
            <param name="retryCount">序列重复次数。</param>
            <returns>一个可观察序列在成功终止前重复生成给定序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retryCount"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Scan``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})">
            <summary>在可观察序列上应用累加器函数并返回每个中间结果。指定的种子值用作初始累加值。对于没有中间结果的合并行为，请参阅 <see cref="M:System.Reactive.Linq.Observable.Aggregate``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})"/>。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TAccumulate">累加结果的类型。</typeparam>
            <param name="source">一个需合并的可观察序列。</param>
            <param name="seed">初始累加值。</param>
            <param name="accumulator">要在每个元素上调用的累加函数。</param>
            <returns>包含累积值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="accumulator"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Scan``1(System.IObservable{``0},System.Func{``0,``0,``0})">
            <summary>在可观察序列上应用累加器函数并返回每个中间结果。对于没有中间结果的合并行为，请参阅 <see cref="M:System.Reactive.Linq.Observable.Aggregate``1(System.IObservable{``0},System.Func{``0,``0,``0})"/>。</summary>
            <typeparam name="TSource">源序列中元素的类型和累加结果。</typeparam>
            <param name="source">一个需合并的可观察序列。</param>
            <param name="accumulator">要在每个元素上调用的累加函数。</param>
            <returns>包含累积值的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="accumulator"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipLast``1(System.IObservable{``0},System.Int32)">
            <summary>跳过可观察序列末尾指定数量的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="count">源序列末尾被跳过的元素数。</param>
            <returns>可观察序列中包含的源序列元素，不含序列末尾被跳过的序列元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。</exception>
            <remarks>该运算符累积的队列长度足以存储第一个<paramref name="count"/>元素。随着接收到更多元素，元素取自队列前段并在结果序列上生成。这会导致元素延迟。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},``0[])">
            <summary>将一组值的序列追加到可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">追加数值的源序列。</param>
            <param name="values">要追加到指定序列的值。</param>
            <returns>追加有指定值的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="values"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>将一组值的序列追加到可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">追加数值的源序列。</param>
            <param name="values">要追加到指定序列的值。</param>
            <returns>追加有指定值的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="values"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler,``0[])">
            <summary>将一组值的序列追加到可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">追加数值的源序列。</param>
            <param name="scheduler">发出追加值的调度程序。</param>
            <param name="values">要追加到指定序列的值。</param>
            <returns>追加有指定值的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>或<paramref name="values"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler,System.Collections.Generic.IEnumerable{``0})">
            <summary>将一组值的序列追加到可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">追加数值的源序列。</param>
            <param name="scheduler">发出追加值的调度程序。</param>
            <param name="values">要追加到指定序列的值。</param>
            <returns>追加有指定值的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>或<paramref name="values"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.Int32)">
            <summary>从可观察序列末尾返回指定数量的连续元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="count">从源序列末尾获取的元素数。</param>
            <returns>一个可观察的序列，包含源序列末尾指定数量的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。</exception>
            <remarks>该运算符累积的缓冲区长度足以存储<paramref name="count"/>元素。完成源序列后，该缓冲区将在结果序列上清空。这会导致元素延迟。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>从可观察序列末尾返回指定数量的连续元素，使用指定调度长度清空队列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="count">从源序列末尾获取的元素数。</param>
            <param name="scheduler">调度程序用于在完成源序列时清空队列。</param>
            <returns>一个可观察的序列，包含源序列末尾指定数量的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。</exception>
            <remarks>该运算符累积的缓冲区长度足以存储<paramref name="count"/>元素。完成源序列后，该缓冲区将在结果序列上清空。这会导致元素延迟。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLastBuffer``1(System.IObservable{``0},System.Int32)">
            <summary>返回的列表包含可观察序列末尾的指定数量的连续元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="count">从源序列末尾获取的元素数。</param>
            <returns>一个可观察序列中包含的列表具有源序列末尾指定数量的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。</exception>
            <remarks>该运算符累积的缓冲区长度足以存储<paramref name="count"/>元素。完成源序列后，该缓冲区将在结果序列上生成。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.Int32)">
            <summary>将可观察序列的每个元素投影至基于元素计数信息产生的连续非重叠窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="count">每个窗口的长度。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于或等于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.Int32,System.Int32)">
            <summary>将可观察序列的每个元素投影至零个或多个基于元素计数信息生成的窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="count">每个窗口的长度。</param>
            <param name="skip">在创建连续窗口期间跳过的元素数。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 或<paramref name="skip"/>小于等于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Cast``1(System.IObservable{System.Object})">
            <summary>将可观察序列的元素转换为指定类型。</summary>
            <typeparam name="TResult">源序列中元素要转换的类型。</typeparam>
            <param name="source">包含待转换元素的可观察序列。</param>
            <returns>一个可观察的序列，包含转换为指定类型的源序列的每个元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DefaultIfEmpty``1(System.IObservable{``0})">
            <summary>如果序列为空，则返回指定序列的元素或单元素序列中的参数默认值。</summary>
            <typeparam name="TSource">源序列中元素的类型（如果有），如果序列为空，将采用其默认值。</typeparam>
            <param name="source">如果序列为空，则返回默认值。</param>
            <returns>如果源为空，则可观察序列包含 Tsource 类默认值；否则，包含源本身的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DefaultIfEmpty``1(System.IObservable{``0},``0)">
            <summary>如果序列为空，则返回指定序列的元素或单元素序列中的指定值。</summary>
            <typeparam name="TSource">源序列中元素的类型（如果有），如果序列为空，将采用指定默认值。</typeparam>
            <param name="source">如果序列为空，则返回指定值。</param>
            <param name="defaultValue">序列为空时返回的值。</param>
            <returns>如果源为空，则可观察序列包含指定默认值；否则，包含源本身的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Distinct``1(System.IObservable{``0})">
            <summary>返回仅包含不同元素的可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">一个用于保留不同元素的可观察序列。</param>
            <returns>一个仅包含源序列中不同元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>由于所维护的内部查找结构尺寸可能变大，因此应仔细考虑此运算符的使用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Distinct``1(System.IObservable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>返回的可观察序列仅包含比较器上的不同元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">一个用于保留不同元素的可观察序列。</param>
            <param name="comparer">源元素的等式比较器。</param>
            <returns>一个仅包含源序列中不同元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="comparer"/>为空。</exception>
            <remarks>由于所维护的内部查找结构尺寸可能变大，因此应仔细考虑此运算符的使用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Distinct``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>返回的可观察序列仅包含 keySelector 上的不同元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的鉴别器密钥类型。</typeparam>
            <param name="source">一个用于保留不同元素的可观察序列。</param>
            <param name="keySelector">用于计算每个元素的比较键的函数。</param>
            <returns>一个可观察序列，仅包含源序列中基于计算键值的不同元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>为空。</exception>
            <remarks>由于所维护的内部查找结构尺寸可能变大，因此应仔细考虑此运算符的使用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Distinct``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>返回的可观察序列根据 keySelector 和比较器仅包含不同的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的鉴别器密钥类型。</typeparam>
            <param name="source">一个用于保留不同元素的可观察序列。</param>
            <param name="keySelector">用于计算每个元素的比较键的函数。</param>
            <param name="comparer">源元素的等式比较器。</param>
            <returns>一个可观察序列，仅包含源序列中基于计算键值的不同元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="comparer"/>为空。</exception>
            <remarks>由于所维护的内部查找结构尺寸可能变大，因此应仔细考虑此运算符的使用。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>根据指定的键选择器函数分组可观察序列的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器分组可观察序列的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="comparer">用于比较密钥的等式比较器。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="comparer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>对可观察序列的元素进行分组，并使用指定的函数选择结果元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TElement">源序列中的每个元素计算得出的分组元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">将每个源元素映射到可观察组中的元素的函数。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器对可观察序列的元素进行分组，并使用指定的函数选择结果元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TElement">源序列中的每个元素计算得出的分组元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">将每个源元素映射到可观察组中的元素的函数。</param>
            <param name="comparer">用于比较密钥的等式比较器。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>或<paramref name="comparer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1},System.Int32)">
            <summary>根据指定的键选择器函数将具有指定初始容量的可观察序列的元素分组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="capacity">基础字典可包含的初始元素数。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于 0。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器将具有指定初始容量的可观察序列的元素分组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="capacity">基础字典可包含的初始元素数。</param>
            <param name="comparer">用于比较密钥的等式比较器。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="comparer"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于 0。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Int32)">
            <summary>对可具有指定初始容量的可观察序列的元素进行分组，并使用指定的函数选择结果元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TElement">源序列中的每个元素计算得出的分组元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">将每个源元素映射到可观察组中的元素的函数。</param>
            <param name="capacity">基础字典可包含的初始元素数。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于 0。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器对具有指定初始容量的可观察序列的元素进行分组，并使用指定的函数选择结果元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TElement">源序列中的每个元素计算得出的分组元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">将每个源元素映射到可观察组中的元素的函数。</param>
            <param name="capacity">基础字典可包含的初始元素数。</param>
            <param name="comparer">用于比较密钥的等式比较器。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>或<paramref name="comparer"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于 0。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``4(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``2},System.IObservable{``3}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器对可观察序列的元素进行分组，并使用指定的函数选择结果元素。持续时间选择器功能用于控制组的生命周期。当组到期时，它会收到 OnCompleted 通知。当出现与回收组具有相同键值的新元素时，将使用新的生命周期请求重新生成该组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TElement">源序列中的每个元素计算得出的分组元素类型。</typeparam>
            <typeparam name="TDuration">持续时间序列中为每个组中获取的表示其生命周期的元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">将每个源元素映射到可观察组中的元素的函数。</param>
            <param name="durationSelector">表示组到期的函数。</param>
            <param name="comparer">用于比较密钥的等式比较器。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。如果组的生命周期到期，就可以创建具有相同键值的新组，只要遇到具有此键值的元素即可。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>或<paramref name="durationSelector"/>或<paramref name="comparer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``4(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``2},System.IObservable{``3}})">
            <summary>根据指定的键选择器函数对可观察序列的元素进行分组，并使用指定的函数选择结果元素。持续时间选择器功能用于控制组的生命周期。当组到期时，它会收到 OnCompleted 通知。当出现与回收组具有相同键值的新元素时，将使用新的生命周期请求重新生成该组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TElement">源序列中的每个元素计算得出的分组元素类型。</typeparam>
            <typeparam name="TDuration">持续时间序列中为每个组中获取的表示其生命周期的元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">将每个源元素映射到可观察组中的元素的函数。</param>
            <param name="durationSelector">表示组到期的函数。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。如果组的生命周期到期，就可以创建具有相同键值的新组，只要遇到具有此键值的元素即可。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>或<paramref name="durationSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``3(System.IObservable{``0},System.Func{``0,``1},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``0},System.IObservable{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器分组可观察序列的元素。持续时间选择器功能用于控制组的生命周期。当组到期时，它会收到 OnCompleted 通知。当出现与回收组具有相同键值的新元素时，将使用新的生命周期请求重新生成该组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TDuration">持续时间序列中为每个组中获取的表示其生命周期的元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="durationSelector">表示组到期的函数。</param>
            <param name="comparer">用于比较密钥的等式比较器。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。如果组的生命周期到期，就可以创建具有相同键值的新组，只要遇到具有此键值的元素即可。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="durationSelector"/>或<paramref name="comparer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``3(System.IObservable{``0},System.Func{``0,``1},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``0},System.IObservable{``2}})">
            <summary>根据指定的键选择器函数分组可观察序列的元素。持续时间选择器功能用于控制组的生命周期。当组到期时，它会收到 OnCompleted 通知。当出现与回收组具有相同键值的新元素时，将使用新的生命周期请求重新生成该组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TDuration">持续时间序列中为每个组中获取的表示其生命周期的元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="durationSelector">表示组到期的函数。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。如果组的生命周期到期，就可以创建具有相同键值的新组，只要遇到具有此键值的元素即可。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="durationSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``4(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``2},System.IObservable{``3}},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器对具有指定初始容量的可观察序列的元素进行分组，并使用指定的函数选择结果元素。持续时间选择器功能用于控制组的生命周期。当组到期时，它会收到 OnCompleted 通知。当出现与回收组具有相同键值的新元素时，将使用新的生命周期请求重新生成该组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TElement">源序列中的每个元素计算得出的分组元素类型。</typeparam>
            <typeparam name="TDuration">持续时间序列中为每个组中获取的表示其生命周期的元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">将每个源元素映射到可观察组中的元素的函数。</param>
            <param name="durationSelector">表示组到期的函数。</param>
            <param name="capacity">基础字典可包含的初始元素数。</param>
            <param name="comparer">用于比较密钥的等式比较器。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。如果组的生命周期到期，就可以创建具有相同键值的新组，只要遇到具有此键值的元素即可。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>或<paramref name="durationSelector"/>或<paramref name="comparer"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于 0。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``4(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``2},System.IObservable{``3}},System.Int32)">
            <summary>根据指定的键选择器函数对具有指定初始容量的可观察序列的元素进行分组，并使用指定的函数选择结果元素。持续时间选择器功能用于控制组的生命周期。当组到期时，它会收到 OnCompleted 通知。当出现与回收组具有相同键值的新元素时，将使用新的生命周期请求重新生成该组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TElement">源序列中的每个元素计算得出的分组元素类型。</typeparam>
            <typeparam name="TDuration">持续时间序列中为每个组中获取的表示其生命周期的元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="elementSelector">将每个源元素映射到可观察组中的元素的函数。</param>
            <param name="durationSelector">表示组到期的函数。</param>
            <param name="capacity">基础字典可包含的初始元素数。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。如果组的生命周期到期，就可以创建具有相同键值的新组，只要遇到具有此键值的元素即可。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="elementSelector"/>或<paramref name="durationSelector"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于 0。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``3(System.IObservable{``0},System.Func{``0,``1},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``0},System.IObservable{``2}},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>根据指定的键选择器函数和比较器将具有指定初始容量的可观察序列的元素分组。持续时间选择器功能用于控制组的生命周期。当组到期时，它会收到 OnCompleted 通知。当出现与回收组具有相同键值的新元素时，将使用新的生命周期请求重新生成该组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TDuration">持续时间序列中为每个组中获取的表示其生命周期的元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="durationSelector">表示组到期的函数。</param>
            <param name="capacity">基础字典可包含的初始元素数。</param>
            <param name="comparer">用于比较密钥的等式比较器。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。如果组的生命周期到期，就可以创建具有相同键值的新组，只要遇到具有此键值的元素即可。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="durationSelector"/>或<paramref name="comparer"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于 0。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``3(System.IObservable{``0},System.Func{``0,``1},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``0},System.IObservable{``2}},System.Int32)">
            <summary>根据指定的键选择器函数将具有指定初始容量的可观察序列的元素分组。持续时间选择器功能用于控制组的生命周期。当组到期时，它会收到 OnCompleted 通知。当出现与回收组具有相同键值的新元素时，将使用新的生命周期请求重新生成该组。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TKey">源序列中的每个元素计算得出的分组键类型。</typeparam>
            <typeparam name="TDuration">持续时间序列中为每个组中获取的表示其生命周期的元素类型。</typeparam>
            <param name="source">一个元素需分组的可观察序列。</param>
            <param name="keySelector">用于提取每个元素的密钥的函数。</param>
            <param name="durationSelector">表示组到期的函数。</param>
            <param name="capacity">基础字典可包含的初始元素数。</param>
            <returns>一系列可观察组，每个组对应一个唯一键值，其内包含共享相同键值的所有元素。如果组的生命周期到期，就可以创建具有相同键值的新组，只要遇到具有此键值的元素即可。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="keySelector"/>或<paramref name="durationSelector"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于 0。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupJoin``5(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``2}},System.Func{``1,System.IObservable{``3}},System.Func{``0,System.IObservable{``1},``4})">
            <summary>根据重叠持续时间关联两个序列的元素，并对结果进行分组。</summary>
            <typeparam name="TLeft">左源序列中元素的类型。</typeparam>
            <typeparam name="TRight">右源序列中元素的类型。</typeparam>
            <typeparam name="TLeftDuration">持续时间序列中表示左源序列中每个元素的计算持续时间的元素。</typeparam>
            <typeparam name="TRightDuration">持续时间序列中表示右源序列中每个元素的计算持续时间的元素。</typeparam>
            <typeparam name="TResult">结果序列中通过为具有重叠持续时间的源元素调用结果选择器函数获取的元素。</typeparam>
            <param name="left">用于连接元素的左可观察序列。</param>
            <param name="right">用于连接元素的右可观察序列。</param>
            <param name="leftDurationSelector">选择左可观察序列中每个元素的持续时间的函数，用于确定重叠。</param>
            <param name="rightDurationSelector">选择右可观察序列中每个元素的持续时间的函数，用于确定重叠。</param>
            <param name="resultSelector">调用一个函数来计算左序列的任意元素的结果元素，其中右侧可观察序列具有重叠元素。</param>
            <returns>包含具有重叠持续时间的源元素计算的结果元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> 或<paramref name="right"/>或<paramref name="leftDurationSelector"/>或<paramref name="rightDurationSelector"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Join``5(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``2}},System.Func{``1,System.IObservable{``3}},System.Func{``0,``1,``4})">
            <summary>基于重叠持续时间关联两个序列的元素。</summary>
            <typeparam name="TLeft">左源序列中元素的类型。</typeparam>
            <typeparam name="TRight">右源序列中元素的类型。</typeparam>
            <typeparam name="TLeftDuration">持续时间序列中表示左源序列中每个元素的计算持续时间的元素。</typeparam>
            <typeparam name="TRightDuration">持续时间序列中表示右源序列中每个元素的计算持续时间的元素。</typeparam>
            <typeparam name="TResult">结果序列中通过为具有重叠持续时间的源元素调用结果选择器函数获取的元素。</typeparam>
            <param name="left">用于连接元素的左可观察序列。</param>
            <param name="right">用于连接元素的右可观察序列。</param>
            <param name="leftDurationSelector">选择左可观察序列中每个元素的持续时间的函数，用于确定重叠。</param>
            <param name="rightDurationSelector">选择右可观察序列中每个元素的持续时间的函数，用于确定重叠。</param>
            <param name="resultSelector">调用函数计算左右可观察序列的任意两个重叠元素的结果元素。</param>
            <returns>包含具有重叠持续时间的源元素计算的结果元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> 或<paramref name="right"/>或<paramref name="leftDurationSelector"/>或<paramref name="rightDurationSelector"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.OfType``1(System.IObservable{System.Object})">
            <summary>根据指定类型筛选可观察序列的元素。</summary>
            <typeparam name="TResult">源序列中元素要转换的类型。</typeparam>
            <param name="source">包含待筛选元素的可观察序列。</param>
            <returns>一个可观察的序列，其中包含来自 Tresult 类输入序列的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Select``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>将可观察序列的每个元素投影到新表单中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中通过为源序列中的每个元素运行选择器函数获取的元素。</typeparam>
            <param name="source">调用转换函数的元素序列。</param>
            <param name="selector">应用于每个源元素的转换函数。</param>
            <returns>可观察序列中所含元素取自在源的每个元素上调用转换函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Select``2(System.IObservable{``0},System.Func{``0,System.Int32,``1})">
            <summary>通过合并元素的索引，将可观察序列的每个元素投影到新表单中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中通过为源序列中的每个元素运行选择器函数获取的元素。</typeparam>
            <param name="source">调用转换函数的元素序列。</param>
            <param name="selector">应用于每个源元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <returns>可观察序列中所含元素取自在源的每个元素上调用转换函数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>将源可观察序列的每个元素投影到另一个可观察序列，并将得到的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TOther">另一个序列中元素的类型和结果序列中的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="other">源序列中每个元素即将投射的可观察序列。</param>
            <returns>一个可观察的序列，其元素是将每个源元素投影到另一个序列上并将所有结果序列合并在一起的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="other"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>将可观察序列的每个元素投影到可观察序列，并将得到的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">预计内部序列中元素的类型和合并结果序列中的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>一个可观察序列，其元素是在输入序列的每个元素上调用一对多变换函数的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.IObservable{``1}})">
            <summary>通过合并元素的索引将可观察序列的每个元素投影到可观察序列，并将得到的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">预计内部序列中元素的类型和合并结果序列中的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="selector">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <returns>一个可观察序列，其元素是在输入序列的每个元素上调用一对多变换函数的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>将可观察序列的每个元素投射到任务，并将所有任务结果合并到一个可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">由预计任务和合并结果序列中的元素生成的结果类型。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>一个可观察序列内的元素是为输入序列中每个元素执行的任务的结果。</returns>
            <remarks>此重载支持可观察序列和任务的组合，无需使用<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/>手动将任务转换为可观察序列。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.Threading.Tasks.Task{``1}})">
            <summary>通过合并元素的索引将可观察序列的每个元素投射到任务，并将所有任务结果合并到一个可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">由预计任务和合并结果序列中的元素生成的结果类型。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="selector">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <returns>一个可观察序列内的元素是为输入序列中每个元素执行的任务的结果。</returns>
            <remarks>此重载支持可观察序列和任务的组合，无需使用<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/>手动将任务转换为可观察序列。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>将可观察序列的每个元素投射到具有取消支持的任务，并将所有任务结果合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">由预计任务和合并结果序列中的元素生成的结果类型。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>一个可观察序列内的元素是为输入序列中每个元素执行的任务的结果。</returns>
            <remarks>此重载支持可观察序列和任务的组合，无需使用<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/>手动将任务转换为可观察序列。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>结合元素的索引与取消支持，将可观察序列的每个元素投射到任务，并将所有任务结果合并到一个可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">由预计任务和合并结果序列中的元素生成的结果类型。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="selector">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <returns>一个可观察序列内的元素是为输入序列中每个元素执行的任务的结果。</returns>
            <remarks>此重载支持可观察序列和任务的组合，无需使用<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/>手动将任务转换为可观察序列。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.IObservable{``1}},System.Func{``0,``1,``2})">
            <summary>将可观察序列的每个元素投射到可观察序列，调用源元素的结果选择器和每个相应的内部序列元素，并将结果合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TCollection">投射的中间序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中通过使用选择器将源序列元素与其对应的中间序列元素组合而获取的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="collectionSelector">应用于每个元素的转换函数。</param>
            <param name="resultSelector">应用于中间序列的每个元素的转换函数。</param>
            <returns>可观察序列中通过在输入序列的每个元素上调用一对多转换函数 collectionSelector，然后将每个序列元素及其对应的源元素映射到结果元素的获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="collectionSelector"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Int32,System.IObservable{``1}},System.Func{``0,System.Int32,``1,System.Int32,``2})">
            <summary>通过合并元素的索引将可观察序列的每个元素投射到可观察序列，调用源元素的结果选择器和每个相应的内部序列元素，并将结果合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TCollection">投射的中间序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中通过使用选择器将源序列元素与其对应的中间序列元素组合而获取的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="collectionSelector">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <param name="resultSelector">应用于中间序列的每个元素的变换函数；函数的第二个参数表示源元素的索引，第四个参数表示中间元素的索引。</param>
            <returns>可观察序列中通过在输入序列的每个元素上调用一对多转换函数 collectionSelector，然后将每个序列元素及其对应的源元素映射到结果元素的获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="collectionSelector"/>或<paramref name="resultSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Func{``0,``1,``2})">
            <summary>将可观察序列的每个元素投射到任务，调用源元素和任务结果的结果选择器，并将结果合并到一个可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TTaskResult">投射的中间任务产生的结果类型。</typeparam>
            <typeparam name="TResult">结果序列中通过使用选择器将源序列元素与其对应的中间任务结果组合而获取的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="taskSelector">应用于每个元素的转换函数。</param>
            <param name="resultSelector">应用于中间序列的每个元素的转换函数。</param>
            <returns>可观察序列中通过在输入序列的每个元素获取任务，然后将任务的结果及其对应的源元素映射到结果元素的获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="taskSelector"/>或<paramref name="resultSelector"/>为空。</exception>
            <remarks>此重载支持在 C＃ 和 Visual Basic 中使用 LINQ 查询理解语法来编制可观察序列和任务，而无需使用<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/>手动将任务转换为可观察序列。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Int32,System.Threading.Tasks.Task{``1}},System.Func{``0,System.Int32,``1,``2})">
            <summary>通过合并元素的索引将可观察序列的每个元素投射到任务，调用源元素和任务结果的结果选择器，并将结果合并到一个可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TTaskResult">投射的中间任务产生的结果类型。</typeparam>
            <typeparam name="TResult">结果序列中通过使用选择器将源序列元素与其对应的中间任务结果组合而获取的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="taskSelector">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <param name="resultSelector">应用于中间序列的每个元素的变换函数；函数的第二个参数表示源元素的索引。</param>
            <returns>可观察序列中通过在输入序列的每个元素获取任务，然后将任务的结果及其对应的源元素映射到结果元素的获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="taskSelector"/>或<paramref name="resultSelector"/>为空。</exception>
            <remarks>此重载支持在 C＃ 和 Visual Basic 中使用 LINQ 查询理解语法来编制可观察序列和任务，而无需使用<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/>手动将任务转换为可观察序列。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Func{``0,``1,``2})">
            <summary>将可观察序列的每个元素投射至具有取消支持的任务，调用源元素和任务结果的结果选择器，并将结果合并到一个可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TTaskResult">投射的中间任务产生的结果类型。</typeparam>
            <typeparam name="TResult">结果序列中通过使用选择器将源序列元素与其对应的中间任务结果组合而获取的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="taskSelector">应用于每个元素的转换函数。</param>
            <param name="resultSelector">应用于中间序列的每个元素的转换函数。</param>
            <returns>可观察序列中通过在输入序列的每个元素获取任务，然后将任务的结果及其对应的源元素映射到结果元素的获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="taskSelector"/>或<paramref name="resultSelector"/>为空。</exception>
            <remarks>此重载支持在 C＃ 和 Visual Basic 中使用 LINQ 查询理解语法来编制可观察序列和任务，而无需使用<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/>手动将任务转换为可观察序列。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Int32,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Func{``0,System.Int32,``1,``2})">
            <summary>通过将元素的索引与取消支持相结合，将可观察序列的每个元素投射到任务，调用源元素和任务结果的结果选择器，并将结果合并到一个可观察序列中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TTaskResult">投射的中间任务产生的结果类型。</typeparam>
            <typeparam name="TResult">结果序列中通过使用选择器将源序列元素与其对应的中间任务结果组合而获取的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="taskSelector">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <param name="resultSelector">应用于中间序列的每个元素的变换函数；函数的第二个参数表示源元素的索引。</param>
            <returns>可观察序列中通过在输入序列的每个元素获取任务，然后将任务的结果及其对应的源元素映射到结果元素的获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="taskSelector"/>或<paramref name="resultSelector"/>为空。</exception>
            <remarks>此重载支持在 C＃ 和 Visual Basic 中使用 LINQ 查询理解语法来编制可观察序列和任务，而无需使用<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/>手动将任务转换为可观察序列。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}},System.Func{System.Exception,System.IObservable{``1}},System.Func{System.IObservable{``1}})">
            <summary>将可观察序列的每个通知投射到可观察序列，并将得到的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">预计内部序列中元素的类型和合并结果序列中的元素。</typeparam>
            <param name="source">待投射通知的可观察序列。</param>
            <param name="onNext">应用于每个元素的转换函数。</param>
            <param name="onError">源序列中发生错误时应用的转换函数。</param>
            <param name="onCompleted">到达源序列的末尾时应用的转换函数。</param>
            <returns>可观察序列中通过调用与输入序列中每个通知相对应的一对多变换函数获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onError"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.IObservable{``1}},System.Func{System.Exception,System.IObservable{``1}},System.Func{System.IObservable{``1}})">
            <summary>通过合并元素的索引，将可观察序列的每个通知投射到可观察序列，并将得到的可观察序列合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">预计内部序列中元素的类型和合并结果序列中的元素。</typeparam>
            <param name="source">待投射通知的可观察序列。</param>
            <param name="onNext">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <param name="onError">源序列中发生错误时应用的转换函数。</param>
            <param name="onCompleted">到达源序列的末尾时应用的转换函数。</param>
            <returns>可观察序列中通过调用与输入序列中每个通知相对应的一对多变换函数获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onError"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>将可观察序列的每个元素投射到可枚举序列，并将得到的可枚举序列连接成一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">投影的内部可枚举序列中的元素类型和合并结果序列中的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="selector">应用于每个元素的转换函数。</param>
            <returns>一个可观察序列，其元素是在输入序列的每个元素上调用一对多变换函数的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>在源序列的 OnNext 调用内同步枚举投射序列。为了执行并发的非阻塞合并，更改选择器以返回使用<see cref="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})"/>转换获得的可观察序列。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>通过合并元素的索引将可观察序列的每个元素投射到可枚举序列并将得到的可枚举序列连接成一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">投影的内部可枚举序列中的元素类型和合并结果序列中的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="selector">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <returns>一个可观察序列，其元素是在输入序列的每个元素上调用一对多变换函数的结果。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="selector"/>为空。</exception>
            <remarks>在源序列的 OnNext 调用内同步枚举投射序列。为了执行并发的非阻塞合并，更改选择器以返回使用<see cref="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})"/>转换获得的可观察序列。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>将可观察序列的每个元素投射到可枚举序列，调用源元素的结果选择器和每个相应的内部序列元素，并将结果合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TCollection">投射的中间可枚举序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中通过使用选择器将源序列元素与其对应的中间序列元素组合而获取的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="collectionSelector">应用于每个元素的转换函数。</param>
            <param name="resultSelector">应用于中间序列的每个元素的转换函数。</param>
            <returns>可观察序列中通过在输入序列的每个元素上调用一对多转换函数 collectionSelector，然后将每个序列元素及其对应的源元素映射到结果元素的获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="collectionSelector"/>或<paramref name="resultSelector"/>为空。</exception>
            <remarks>在源序列的 OnNext 调用内同步枚举投射序列。为了执行并发的非阻塞合并，更改选择器以返回使用<see cref="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})"/>转换获得的可观察序列。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,System.Int32,``1,System.Int32,``2})">
            <summary>通过合并元素的索引将可观察序列的每个元素投射到可枚举序列，调用源元素的结果选择器和每个相应的内部序列元素，并将结果合并为一个可观察序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TCollection">投射的中间可枚举序列中元素的类型。</typeparam>
            <typeparam name="TResult">结果序列中通过使用选择器将源序列元素与其对应的中间序列元素组合而获取的元素。</typeparam>
            <param name="source">待投射的可观察元素序列。</param>
            <param name="collectionSelector">应用于每个元素的转换函数；函数的第二个参数表示源元素的索引。</param>
            <param name="resultSelector">应用于中间序列的每个元素的变换函数；函数的第二个参数表示源元素的索引，第四个参数表示中间元素的索引。</param>
            <returns>可观察序列中通过在输入序列的每个元素上调用一对多转换函数 collectionSelector，然后将每个序列元素及其对应的源元素映射到结果元素的获取的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="collectionSelector"/>或<paramref name="resultSelector"/>为空。</exception>
            <remarks>在源序列的 OnNext 调用内同步枚举投射序列。为了执行并发的非阻塞合并，更改选择器以返回使用<see cref="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})"/>转换获得的可观察序列。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Skip``1(System.IObservable{``0},System.Int32)">
            <summary>跳过可观察序列中指定数量的元素，然后返回其余元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的顺序。</param>
            <param name="count">返回剩余元素之前要跳过的元素数。</param>
            <returns>一个可观察序列包含的元素出现在输入序列中指定索引之后。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipWhile``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>只要指定的条件为真，就会在可观察序列中跳过元素，然后返回其余元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">返回元素的可观察序列。</param>
            <param name="predicate">用于测试条件的每个元素的函数。</param>
            <returns>一个可观察序列，包含始于线性序列中第一个元素的输入序列中的元素，而该线性序列未通过谓词指定的测试。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipWhile``1(System.IObservable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>只要指定的条件为真，就会在可观察序列中跳过元素，然后返回其余元素。元素的索引用在谓词函数的逻辑中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">返回元素的可观察序列。</param>
            <param name="predicate">测试条件中每个元素的函数；函数的第二个参数表示源元素的索引。</param>
            <returns>一个可观察序列，包含始于线性序列中第一个元素的输入序列中的元素，而该线性序列未通过谓词指定的测试。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)">
            <summary>从可观察序列开始返回指定数量的连续元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的顺序。</param>
            <param name="count">要返回的元素数。</param>
            <returns>一个可观察序列中包含始于输入序列的指定元素数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>使用 Take(0) 边缘案例的指定调度程序，从可观察序列的开头返回指定数量的连续元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的顺序。</param>
            <param name="count">要返回的元素数。</param>
            <param name="scheduler"><paramref name="count">计数</paramref>设置为 0 时，调度程序生成 OnCompleted 消息。</param>
            <returns>一个可观察序列中包含始于输入序列的指定元素数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeWhile``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>只要指定的条件为真，就从可观察序列返回元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">返回元素的序列。</param>
            <param name="predicate">用于测试条件的每个元素的函数。</param>
            <returns>一个可观察序列，包含输入序列中的元素，这些元素出现在测试不再通过的元素之前。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeWhile``1(System.IObservable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>只要指定的条件为真，就从可观察序列返回元素。元素的索引用在谓词函数的逻辑中。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">返回元素的序列。</param>
            <param name="predicate">测试条件中每个元素的函数；函数的第二个参数表示源元素的索引。</param>
            <returns>一个可观察序列，包含输入序列中的元素，这些元素出现在测试不再通过的元素之前。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>根据谓词筛选可观察序列的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">一个元素需要筛选的可观察序列。</param>
            <param name="predicate">用于测试条件的每个源元素的函数。</param>
            <returns>一个可观察序列，包含满足条件的输入序列中的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Where``1(System.IObservable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>通过合并元素的索引，根据谓词筛选可观察序列的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">一个元素需要筛选的可观察序列。</param>
            <param name="predicate">测试条件的每个源元素的函数；函数的第二个参数表示源元素的索引。</param>
            <returns>一个可观察序列，包含满足条件的输入序列中的元素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="predicate"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan)">
            <summary>将可观察序列的每个元素投影至基于定时信息产生的连续非重叠缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="timeSpan">每个缓冲区的长度。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 小于 TimeSpan.Zero。</exception>
            <remarks>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，导致调度程序尽可能快地创建缓冲区。因为所有源序列元素都在其中一个缓冲区中结束，所以部分缓冲区的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前缓冲区和创建新缓冲区的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，将可观察序列的每个元素投射至基于定时信息生成的连续非重叠缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="timeSpan">每个缓冲区的长度。</param>
            <param name="scheduler">运行缓冲计时器的调度程序。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 小于 TimeSpan.Zero。</exception>
            <remarks>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，导致调度程序尽可能快地创建缓冲区。因为所有源序列元素都在其中一个缓冲区中结束，所以部分缓冲区的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前缓冲区和创建新缓冲区的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan)">
            <summary>将可观察序列的每个元素投射至基于定时信息产生的零个或多个缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="timeSpan">每个缓冲区的长度。</param>
            <param name="timeShift">创建连续缓冲区的间隔。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 或 <paramref name="timeSpan"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，导致调度程序在最短用时内创建缓冲区。但是，部分缓冲区的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前缓冲区的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            <para>不建议但受支持为<paramref name="timeShift"/>指定一个 TimeSpan.Zero 值，导致调度程序尽可能快地创建缓冲区。但是，这并表示所有缓冲区都将从源序列的开头开始。这是调度程序引入的异步的副作用，其中创建新缓冲区的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，将可观察序列的每个元素投射至基于定时信息生成的零个或多个缓冲区。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="timeSpan">每个缓冲区的长度。</param>
            <param name="timeShift">创建连续缓冲区的间隔。</param>
            <param name="scheduler">运行缓冲计时器的调度程序。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 或 <paramref name="timeSpan"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，导致调度程序在最短用时内创建缓冲区。但是，部分缓冲区的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前缓冲区的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            <para>不建议但受支持为<paramref name="timeShift"/>指定一个 TimeSpan.Zero 值，导致调度程序尽可能快地创建缓冲区。但是，这并表示所有缓冲区都将从源序列的开头开始。这是调度程序引入的异步的副作用，其中创建新缓冲区的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.Int32)">
            <summary>将可观察序列的每个元素投射至一个缓冲区，该缓冲区在其内存已满或已经过去一定时间后发送。这种超载的现实类比是相当于渡船在所有座位均已落座或到达预定离港时驶离码头的行为，以先发生者为准。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="timeSpan">窗口的最大时间长度。</param>
            <param name="count">窗口的最大元素数。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 小于 TimeSpan.Zero。-或-<paramref name="count"/>小于等于零。</exception>
            <remarks>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，导致调度程序尽可能快地创建缓冲区。因为所有源序列元素都在其中一个缓冲区中结束，所以部分缓冲区的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前缓冲区和创建新缓冲区的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定调度程序运行定时器，将可观察序列的每个元素投射至一个缓冲区，该缓冲区在其内存已满或已经过去一定时间后发送。这种超载的现实类比是相当于渡船在所有座位均已落座或到达预定离港时驶离码头的行为，以先发生者为准。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的列表。</typeparam>
            <param name="source">生成缓冲区的源序列。</param>
            <param name="timeSpan">缓冲区的最大时间长度。</param>
            <param name="count">缓冲区的最大元素数。</param>
            <param name="scheduler">运行缓冲计时器的调度程序。</param>
            <returns>缓冲区的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 小于 TimeSpan.Zero。-或-<paramref name="count"/>小于等于零。</exception>
            <remarks>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，导致调度程序尽可能快地创建缓冲区。因为所有源序列元素都在其中一个缓冲区中结束，所以部分缓冲区的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前缓冲区和创建新缓冲区的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan)">
            <summary>可观察序列的时移将为指定的相对持续时间。保留值的相对时间间隔。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">数值需延迟的源序列。</param>
            <param name="dueTime">可观察序列的相对移动时间。如果此值等于 TimeSpan.Zero，则调度程序将尽快调度观察者回调。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>该运算符的效率低于 <see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)">DelaySubscription</see>，因为它记录了所有通知和延时。此时，错误会立即传播。</para>
            <para>结果序列的观察者回调将在默认调度程序上运行。该效果类似于使用 ObserveOn。</para>
            <para>源序列通过 OnError 回调发出的异常会立即转发到结果序列。OnError 回调时队列中的任何 OnNext 通知将被删除。为了延迟错误传播，请考虑使用 <see cref="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">Observable.Materialize</see> 和 <see cref="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">Observable.Dematerialize</see> 运算符，或使用 <see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)">DelaySubscription</see>。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，可观察序列的时移将为指定的相对持续时间。保留值的相对时间间隔。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">数值需延迟的源序列。</param>
            <param name="dueTime">可观察序列的相对移动时间。如果此值等于 TimeSpan.Zero，则调度程序将尽快调度观察者回调。</param>
            <param name="scheduler">运行延迟定时器的调度程序。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>该运算符的效率低于 <see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">DelaySubscription</see>，因为它记录了所有通知和延时。此时，错误会立即传播。</para>
            <para>结果序列的观察者回调将在指定调度程序上运行。该效果类似于使用 ObserveOn。</para>
            <para>源序列通过 OnError 回调发出的异常会立即转发到结果序列。OnError 回调时队列中的任何 OnNext 通知将被删除。</para>
            <para>源序列通过 OnError 回调发出的异常会立即转发到结果序列。OnError 回调时队列中的任何 OnNext 通知将被删除。为了延迟错误传播，请考虑使用 <see cref="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">Observable.Materialize</see> 和 <see cref="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">Observable.Dematerialize</see> 运算符，或使用 <see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">DelaySubscription</see>。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>可观察序列进行时移以在指定的绝对时间时开始传播通知。保留值的相对时间间隔。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">数值需延迟的源序列。</param>
            <param name="dueTime">移动可观察序列的绝对时间；订阅后计算的相对时移。如果此值小于等于DateTimeOffset.UtcNow，则调度程序将尽快调度观察者回调。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>
            <para>该运算符的效率低于 <see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset)">DelaySubscription</see>，因为它记录了所有通知和延时。此时，错误会立即传播。</para>
            <para>结果序列的观察者回调将在默认调度程序上运行。该效果类似于使用 ObserveOn。</para>
            <para>源序列通过 OnError 回调发出的异常会立即转发到结果序列。OnError 回调时队列中的任何 OnNext 通知将被删除。为了延迟错误传播，请考虑使用 <see cref="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">Observable.Materialize</see> 和 <see cref="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">Observable.Dematerialize</see> 运算符，或使用 <see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset)">DelaySubscription</see>。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，可观察序列进行时移以在指定的绝对时间时开始传播通知。保留值的相对时间间隔。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">数值需延迟的源序列。</param>
            <param name="dueTime">移动可观察序列的绝对时间；订阅后计算的相对时移。如果此值小于等于DateTimeOffset.UtcNow，则调度程序将尽快调度观察者回调。</param>
            <param name="scheduler">运行延迟定时器的调度程序。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>该运算符的效率低于 <see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">DelaySubscription</see>，因为它记录了所有通知和延时。此时，错误会立即传播。</para>
            <para>结果序列的观察者回调将在指定调度程序上运行。该效果类似于使用 ObserveOn。</para>
            <para>源序列通过 OnError 回调发出的异常会立即转发到结果序列。OnError 回调时队列中的任何 OnNext 通知将被删除。为了延迟错误传播，请考虑使用 <see cref="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">Observable.Materialize</see> 和 <see cref="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">Observable.Dematerialize</see> 运算符，或使用 <see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">DelaySubscription</see>。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>基于每个元素的延迟选择器函数对可观察序列进行时移。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TDelay">延迟序列中表示源序列中每个元素的延时的元素。</typeparam>
            <param name="source">数值需延迟的源序列。</param>
            <param name="delayDurationSelector">选择器函数检索指示每个给定元素的延迟的序列。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="delayDurationSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})">
            <summary>基于订阅延迟和每个元素的延迟选择器函数对可观察序列进行时移。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TDelay">延迟序列中表示源序列中每个元素的延时的元素。</typeparam>
            <param name="source">数值需延迟的源序列。</param>
            <param name="subscriptionDelay">指示订阅源的延迟的序列。</param>
            <param name="delayDurationSelector">选择器函数检索指示每个给定元素的延迟的序列。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="subscriptionDelay"/>或<paramref name="delayDurationSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)">
            <summary>可观察序列的时移相当于指定相对时间订阅的延迟。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">延迟订阅的源序列。</param>
            <param name="dueTime">订阅的相对时移。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>这个运算符的效率高于<see cref="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan)">延迟</see>，但是推迟了订阅的所有副作用并影响错误传播计时。</para>
            <para>订阅源序列的副作用将在默认调度程序上运行。观察者回调不会受到影响。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，可观察序列的时移相当于指定相对时间订阅的延迟。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">延迟订阅的源序列。</param>
            <param name="dueTime">订阅的相对时移。</param>
            <param name="scheduler">运行订阅延迟定时器的调度程序。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>这个运算符的效率高于<see cref="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">延迟</see>，但是推迟了订阅的所有副作用并影响错误传播计时。</para>
            <para>订阅源序列的副作用将在指定的调度程序上运行。观察者回调不会受到影响。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>可观察序列的时移相当于指定绝对时间订阅的延迟。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">延迟订阅的源序列。</param>
            <param name="dueTime">订阅的绝对时间。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>
            <para>这个运算符的效率高于<see cref="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.DateTimeOffset)">延迟</see>，但是推迟了订阅的所有副作用并影响错误传播计时。</para>
            <para>订阅源序列的副作用将在默认调度程序上运行。观察者回调不会受到影响。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，可观察序列的时移相当于指定绝对时间订阅的延迟。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">延迟订阅的源序列。</param>
            <param name="dueTime">订阅的绝对时间。</param>
            <param name="scheduler">运行订阅延迟定时器的调度程序。</param>
            <returns>时移序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <remarks>
            <para>这个运算符的效率高于<see cref="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">延迟</see>，但是推迟了订阅的所有副作用并影响错误传播计时。</para>
            <para>订阅源序列的副作用将在指定的调度程序上运行。观察者回调不会受到影响。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan})">
            <summary>通过运行生成序列元素的状态驱动和临时循环来生成可观察序列。</summary>
            <typeparam name="TState">生成器循环中使用的状态类型。</typeparam>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="initialState">初始状态。</param>
            <param name="condition">终止生成的条件（返回 false 时）。</param>
            <param name="iterate">迭代步骤函数。</param>
            <param name="resultSelector">序列中生成结果的选择器函数。</param>
            <param name="timeSelector">时间选择器功能用于控制每次迭代生成的值的速度。</param>
            <returns>生成的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或<paramref name="iterate"/>或<paramref name="resultSelector"/>或<paramref name="timeSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan},System.Reactive.Concurrency.IScheduler)">
            <summary>通过运行生成序列元素的状态驱动和临时循环生成可观察序列，使用指定的调度程序运行定时器和发送观察者消息。</summary>
            <typeparam name="TState">生成器循环中使用的状态类型。</typeparam>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="initialState">初始状态。</param>
            <param name="condition">终止生成的条件（返回 false 时）。</param>
            <param name="iterate">迭代步骤函数。</param>
            <param name="resultSelector">序列中生成结果的选择器函数。</param>
            <param name="timeSelector">时间选择器功能用于控制每次迭代生成的值的速度。</param>
            <param name="scheduler">用于运行生成器循环的调度程序。</param>
            <returns>生成的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或<paramref name="iterate"/>或<paramref name="resultSelector"/>或<paramref name="timeSelector"/>或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.DateTimeOffset})">
            <summary>通过运行生成序列元素的状态驱动和临时循环来生成可观察序列。</summary>
            <typeparam name="TState">生成器循环中使用的状态类型。</typeparam>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="initialState">初始状态。</param>
            <param name="condition">终止生成的条件（返回 false 时）。</param>
            <param name="iterate">迭代步骤函数。</param>
            <param name="resultSelector">序列中生成结果的选择器函数。</param>
            <param name="timeSelector">时间选择器功能用于控制每次迭代生成的值的速度。</param>
            <returns>生成的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或<paramref name="iterate"/>或<paramref name="resultSelector"/>或<paramref name="timeSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.DateTimeOffset},System.Reactive.Concurrency.IScheduler)">
            <summary>通过运行生成序列元素的状态驱动和临时循环生成可观察序列，使用指定的调度程序运行定时器和发送观察者消息。</summary>
            <typeparam name="TState">生成器循环中使用的状态类型。</typeparam>
            <typeparam name="TResult">生成序列中元素的类型。</typeparam>
            <param name="initialState">初始状态。</param>
            <param name="condition">终止生成的条件（返回 false 时）。</param>
            <param name="iterate">迭代步骤函数。</param>
            <param name="resultSelector">序列中生成结果的选择器函数。</param>
            <param name="timeSelector">时间选择器功能用于控制每次迭代生成的值的速度。</param>
            <param name="scheduler">用于运行生成器循环的调度程序。</param>
            <returns>生成的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> 或<paramref name="iterate"/>或<paramref name="resultSelector"/>或<paramref name="timeSelector"/>或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Interval(System.TimeSpan)">
            <summary>返回一个可观察的序列，该序列在每个句点后生成一个值。</summary>
            <param name="period">结果序列中值的生成时间。如果此值等于 TimeSpan.Zero，则定时器将尽快重现。</param>
            <returns>一个可观察的序列，该系列在每个周期后生成一个值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
            <remarks>间隔是在启动后续通知之间测量的，而不是在前一次通知结束和下一次通知开始之间。如果观察者处理消息的时间超过间隔时间，则后续通知将在处理完当前通知后立即发送。如果您需要控制连续通知结束和开始之间的间隔，请考虑改用<see cref="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan})"/>运算符。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Interval(System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察的序列，该序列在每个时间段之后生成一个值，使用指定的调度程序运行定时器并发送观察者消息。</summary>
            <param name="period">结果序列中值的生成时间。如果此值等于 TimeSpan.Zero，则定时器将尽快重现。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>一个可观察的序列，该系列在每个周期后生成一个值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
            <remarks>间隔是在启动后续通知之间测量的，而不是在前一次通知结束和下一次通知开始之间。如果观察者处理消息的时间超过间隔时间，则后续通知将在处理完当前通知后立即发送。如果您需要控制连续通知结束和开始之间的间隔，请考虑改用<see cref="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan},System.Reactive.Concurrency.IScheduler)"/>运算符。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sample``1(System.IObservable{``0},System.TimeSpan)">
            <summary>在每个间隔期对可观察序列进行采样。每次采样时，在最后一个采样间隔内源序列中的最新元素（如果有）被发送到结果序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">待采样的源序列。</param>
            <param name="interval">采样间隔。如果此值等于 TimeSpan.Zero，则调度程序将连续采样数据流。</param>
            <returns>采样可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="interval"/> 小于 TimeSpan.Zero。</exception>
            <remarks>为<paramref name="interval"/>指定一个 TimeSpan.Zero 值无法确保所有源序列元素均会被保留。这是调度程序引入的异步的副作用，其中采样操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sample``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>在每个间隔期内采样可观察序列，使用指定调度程序运行采样定时器。每次采样时，在最后一个采样间隔内源序列中的最新元素（如果有）被发送到结果序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">待采样的源序列。</param>
            <param name="interval">采样间隔。如果此值等于 TimeSpan.Zero，则调度程序将连续采样数据流。</param>
            <param name="scheduler">运行采样定时器的调度程序。</param>
            <returns>采样可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="interval"/> 小于 TimeSpan.Zero。</exception>
            <remarks>为<paramref name="interval"/>指定一个 TimeSpan.Zero 值无法确保所有源序列元素均会被保留。这是调度程序引入的异步的副作用，其中采样操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sample``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>使用样本可观察序列对源可观察序列进行采样，生成采样选项。每次采样时，在最后一个采样间隔内源序列中的最新元素（如果有）被发送到结果序列。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TSample">采样序列中元素的类型。</typeparam>
            <param name="source">待采样的源序列。</param>
            <param name="sampler">采样选项序列。</param>
            <returns>采样可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="sampler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Skip``1(System.IObservable{``0},System.TimeSpan)">
            <summary>从可观察源序列的开头跳过指定持续时间的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">要跳过元素的源序列。</param>
            <param name="duration">从序列开头跳过元素的持续时间。</param>
            <returns>在源序列开始的指定持续时间内跳过元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>为<paramref name="duration"/>指定一个 TimeSpan.Zero 值无法保证不会从源序列的开头删除任何元素。这是调度程序引入的异步的副作用，其中导致源序列的回调被转发的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            <para>源序列产生的错误总是转发到结果序列，即使错误发生在<paramref name="duration"/>之前。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Skip``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，从可观察源序列的开头跳过指定持续时间的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">要跳过元素的源序列。</param>
            <param name="duration">从序列开头跳过元素的持续时间。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>在源序列开始的指定持续时间内跳过元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>为<paramref name="duration"/>指定一个 TimeSpan.Zero 值无法保证不会从源序列的开头删除任何元素。这是调度程序引入的异步的副作用，其中导致源序列的回调被转发的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            <para>源序列产生的错误总是转发到结果序列，即使错误发生在<paramref name="duration"/>之前。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipLast``1(System.IObservable{``0},System.TimeSpan)">
            <summary>从可观察源序列的结尾跳过指定持续时间的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">要跳过元素的源序列。</param>
            <param name="duration">从序列结尾跳过元素的持续时间。</param>
            <returns>在源序列结尾的指定持续时间内跳过元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>该运算符累积的队列长度足以存储初始<paramref name="duration"/>窗口接收的元素。随着接收到更多元素，比指定<paramref name="duration"/>要早的元素取自队列并在结果序列上生成。这会导致含<paramref name="duration"/>的元素出现延迟。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipLast``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，从可观察源序列的结尾跳过指定持续时间的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">要跳过元素的源序列。</param>
            <param name="duration">从序列结尾跳过元素的持续时间。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>在源序列结尾的指定持续时间内跳过元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>该运算符累积的队列长度足以存储初始<paramref name="duration"/>窗口接收的元素。随着接收到更多元素，比指定<paramref name="duration"/>要早的元素取自队列并在结果序列上生成。这会导致含<paramref name="duration"/>的元素出现延迟。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipUntil``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>从可观察源序列中跳过元素直到指定的开始时间。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">要跳过元素的源序列。</param>
            <param name="startTime">是时候开始从源序列中获取元素了。如果此值小于或等于 DateTimeOffset.UtcNow，则不会跳过任何元素。</param>
            <returns>一个可观察序列，其元素会跳过指定的开始时间。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <remarks>源序列产生的错误总是转发到结果序列，即使错误发生在<paramref name="startTime"/>之前。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipUntil``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，跳过可观察源序列的元素直至指定的开始时间。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">要跳过元素的源序列。</param>
            <param name="startTime">是时候开始从源序列中获取元素了。如果此值小于或等于 DateTimeOffset.UtcNow，则不会跳过任何元素。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>一个可观察序列，其元素会跳过指定的开始时间。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <remarks>源序列产生的错误总是转发到结果序列，即使错误发生在<paramref name="startTime"/>之前。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.TimeSpan)">
            <summary>从可观察源序列的开头截取指定持续时间的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="duration">从序列开始截取元素的持续时间。</param>
            <returns>在源序列开始的指定持续时间内截取元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>为<paramref name="duration"/>指定一个 TimeSpan.Zero 值无法确保返回所有空序列。这是调度程序引入的异步的副作用，其中停止源序列的回调的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，从可观察源序列的开头截取指定持续时间的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="duration">从序列开始截取元素的持续时间。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>在源序列开始的指定持续时间内截取元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>为<paramref name="duration"/>指定一个 TimeSpan.Zero 值无法确保返回所有空序列。这是调度程序引入的异步的副作用，其中停止源序列的回调的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.TimeSpan)">
            <summary>从可观察源序列的末尾返回指定持续时间内的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="duration">从序列末尾截取元素的持续时间。</param>
            <returns>在源序列结尾的指定持续时间内截取元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>该运算符累积的缓冲区其长度足以存储源序列生命周期内任意<paramref name="duration"/>窗口的元素。完成源序列后，该缓冲区将在结果序列上清空。这会导致含<paramref name="duration"/>的结果元素出现延迟。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，从可观察源序列的末尾返回指定持续时间内的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="duration">从序列末尾截取元素的持续时间。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>在源序列结尾的指定持续时间内截取元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>该运算符累积的缓冲区其长度足以存储源序列生命周期内任意<paramref name="duration"/>窗口的元素。完成源序列后，该缓冲区将在结果序列上清空。这会导致含<paramref name="duration"/>的结果元素出现延迟。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器并清空已收集的元素，从可观察源序列的末尾返回指定持续时间内的元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="duration">从序列末尾截取元素的持续时间。</param>
            <param name="timerScheduler">运行定时器的调度程序。</param>
            <param name="loopScheduler">清空已收集元素的调度程序。</param>
            <returns>在源序列结尾的指定持续时间内截取元素的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="timerScheduler"/>或<paramref name="loopScheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>该运算符累积的缓冲区其长度足以存储源序列生命周期内任意<paramref name="duration"/>窗口的元素。完成源序列后，该缓冲区将在结果序列上清空。这会导致含<paramref name="duration"/>的结果元素出现延迟。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLastBuffer``1(System.IObservable{``0},System.TimeSpan)">
            <summary>从可观察源序列的末尾返回指定持续时间内的元素列表。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="duration">从序列末尾截取元素的持续时间。</param>
            <returns>在源序列结尾的指定持续时间内截取包含元素列表的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>该运算符累积的缓冲区其长度足以存储源序列生命周期内任意<paramref name="duration"/>窗口的元素。完成源序列后，该缓冲区将在结果序列上生成。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLastBuffer``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，从可观察源序列的末尾返回指定持续时间内的元素列表。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="duration">从序列末尾截取元素的持续时间。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>在源序列结尾的指定持续时间内截取包含元素列表的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> 小于 TimeSpan.Zero。</exception>
            <remarks>该运算符累积的缓冲区其长度足以存储源序列生命周期内任意<paramref name="duration"/>窗口的元素。完成源序列后，该缓冲区将在结果序列上生成。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeUntil``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>在指定持续时间内截取元素，直到指定的结束时间。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="endTime">是时候停止从源序列中截取元素了。如果此值小于等于 DateTimeOffset.UtcNow，则结果流将立即完成。</param>
            <returns>一个可观察序列，其内的元素在指定的结束时间前截取。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeUntil``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，在指定持续时间内截取元素，直到指定的结束时间。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">获取元素的源序列。</param>
            <param name="endTime">是时候停止从源序列中截取元素了。如果此值小于等于 DateTimeOffset.UtcNow，则结果流将立即完成。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>一个可观察序列，其内的元素在指定的结束时间前截取。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throttle``1(System.IObservable{``0},System.TimeSpan)">
            <summary>忽略可观察序列中的元素，这些元素后跟指定相对持续时间内的另一个元素。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">需要限制的源序列。</param>
            <param name="dueTime">每个元素的限制持续时间。</param>
            <returns>受限制的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>此运算符通过在<paramref name="dueTime"/>内指定的持续时间内保持每个元素来限制源序列。如果在此时间窗口内生成另一个元素，则会删除该元素并为当前元素启动一个新计时器，然后重复整个过程。如果数据流的间隔从未大于等于元素间<paramref name="dueTime"/>，生成的流不会产生任何元素。为了减小流的容量同时保证元素的生成周期，请考虑使用 Observable.Sample 运算符集。</para>
            <para>不建议但受支持为<paramref name="dueTime"/>指定一个 TimeSpan.Zero值，这导致计划的限流计时器立即到期。但是，这无法保证所有元素都将保留在结果序列中。这是调度程序引入的异步的副作用，其中转发当前元素的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。此时，下一个元素可能在调度程序有机会运行限制操作之前出现。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throttle``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>忽略可观察序列中的元素，这些元素后跟指定相对持续时间内的另一个元素，使用指定调度程序运行限流计时器。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">需要限制的源序列。</param>
            <param name="dueTime">每个元素的限制持续时间。</param>
            <param name="scheduler">运行限流计时器的调度程序。</param>
            <returns>受限制的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>此运算符通过在<paramref name="dueTime"/>内指定的持续时间内保持每个元素来限制源序列。如果在此时间窗口内生成另一个元素，则会删除该元素并为当前元素启动一个新计时器，然后重复整个过程。如果数据流的间隔从未大于等于元素间<paramref name="dueTime"/>，生成的流不会产生任何元素。为了减小流的容量同时保证元素的生成周期，请考虑使用 Observable.Sample 运算符集。</para>
            <para>不建议但受支持为<paramref name="dueTime"/>指定一个 TimeSpan.Zero值，这导致计划的限流计时器立即到期。但是，这无法保证所有元素都将保留在结果序列中。这是调度程序引入的异步的副作用，其中转发当前元素的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。此时，下一个元素可能在调度程序有机会运行限制操作之前出现。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throttle``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>忽略可观察序列中的元素，这些元素后跟计算的节流持续时间内的另一个值。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TThrottle">节流序列中选用于源序列中每个元素的元素。</typeparam>
            <param name="source">需要限制的源序列。</param>
            <param name="throttleDurationSelector">选择器函数检索指示每个给定元素的节流时间的序列。</param>
            <returns>受限制的序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="throttleDurationSelector"/>为空。</exception>
            <remarks>此运算符通过在<paramref name="throttleDurationSelector"/>表示的持续时间内保持每个元素来限制源序列。如果在此时间窗口内生成另一个元素，则会删除该元素并为当前元素启动一个新计时器，然后重复整个过程。对于通过应用<paramref name="throttleDurationSelector"/>至每个元素计算的持续时间与后继元素的出现重叠的流，结果流将不产生任何元素。为了减小流的容量同时保证元素的生成周期，请考虑使用 Observable.Sample 运算符集。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TimeInterval``1(System.IObservable{``0})">
            <summary>记录可观察序列中连续元素之间的时间间隔。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">记录时间间隔的源序列。</param>
            <returns>包含元素时间间隔信息的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TimeInterval``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>记录可观察序列中连续元素之间的时间间隔，使用指定的调度程序计算时间间隔。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">记录时间间隔的源序列。</param>
            <param name="scheduler">调度程序用于计算时间间隔。</param>
            <returns>包含元素时间间隔信息的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.TimeSpan)">
            <summary>对可观察序列中的每个元素应用超时策略。距开始前导活动指定超时持续时间内未收到下一个元素时，则 TimeoutException 将传播给观察者。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="dueTime">超时发生前的数值间的最大持续时间。</param>
            <returns>在超时的情况下含有 TimeoutException 的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <exception cref="T:System.TimeoutException">（异步）距前一个元素<paramref name="dueTime"/>内，如果未生成任何元素。</exception>
            <remarks>
            <para>如果您只想在第一个元素上超时，请考虑将<see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/>运算符应用于源序列和延迟的<see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/>序列。或者，可以使用 Timeout <see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/>的通用重载。</para>
            <para>不建议但受支持为<paramref name="dueTime"/>指定一个 TimeSpan.Zero 值，这导致计划的超时计时器立即到期。但是，这甚至无法保证第一个元素也会发生超时。这是调度程序引入的异步的副作用，其中传播超时的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。此时，下一个元素可能在调度程序有机会运行超时操作之前出现。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>对可观察序列中的每个元素应用超时策略，使用指定的调度程序运行超时计时器。距开始前导活动指定超时持续时间内未收到下一个元素时，则 TimeoutException 将传播给观察者。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="dueTime">超时发生前的数值间的最大持续时间。</param>
            <param name="scheduler">运行超时计时器的调度程序。</param>
            <returns>在超时的情况下含有 TimeoutException 的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <exception cref="T:System.TimeoutException">（异步）距前一个元素<paramref name="dueTime"/>内，如果未生成任何元素。</exception>
            <remarks>
            <para>如果您只想在第一个元素上超时，请考虑将<see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/>运算符应用于源序列和延迟的<see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/>序列。或者，可以使用 Timeout <see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/>的通用重载。</para>
            <para>不建议但受支持为<paramref name="dueTime"/>指定一个 TimeSpan.Zero 值，这导致计划的超时计时器立即到期。但是，这甚至无法保证第一个元素也会发生超时。这是调度程序引入的异步的副作用，其中传播超时的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。此时，下一个元素可能在调度程序有机会运行超时操作之前出现。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.TimeSpan,System.IObservable{``0})">
            <summary>对可观察序列中的每个元素应用超时策略。距开始前导活动指定超时持续时间内未收到下一个元素时，则使用另一个可观察序列生成后续消息。</summary>
            <typeparam name="TSource">源序列中元素的类型以及超时时使用的其他序列。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="dueTime">超时发生前的数值间的最大持续时间。</param>
            <param name="other">在超时的情况下返回的序列。</param>
            <returns>在超时的情况下，源序列切换为另一个序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="other"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>如果您只想在第一个元素上超时，请考虑将<see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/>运算符应用于源序列和延迟的<see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/>序列。或者，可以使用 Timeout <see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/>的通用重载。</para>
            <para>不建议但受支持为<paramref name="dueTime"/>指定一个 TimeSpan.Zero 值，这导致计划的超时计时器立即到期。但是，这甚至无法保证第一个元素也会发生超时。这是调度程序引入的异步的副作用，其中传播超时的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。此时，下一个元素可能在调度程序有机会运行超时操作之前出现。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.TimeSpan,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>对可观察序列中的每个元素应用超时策略，使用指定的调度程序运行超时计时器。距开始前导活动指定超时持续时间内未收到下一个元素时，则使用另一个可观察序列生成后续消息。</summary>
            <typeparam name="TSource">源序列中元素的类型以及超时时使用的其他序列。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="dueTime">超时发生前的数值间的最大持续时间。</param>
            <param name="other">在超时的情况下返回的序列。</param>
            <param name="scheduler">运行超时计时器的调度程序。</param>
            <returns>在超时的情况下，源序列切换为另一个序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="other"/>或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>如果您只想在第一个元素上超时，请考虑将<see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/>运算符应用于源序列和延迟的<see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/>序列。或者，可以使用 Timeout <see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/>的通用重载。</para>
            <para>不建议但受支持为<paramref name="dueTime"/>指定一个 TimeSpan.Zero 值，这导致计划的超时计时器立即到期。但是，这甚至无法保证第一个元素也会发生超时。这是调度程序引入的异步的副作用，其中传播超时的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。此时，下一个元素可能在调度程序有机会运行超时操作之前出现。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>根据绝对时间对可观察序列应用超时策略。如果序列未在指定的绝对到期时间之前终止，则 TimeoutException 将传播给观察者。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="dueTime">超时发生的时间。如果此值小于或等于 DateTimeOffset.UtcNow，则立即发生超时。</param>
            <returns>在超时的情况下含有 TimeoutException 的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.TimeoutException">（异步）如果序列在<paramref name="dueTime"/>之前没有终止。</exception>
            <remarks>如果您只想在第一个元素上超时，请考虑将<see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/>运算符应用于源序列和延迟的<see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/>序列。或者，可以使用 Timeout <see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/>的通用重载。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>根据绝对时间对可观察序列应用超时策略，使用指定的调度程序运行超时计时器。如果序列未在指定的绝对到期时间之前终止，则 TimeoutException 将传播给观察者。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="dueTime">超时发生的时间。如果此值小于或等于 DateTimeOffset.UtcNow，则立即发生超时。</param>
            <param name="scheduler">运行超时计时器的调度程序。</param>
            <returns>在超时的情况下含有 TimeoutException 的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.TimeoutException">（异步）如果序列在<paramref name="dueTime"/>之前没有终止。</exception>
            <remarks>如果您只想在第一个元素上超时，请考虑将<see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/>运算符应用于源序列和延迟的<see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/>序列。或者，可以使用 Timeout <see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/>的通用重载。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.DateTimeOffset,System.IObservable{``0})">
            <summary>根据绝对时间对可观察序列应用超时策略。如果序列未在指定的绝对到期时间之前终止，则使用另一个可观察序列从该时间点生成后续消息。</summary>
            <typeparam name="TSource">源序列中元素的类型以及超时时使用的其他序列。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="dueTime">超时发生的时间。如果此值小于或等于 DateTimeOffset.UtcNow，则立即发生超时。</param>
            <param name="other">在超时的情况下返回的序列。</param>
            <returns>在超时的情况下，源序列切换为另一个序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="other"/>为空。</exception>
            <remarks>如果您只想在第一个元素上超时，请考虑将<see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/>运算符应用于源序列和延迟的<see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/>序列。或者，可以使用 Timeout <see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/>的通用重载。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.DateTimeOffset,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>根据绝对时间对可观察序列应用超时策略，使用指定的调度程序运行超时计时器。如果序列未在指定的绝对到期时间之前终止，则使用另一个可观察序列从该时间点生成后续消息。</summary>
            <typeparam name="TSource">源序列中元素的类型以及超时时使用的其他序列。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="dueTime">超时发生的时间。如果此值小于或等于 DateTimeOffset.UtcNow，则立即发生超时。</param>
            <param name="other">在超时的情况下返回的序列。</param>
            <param name="scheduler">运行超时计时器的调度程序。</param>
            <returns>在超时的情况下，源序列切换为另一个序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="other"/>或<paramref name="scheduler"/>为空。</exception>
            <remarks>如果您只想在第一个元素上超时，请考虑将<see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/>运算符应用于源序列和延迟的<see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/>序列。或者，可以使用 Timeout <see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/>的通用重载。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>根据为每个元素计算的超时持续时间，对可观察序列应用超时策略。距开始前导活动计算的超时持续时间内未收到下一个元素时，则 TimeoutException 将传播给观察者。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TTimeout">超时序列中指示源序列中每个元素的超时持续时间的元素。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="timeoutDurationSelector">选择器用于检索表示当前元素和下一个元素之间超时的可观察序列。</param>
            <returns>在超时的情况下含有 TimeoutException 的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="timeoutDurationSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}},System.IObservable{``0})">
            <summary>根据为每个元素计算的超时持续时间，对可观察序列应用超时策略。距开始前导活动计算的超时持续时间内未收到下一个元素时，则使用另一个可观察序列从该时间点生成后续消息。</summary>
            <typeparam name="TSource">源序列中元素的类型以及超时时使用的其他序列。</typeparam>
            <typeparam name="TTimeout">超时序列中指示源序列中每个元素的超时持续时间的元素。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="timeoutDurationSelector">选择器用于检索表示当前元素和下一个元素之间超时的可观察序列。</param>
            <param name="other">在超时的情况下返回的序列。</param>
            <returns>在超时的情况下，源序列切换为另一个序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="timeoutDurationSelector"/>或<paramref name="other"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})">
            <summary>根据第一个元素的初始超时持续时间和为每个后续元素计算的超时持续时间，对可观察序列应用超时策略。距开始前导活动计算的超时持续时间内未收到下一个元素时，则 TimeoutException 将传播给观察者。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TTimeout">超时序列中指示源序列中每个元素的超时持续时间的元素。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="firstTimeout">表示第一个元素超时的可观察序列。</param>
            <param name="timeoutDurationSelector">选择器用于检索表示当前元素和下一个元素之间超时的可观察序列。</param>
            <returns>在超时的情况下含有 TimeoutException 的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="firstTimeout"/>或<paramref name="timeoutDurationSelector"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}},System.IObservable{``0})">
            <summary>根据第一个元素的初始超时持续时间和为每个后续元素计算的超时持续时间，对可观察序列应用超时策略。距开始前导活动计算的超时持续时间内未收到下一个元素时，则使用另一个可观察序列从该时间点生成后续消息。</summary>
            <typeparam name="TSource">源序列中元素的类型以及超时时使用的其他序列。</typeparam>
            <typeparam name="TTimeout">超时序列中指示源序列中每个元素的超时持续时间的元素。</typeparam>
            <param name="source">执行超时的源序列。</param>
            <param name="firstTimeout">表示第一个元素超时的可观察序列。</param>
            <param name="timeoutDurationSelector">选择器用于检索表示当前元素和下一个元素之间超时的可观察序列。</param>
            <param name="other">在超时的情况下返回的序列。</param>
            <returns>在超时的情况下，源序列切换为另一个序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="firstTimeout"/>或<paramref name="timeoutDurationSelector"/>或<paramref name="other"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.TimeSpan)">
            <summary>返回一个可观察序列，该序列在指定的相对到期时间结束后生成一个值。</summary>
            <param name="dueTime">生成数值的相对时间。如果此值小于或等于 TimeSpan.Zero，则将尽快触发计时器。</param>
            <returns>一个可观察序列，该序列在到期时间结束后生成一个值。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.DateTimeOffset)">
            <summary>返回一个可观察序列，该序列在指定的绝对到期时间结束后生成一个值。</summary>
            <param name="dueTime">生成数值的绝对时间。如果此值小于或等于 DateTimeOffset.UtcNow，则将尽快触发计时器。</param>
            <returns>一个可观察的序列，该系列在到期时间结束后生成一个值。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.TimeSpan,System.TimeSpan)">
            <summary>返回一个可观察序列，该序列在指定的初始相对到期时间结束后周期性地生成一个值。</summary>
            <param name="dueTime">生成第一个值的相对时间。如果此值小于或等于 TimeSpan.Zero，则将尽快触发计时器。</param>
            <param name="period">生成后续值的时间。如果此值等于 TimeSpan.Zero，则定时器将尽快重现。</param>
            <returns>一个可观察序列，该序列先在到期时间结束，然后在每个时段结束后生成一个值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.DateTimeOffset,System.TimeSpan)">
            <summary>返回一个可观察序列，该序列在指定的初始绝对到期时间开始后周期性地生成一个值。</summary>
            <param name="dueTime">生成第一个值的绝对时间。如果此值小于或等于 DateTimeOffset.UtcNow，则将尽快触发计时器。</param>
            <param name="period">生成后续值的时间。如果此值等于 TimeSpan.Zero，则定时器将尽快重现。</param>
            <returns>一个可观察序列，该序列先在到期时间结束，然后在每个时段结束后生成一个值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察序列，该序列在指定的相对到期时间结束后生成一个值，使用指定调度程序运行计时器。</summary>
            <param name="dueTime">生成数值的相对时间。如果此值小于或等于 TimeSpan.Zero，则将尽快触发计时器。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>一个可观察序列，该序列在到期时间结束后生成一个值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察序列，该序列在指定的绝对到期时间结束后生成一个值，使用指定调度程序运行计时器。</summary>
            <param name="dueTime">生成数值的绝对时间。如果此值小于或等于 DateTimeOffset.UtcNow，则将尽快触发计时器。</param>
            <param name="scheduler">运行定时器的调度程序。</param>
            <returns>一个可观察的序列，该系列在到期时间结束后生成一个值。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.TimeSpan,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察序列，该序列在指定的初始相对到期时间结束后周期性地生成一个值，使用指定调度程序运行计时器。</summary>
            <param name="dueTime">生成第一个值的相对时间。如果此值小于或等于 TimeSpan.Zero，则将尽快触发计时器。</param>
            <param name="period">生成后续值的时间。如果此值等于 TimeSpan.Zero，则定时器将尽快重现。</param>
            <param name="scheduler">运行计时器的调度程序。</param>
            <returns>一个可观察序列，该序列先在到期时间结束，然后在每个时段结束后生成一个值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.DateTimeOffset,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>返回一个可观察序列，该序列在指定的初始绝对到期时间开始后周期性地生成一个值，使用指定调度程序运行计时器。</summary>
            <param name="dueTime">生成第一个值的绝对时间。如果此值小于或等于 DateTimeOffset.UtcNow，则将尽快触发计时器。</param>
            <param name="period">生成后续值的时间。如果此值等于 TimeSpan.Zero，则定时器将尽快重现。</param>
            <param name="scheduler">运行计时器的调度程序。</param>
            <returns>一个可观察序列，该序列先在到期时间结束，然后在每个时段结束后生成一个值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timestamp``1(System.IObservable{``0})">
            <summary>使用本地系统时钟为可观察序列中的每个元素添加时间戳。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">添加时间戳元素的源序列。</param>
            <returns>具有元素时间戳信息的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timestamp``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定调度程序的时钟为可观察序列中的每个元素添加时间戳。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">添加时间戳元素的源序列。</param>
            <param name="scheduler">计算时间戳的调度程序。</param>
            <returns>具有元素时间戳信息的可观察序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan)">
            <summary>将可观察序列的每个元素投射至基于定时信息产生的连续非重叠窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="timeSpan">每个窗口的长度。</param>
            <returns>窗口的顺序。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 小于 TimeSpan.Zero。</exception>
            <remarks>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，这导致调度程序尽可能快地创建窗口。因为所有源序列元素都在其中一个窗口中结束，所以部分窗口的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前窗口和创建新窗口的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，将可观察序列的每个元素投射至基于定时信息生成的连续非重叠窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="timeSpan">每个窗口的长度。</param>
            <param name="scheduler">运行窗口计时器的调度程序。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 小于 TimeSpan.Zero。</exception>
            <remarks>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，这导致调度程序尽可能快地创建窗口。因为所有源序列元素都在其中一个窗口中结束，所以部分窗口的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前窗口和创建新窗口的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan)">
            <summary>将可观察序列的每个元素投射至基于定时信息产生的零个或多个窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="timeSpan">每个窗口的长度。</param>
            <param name="timeShift">创建连续缓窗口的间隔。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 或 <paramref name="timeSpan"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，导致调度程序在最短用时内创建窗口。但是，部分窗口的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前窗口的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            <para>不建议但受支持为<paramref name="timeShift"/>指定一个 TimeSpan.Zero 值，这导致调度程序尽可能快地创建窗口。但是，这并表示所有窗口都将从源序列的开头开始。这是调度程序引入的异步的副作用，其中创建新窗口的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的调度程序运行定时器，将可观察序列的每个元素投射至基于定时信息生成的零个或多个窗口。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="timeSpan">每个窗口的长度。</param>
            <param name="timeShift">创建连续缓窗口的间隔。</param>
            <param name="scheduler">运行窗口计时器的调度程序。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 或 <paramref name="timeSpan"/> 小于 TimeSpan.Zero。</exception>
            <remarks>
            <para>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，导致调度程序在最短用时内创建窗口。但是，部分窗口的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前窗口的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            <para>不建议但受支持为<paramref name="timeShift"/>指定一个 TimeSpan.Zero 值，这导致调度程序尽可能快地创建窗口。但是，这并表示所有窗口都将从源序列的开头开始。这是调度程序引入的异步的副作用，其中创建新窗口的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.Int32)">
            <summary>将可观察序列的每个元素投射至一个窗口，该窗口在其内存已满或已经过去一定时间后发送。这种超载的现实类比是相当于渡船在所有座位均已落座或到达预定离港时驶离码头的行为，以先发生者为准。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="timeSpan">窗口的最大时间长度。</param>
            <param name="count">窗口的最大元素数。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 小于 TimeSpan.Zero。-或-<paramref name="count"/>小于等于零。</exception>
            <remarks>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，这导致调度程序尽可能快地创建窗口。因为所有源序列元素都在其中一个窗口中结束，所以部分窗口的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前窗口和创建新窗口的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定调度程序运行定时器，将可观察序列的每个元素投射至一个窗口，该窗口在其内存已满或已经过去一定时间后发送。这种超载的现实类比是相当于渡船在所有座位均已落座或到达预定离港时驶离码头的行为，以先发生者为准。</summary>
            <typeparam name="TSource">源序列中的元素类型以及结果序列中的窗口。</typeparam>
            <param name="source">生成窗口的源序列。</param>
            <param name="timeSpan">窗口的最大时间长度。</param>
            <param name="count">窗口的最大元素数。</param>
            <param name="scheduler">运行窗口计时器的调度程序。</param>
            <returns>一个可观察的窗口序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> 小于 TimeSpan.Zero。-或-<paramref name="count"/>小于等于零。</exception>
            <remarks>不建议但受支持为<paramref name="timeSpan"/>指定一个 TimeSpan.Zero 值，这导致调度程序尽可能快地创建窗口。因为所有源序列元素都在其中一个窗口中结束，所以部分窗口的时间跨度不会为零。这是调度程序引入的异步的副作用，其中关闭当前窗口和创建新窗口的操作可能不会立即执行，尽管设置了 TimeSpan.Zero 到期时间。</remarks>
        </member>
        <member name="T:System.Reactive.Linq.IQueryLanguage">
            <summary>描述 LINQ 到事件查询语言的内部接口。</summary>
        </member>
        <member name="T:System.Reactive.EventPatternSourceBase`2">
            <summary>将可观察序列公开为众所周知的事件模式（发送程序，事件参数）的基类。包含维护事件处理程序委托映射到可观察序列订阅的功能。子类只应添加一个事件，其中自定义添加和删除方法调用基类的操作。</summary>
            <typeparam name="TSender">引发事件的发送程序的类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.EventPatternSourceBase`2.#ctor(System.IObservable{System.Reactive.EventPattern{`0,`1}},System.Action{System.Action{`0,`1},System.Reactive.EventPattern{`0,`1}})">
            <summary>创建新的事件模式源。</summary>
            <param name="source">公开为事件的源序列。</param>
            <param name="invokeHandler">委托用于为序列的每个元素调用事件。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="invokeHandler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.EventPatternSourceBase`2.Add(System.Delegate,System.Action{`0,`1})">
            <summary>添加指定的事件处理程序，从而导致对基础源的订阅。</summary>
            <param name="handler">要添加的事件处理程序。应该将相同的委托传递给 Remove 操作以删除事件处理程序。</param>
            <param name="invoke">调用委托以在派生类中引发事件。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="handler"/> 或<paramref name="invoke"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.EventPatternSourceBase`2.Remove(System.Delegate)">
            <summary>删除指定的事件处理程序，这导致处理在 Add 操作期间创建的基础源的相应订阅。</summary>
            <param name="handler">要删除的事件处理程序。这应该是与传递给 Add 操作的委托相同的委托。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="handler"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.EventPattern`1">
            <summary>表示一个.NET事件调用，它由引发事件的弱类型对象和事件生成的数据组成。</summary>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
        </member>
        <member name="T:System.Reactive.EventPattern`2">
            <summary>表示由引发事件的强类型对象和事件生成的数据组成的.NET 事件调用。</summary>
            <typeparam name="TSender">引发事件的发送程序的类型。</typeparam>
            <typeparam name="TEventArgs">事件生成的事件数据的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.EventPattern`2.#ctor(`0,`1)">
            <summary>使用给定的发送程序和事件数据创建. NET 事件调用的新数据表示实例。</summary>
            <param name="sender">引发事件的发件程序对象。</param>
            <param name="e">事件生成的事件数据。</param>
        </member>
        <member name="M:System.Reactive.EventPattern`2.Equals(System.Reactive.EventPattern{`0,`1})">
            <summary>确定当前的 EventPattern &lt;TSender, TEventArgs&gt; 对象是否与指定的 EventPattern&lt;TSender, TEventArgs&gt; 对象表示相同的事件。</summary>
            <param name="other">要与当前 EventPattern&lt;TSender, TEventArgs&gt; 对象进行比较的对象。</param>
            <returns>如果两个 EventPattern&lt;TSender, TEventArgs&gt; 对象表示同一事件，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.EventPattern`2.Equals(System.Object)">
            <summary>确定指定的 System.Object 是否与当前 EventPattern&lt;TSender, TEventArgs&gt; 一致。</summary>
            <param name="obj">要与当前 EventPattern&lt;TSender, TEventArgs&gt; 进行比较的 System.Object。</param>
            <returns>如果指定的 System.Object 是否与当前 EventPattern&lt;TSender, TEventArgs&gt; 一致，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.EventPattern`2.GetHashCode">
            <summary>返回当前 EventPattern&lt;TSender, TEventArgs&gt; 实例的散列码。</summary>
            <returns>当前 EventPattern&lt;TSender, TEventArgs&gt; 实例的散列码。</returns>
        </member>
        <member name="M:System.Reactive.EventPattern`2.op_Equality(System.Reactive.EventPattern{`0,`1},System.Reactive.EventPattern{`0,`1})">
            <summary>确定两个指定的EventPattern&lt;TSender, TEventArgs&gt; 对象是否表示同一事件。</summary>
            <param name="first">第一个比较的 EventPattern&lt;TSender, TEventArgs&gt;，或 null。</param>
            <param name="second">第二个比较的 EventPattern&lt;TSender, TEventArgs&gt;，或 null。</param>
            <returns>如果两个 EventPattern&lt;TSender, TEventArgs&gt; 对象表示同一事件，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.EventPattern`2.op_Inequality(System.Reactive.EventPattern{`0,`1},System.Reactive.EventPattern{`0,`1})">
            <summary>确定两个指定的 EventPattern&lt;TSender, TEventArgs&gt; 对象是否表示不同的事件。</summary>
            <param name="first">第一个比较的 EventPattern&lt;TSender, TEventArgs&gt;，或 null。</param>
            <param name="second">第二个比较的 EventPattern&lt;TSender, TEventArgs&gt;，或 null。</param>
            <returns>如果两个 EventPattern&lt;TSender, TEventArgs&gt; 对象不表示同一事件，则为真；否则为假。</returns>
        </member>
        <member name="P:System.Reactive.EventPattern`2.Sender">
            <summary>获取引发事件的发送程序对象。</summary>
        </member>
        <member name="P:System.Reactive.EventPattern`2.EventArgs">
            <summary>获取事件生成的事件数据。</summary>
        </member>
        <member name="M:System.Reactive.EventPattern`1.#ctor(System.Object,`0)">
            <summary>使用给定的发送程序和事件数据创建. NET 事件调用的新数据表示实例。</summary>
            <param name="sender">引发事件的发件程序对象。</param>
            <param name="e">事件生成的事件数据。</param>
        </member>
        <member name="T:System.Reactive.Concurrency.HistoricalSchedulerBase">
            <summary>历史调度程序的基类，该调度程序是使用 DateTimeOffset 作为绝对时间，使用 TimeSpan作为相对时间的虚拟时间调度程序。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2">
            <summary>虚拟时间调度程序的基类。</summary>
            <typeparam name="TAbsolute">绝对时间表示类型。</typeparam>
            <typeparam name="TRelative">相对时间表示类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.#ctor">
            <summary>创建一个新的虚拟时间调度程序，其中默认值 Tabsolute 为初始时钟值。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.#ctor(`0,System.Collections.Generic.IComparer{`0})">
            <summary>使用指定的初始时钟值和绝对时间比较器创建新的虚拟时间调度程序。</summary>
            <param name="initialClock">时钟的初始值。</param>
            <param name="comparer">基于绝对时间确定事件因果关系的比较器。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Add(`0,`1)">
            <summary>将相对时间值添加到绝对时间值。</summary>
            <param name="absolute">绝对时间值。</param>
            <param name="relative">要添加的相对时间值。</param>
            <returns>得到的绝对时间总和值。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.ToDateTimeOffset(`0)">
            <summary>将绝对时间值转换为 DateTimeOffset 值。</summary>
            <param name="absolute">要转换的绝对时间值。</param>
            <returns>相应的 DateTimeOffset 值。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.ToRelative(System.TimeSpan)">
            <summary>将 TimeSpan 值转换为相对时间值。</summary>
            <param name="timeSpan">要转换的 TimeSpan 值。</param>
            <returns>相应的相对时间值。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.ScheduleAbsolute``1(``0,`0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>分配在 dueTime 时执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.ScheduleRelative``1(``0,`1,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>分配在 dueTime 时执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Schedule``1(``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排要执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Schedule``1(``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排在 dueTime 之后执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Schedule``1(``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>分配在 dueTime 时执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Start">
            <summary>启动虚拟时间调度程序。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Stop">
            <summary>停止虚拟时间调度程序。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.AdvanceTo(`0)">
            <summary>将调度程序的时钟提前到指定时间，运行所有工作直到该时间点。</summary>
            <param name="time">调度程序的时钟提前的绝对时间。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="time"/> 已结束。</exception>
            <exception cref="T:System.InvalidOperationException">调度程序已在运行。VirtualTimeScheduler 不支持运行嵌套的工作调度循环。要在调度程序上运行工作的同时模拟时间滑动，请使用<see cref="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Sleep(`1)"/>。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.AdvanceBy(`1)">
            <summary>将调度程序的时钟调快指定的相对时间，同时运行该时间跨度内计划的所有工作。</summary>
            <param name="time">调度程序时钟调快的相对时间。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="time"/> 为负值。</exception>
            <exception cref="T:System.InvalidOperationException">调度程序已在运行。VirtualTimeScheduler 不支持运行嵌套的工作调度循环。要在调度程序上运行工作的同时模拟时间滑动，请使用<see cref="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Sleep(`1)"/>。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Sleep(`1)">
            <summary>将调度程序的时钟调快指定的相对时间。</summary>
            <param name="time">调度程序时钟调快的相对时间。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="time"/> 为负值。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.GetNext">
            <summary>获取要执行的下一个计划项。</summary>
            <returns>下一个计划项。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.GetService(System.Type)">
            <summary>按接口类型查找调度程序服务。基类实现仅支持 IStopwatchProvider 服务。要影响服务查找—例如为其他调度程序服务提供支持—派生类可覆盖此方法。</summary>
            <param name="serviceType">要查找的调度程序服务接口类型。</param>
            <returns>实现所请求服务的对象（如果可用）;否则为空。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.StartStopwatch">
            <summary>启动一个新的秒表对象。</summary>
            <returns>新的秒表对象；在请求时启动。</returns>
        </member>
        <member name="P:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.IsEnabled">
            <summary>获悉是否启用调度程序以运行工作。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Comparer">
            <summary>获取用于比较绝对时间值的比较器。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Clock">
            <summary>获取调度程序的绝对时间时钟值。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Now">
            <summary>获取调度程序的当前时间概念。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.#ctor">
            <summary>创建一个新的历史调度程序，其最小值 DateTimeOffset 作为初始时钟值。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.#ctor(System.DateTimeOffset)">
            <summary>使用指定的初始时钟值创建新的历史调度程序。</summary>
            <param name="initialClock">初始时钟值。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.#ctor(System.DateTimeOffset,System.Collections.Generic.IComparer{System.DateTimeOffset})">
            <summary>使用指定的初始时钟值和绝对时间比较器创建新的历史调度程序。</summary>
            <param name="initialClock">时钟的初始值。</param>
            <param name="comparer">基于绝对时间确定事件因果关系的比较器。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.Add(System.DateTimeOffset,System.TimeSpan)">
            <summary>将相对时间值添加到绝对时间值。</summary>
            <param name="absolute">绝对时间值。</param>
            <param name="relative">要添加的相对时间值。</param>
            <returns>得到的绝对时间总和值。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.ToDateTimeOffset(System.DateTimeOffset)">
            <summary>将绝对时间值转换为 DateTimeOffset 值。</summary>
            <param name="absolute">要转换的绝对时间值。</param>
            <returns>相应的 DateTimeOffset 值。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.ToRelative(System.TimeSpan)">
            <summary>将 TimeSpan 值转换为相对时间值。</summary>
            <param name="timeSpan">要转换的 TimeSpan 值。</param>
            <returns>相应的相对时间值。</returns>
        </member>
        <member name="T:System.Reactive.Concurrency.HistoricalScheduler">
            <summary>提供一个虚拟时间调度程序，其中 DateTimeOffset 为作绝对时间，TimeSpan 为作相对时间。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.#ctor">
            <summary>创建一个新的历史调度程序，其最小值 DateTimeOffset 作为初始时钟值。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.#ctor(System.DateTimeOffset)">
            <summary>使用指定的初始时钟值创建新的历史调度程序。</summary>
            <param name="initialClock">时钟的初始值。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.#ctor(System.DateTimeOffset,System.Collections.Generic.IComparer{System.DateTimeOffset})">
            <summary>使用指定的初始时钟值创建新的历史调度程序。</summary>
            <param name="initialClock">时钟的初始值。</param>
            <param name="comparer">基于绝对时间确定事件因果关系的比较器。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.GetNext">
            <summary>获取要执行的下一个计划项。</summary>
            <returns>下一个计划项。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.ScheduleAbsolute``1(``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>分配在 dueTime 时执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Concurrency.VirtualTimeScheduler`2">
            <summary>虚拟时间调度程序的基类，该程序使用计划项目的优先级队列。</summary>
            <typeparam name="TAbsolute">绝对时间表示类型。</typeparam>
            <typeparam name="TRelative">相对时间表示类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeScheduler`2.#ctor">
            <summary>创建一个新的虚拟时间调度程序，其中默认值 Tabsolute 为初始时钟值。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeScheduler`2.#ctor(`0,System.Collections.Generic.IComparer{`0})">
            <summary>创建新的虚拟时间调度程序。</summary>
            <param name="initialClock">时钟的初始值。</param>
            <param name="comparer">基于绝对时间确定事件因果关系的比较器。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeScheduler`2.GetNext">
            <summary>获取要执行的下一个计划项。</summary>
            <returns>下一个计划项。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeScheduler`2.ScheduleAbsolute``1(``0,`0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>分配在 dueTime 时执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Subjects.ConnectableObservable`2">
            <summary>表示可以与基础可观察序列连接和断开的可观察包装器。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <typeparam name="TResult">通过主题转换后，结果序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.ConnectableObservable`2.#ctor(System.IObservable{`0},System.Reactive.Subjects.ISubject{`0,`1})">
            <summary>创建一个可以与其源连接和断开的可观察对象。</summary>
            <param name="source">可以与包装器连接和断开的潜在可观察源序列。</param>
            <param name="subject">被可连接可观察序列公开的主题，在连接时从基础源序列接收数据。</param>
        </member>
        <member name="M:System.Reactive.Subjects.ConnectableObservable`2.Connect">
            <summary>将可观察的包装器连接到其源。只要建立连接，所有订阅的观察者都将从基础可观察序列接收值。</summary>
            <returns>用于将可观察包装器与其源断开的可处置对象，导致已订阅的观察者停止从基础可观察序列接收值。</returns>
        </member>
        <member name="M:System.Reactive.Subjects.ConnectableObservable`2.Subscribe(System.IObserver{`1})">
            <summary>为可观察序列订阅观察者。除非通过 Connect 方法建立连接，否则不会接收来自基础可观察源的值。</summary>
            <param name="observer">当前 ConnectableObservable 实例通过调用 Connect 进行连接时将从基础可观察源接收值的 Observer。</param>
            <returns>用于取消订阅可观察序列的可处置对象。</returns>
        </member>
        <member name="T:System.Reactive.Subjects.Subject">
            <summary>提供一组用于创建主题的静态方法。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.Subject.Create``2(System.IObserver{``0},System.IObservable{``1})">
            <summary>从指定的观察者和可观察对象创建主题。</summary>
            <typeparam name="TSource">观察者收到的元素类型。</typeparam>
            <typeparam name="TResult">可观察序列生成的元素的类型。</typeparam>
            <param name="observer">观察者过去常常向主题发送消息。</param>
            <param name="observable">该可观察对象用于订阅从主题发送的消息。</param>
            <returns>使用给定观察者和可观察对象实现的主题。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 或<paramref name="observable"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.Subject.Synchronize``2(System.Reactive.Subjects.ISubject{``0,``1})">
            <summary>同步发送给主题的消息。</summary>
            <typeparam name="TSource">主题接收的元素类型。</typeparam>
            <typeparam name="TResult">主题产生的元素的类型。</typeparam>
            <param name="subject">要同步的主题。</param>
            <returns>消息同步的主题。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.Subject.Synchronize``2(System.Reactive.Subjects.ISubject{``0,``1},System.Reactive.Concurrency.IScheduler)">
            <summary>同步发送给主题的消息，并通知指定调度程序上的观察者。</summary>
            <typeparam name="TSource">主题接收的元素类型。</typeparam>
            <typeparam name="TResult">主题产生的元素的类型。</typeparam>
            <param name="subject">要同步的主题。</param>
            <param name="scheduler">调度程序通知观察者。</param>
            <returns>消息已同步且在给定调度程序上通知其观察者的主题。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="T:System.Reactive.Subjects.AsyncSubject`1">
            <summary>表示异步操作的结果。OnCompleted 通知之前的最后一个值或通过 OnError 接收的错误将发送给所有订阅观察者。</summary>
            <typeparam name="T">主题处理的元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.#ctor">
            <summary>创建一个只能接收一个值的主题，并为将来的所有观察缓存该值。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.OnCompleted">
            <summary>将序列已结束通知所有已订阅观察者，这也导致发送最后一个接收的值（如果有）。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.OnError(System.Exception)">
            <summary>将异常情况通知所有订阅观察者。</summary>
            <param name="error">发送给所有观察者的异常情况。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.OnNext(`0)">
            <summary>向主题发送一个值。成功终止前收到的最后一个值将发送给所有订阅的观察者和后续观察者。</summary>
            <param name="value">存储在主题中的值。</param>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.Subscribe(System.IObserver{`0})">
            <summary>订阅该主题的观察者。</summary>
            <param name="observer">观察者订阅该主题。</param>
            <returns>可用于从主题中取消订阅观察者的可处置对象</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.Dispose">
            <summary>取消订阅所有观察者并释放资源。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.GetAwaiter">
            <summary>获取当前 AsyncSubject 的等待对象。</summary>
            <returns>可以等待的对象。</returns>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.OnCompleted(System.Action)">
            <summary>指定主题完成时将调用的回调操作。</summary>
            <param name="continuation">主题完成时将调用的回调操作。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="continuation"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.GetResult">
            <summary>获取主题的最后一个元素，可能会阻塞，直到主题成功完成或异常完成。</summary>
            <returns>该主题的最后一个元素。如果未收到任何元素，则引发 InvalidOperationException。</returns>
            <exception cref="T:System.InvalidOperationException">源序列为空。</exception>
        </member>
        <member name="P:System.Reactive.Subjects.AsyncSubject`1.HasObservers">
            <summary>指示主题是否有观察者订阅。</summary>
        </member>
        <member name="P:System.Reactive.Subjects.AsyncSubject`1.IsCompleted">
            <summary>获悉 AsyncSubject 是否已完成。</summary>
        </member>
        <member name="T:System.Reactive.Subjects.BehaviorSubject`1">
            <summary>表示随时间变化的值。观察者可以订阅主题以接收最后（或初始）值以及所有后续通知。</summary>
            <typeparam name="T">主题处理的元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.#ctor(`0)">
            <summary>初始化一个<see cref="T:System.Reactive.Subjects.BehaviorSubject`1"/>类的新实例，该实例创建一个缓存其最后一个值并以指定值开始的主题。</summary>
            <param name="value">当主体尚未收到其他值时发送给观察者的初始值。</param>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.OnCompleted">
            <summary>将序列已结束情况通知所有订阅的观察者。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.OnError(System.Exception)">
            <summary>将异常情况通知所有订阅观察者。</summary>
            <param name="error">发送给所有观察者的异常情况。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.OnNext(`0)">
            <summary>通知所有已订阅的观察者有关指定元素到达序列的信息。</summary>
            <param name="value">要发送给所有观察者的值。</param>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.Subscribe(System.IObserver{`0})">
            <summary>订阅该主题的观察者。</summary>
            <param name="observer">观察者订阅该主题。</param>
            <returns>可用于从主题中取消订阅观察者的可处置对象</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.Dispose">
            <summary>取消订阅所有观察者并释放资源。</summary>
        </member>
        <member name="P:System.Reactive.Subjects.BehaviorSubject`1.Value">
            <summary>获取当前值或引发异常。</summary>
            <value>传递给构造函数的初始值，直到<see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnNext(`0)"/> 被调用后传递给的最后一个值 <see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnNext(`0)"/>。</value>
            <remarks>
            <para><see cref="P:System.Reactive.Subjects.BehaviorSubject`1.Value"/> 在<see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnCompleted"/>被调用后冻结。</para>
            <para><see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnError(System.Exception)"/>被调用后，<see cref="P:System.Reactive.Subjects.BehaviorSubject`1.Value"/>始终引发指定异常。</para>
            <para><see cref="M:System.Reactive.Subjects.BehaviorSubject`1.Dispose"/> 被调用后，始终引发异常。</para>
            <alert type="caller">读取<see cref="P:System.Reactive.Subjects.BehaviorSubject`1.Value"/>是一种线程安全操作，虽然有一个潜在的竞争条件，即<see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnNext(`0)"/>或<see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnError(System.Exception)"/>被同时调用。在某些情况下，调用方可能需要使用外部同步来避免竞争条件。</alert>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">处理被调用。</exception>
        </member>
        <member name="P:System.Reactive.Subjects.BehaviorSubject`1.HasObservers">
            <summary>指示主题是否有观察者订阅。</summary>
        </member>
        <member name="T:System.Reactive.Subjects.Subject`1">
            <summary>表示对象既是可观察序列又是观察者。每个通知都会向所有订阅的观察者广播。</summary>
            <typeparam name="T">主题处理的元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.#ctor">
            <summary>创建一个主题。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.OnCompleted">
            <summary>将序列已结束情况通知所有订阅的观察者。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.OnError(System.Exception)">
            <summary>通知所有已订阅的观察者有关指定的异常。</summary>
            <param name="error">发送给所有当前订阅的观察者的异常情况。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.OnNext(`0)">
            <summary>通知所有已订阅的观察者有关指定元素到达序列的信息。</summary>
            <param name="value">要发送给所有当前订阅的观察者的值。</param>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.Subscribe(System.IObserver{`0})">
            <summary>订阅该主题的观察者。</summary>
            <param name="observer">观察者订阅该主题。</param>
            <returns>可用于从主题中取消订阅观察者的可处置对象</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.Dispose">
            <summary>释放当前<see cref="T:System.Reactive.Subjects.Subject`1"/>类实例使用的所有资源并取消订阅所有观察者。</summary>
        </member>
        <member name="P:System.Reactive.Subjects.Subject`1.HasObservers">
            <summary>指示主题是否有观察者订阅。</summary>
        </member>
        <member name="T:System.Reactive.Joins.Pattern">
            <summary>连接模式的抽象基类。</summary>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`1">
            <summary>表示一个可观察序列上的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`1.Then``1(System.Func{`0,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`2">
            <summary>表示两个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`2.And``1(System.IObservable{``0})">
            <summary>创建一个在三个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource3">第三个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前两个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`2.Then``1(System.Func{`0,`1,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`3">
            <summary>表示三个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`3.And``1(System.IObservable{``0})">
            <summary>创建一个在四个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource4">第四个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前三个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`3.Then``1(System.Func{`0,`1,`2,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`4">
            <summary>表示四个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`4.And``1(System.IObservable{``0})">
            <summary>创建一个在五个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource5">第五个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前四个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`4.Then``1(System.Func{`0,`1,`2,`3,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`5">
            <summary>表示五个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`5.And``1(System.IObservable{``0})">
            <summary>创建一个在六个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource6">第六个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前五个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`5.Then``1(System.Func{`0,`1,`2,`3,`4,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`6">
            <summary>表示六个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`6.And``1(System.IObservable{``0})">
            <summary>创建一个在七个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource7">第七个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前六个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`6.Then``1(System.Func{`0,`1,`2,`3,`4,`5,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`7">
            <summary>表示七个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`7.And``1(System.IObservable{``0})">
            <summary>创建一个在八个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource8">第八个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前七个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`7.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`8">
            <summary>表示八个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`8.And``1(System.IObservable{``0})">
            <summary>创建一个在九个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource9">第九个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前八个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`8.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`9">
            <summary>表示九个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`9.And``1(System.IObservable{``0})">
            <summary>创建一个在十个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource10">第十个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前九个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`9.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`10">
            <summary>表示十个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`10.And``1(System.IObservable{``0})">
            <summary>创建一个在十一个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource11">第十一个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察的序列与前十个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`10.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`11">
            <summary>表示十一个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`11.And``1(System.IObservable{``0})">
            <summary>创建一个在十二个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource12">第十二个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前十一个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`11.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`12">
            <summary>表示十二个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`12.And``1(System.IObservable{``0})">
            <summary>创建一个在十三个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource13">第十三个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前十二个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`12.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`13">
            <summary>表示十三个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`13.And``1(System.IObservable{``0})">
            <summary>创建一个在十四个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource14">第十四个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前十三个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`13.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`14">
            <summary>表示十四个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`14.And``1(System.IObservable{``0})">
            <summary>创建一个在十五个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource15">第十五个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前十四个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`14.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`15">
            <summary>表示十五个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource15">第十五个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`15.And``1(System.IObservable{``0})">
            <summary>创建一个在十六个可观察序列中的元素均可用时匹配的模式。</summary>
            <typeparam name="TSource16">第十六个可观察序列中元素的类型。</typeparam>
            <param name="other">可观察序列与前十五个序列匹配。</param>
            <returns>创建一个在三个可观察序列中的元素均可用时匹配的对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`15.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`16">
            <summary>表示十六个可观察序列的连接模式。</summary>
            <typeparam name="TSource1">第一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource2">第二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource3">第三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource4">第四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource5">第五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource6">第六个源序列中元素的类型。</typeparam>
            <typeparam name="TSource7">第七个源序列中元素的类型。</typeparam>
            <typeparam name="TSource8">第八个源序列中元素的类型。</typeparam>
            <typeparam name="TSource9">第九个源序列中元素的类型。</typeparam>
            <typeparam name="TSource10">第十个源序列中元素的类型。</typeparam>
            <typeparam name="TSource11">第十一个源序列中元素的类型。</typeparam>
            <typeparam name="TSource12">第十二个源序列中元素的类型。</typeparam>
            <typeparam name="TSource13">第十三个源序列中元素的类型。</typeparam>
            <typeparam name="TSource14">第十四个源序列中元素的类型。</typeparam>
            <typeparam name="TSource15">第十五个源序列中元素的类型。</typeparam>
            <typeparam name="TSource16">第十六个源序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`16.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,``0})">
            <summary>当可观察序列具有可用元素并通过调用选择器函数来投射元素时匹配。</summary>
            <typeparam name="TResult">结果序列中元素的类型，由选择器函数返回。</typeparam>
            <param name="selector">将被源序列中的元素调用的选择器。</param>
            <returns>生成预计结果的计划（与其他计划一起）提供给 When 运算符。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Plan`1">
            <summary>表示联接模式的执行计划。</summary>
            <typeparam name="TResult">计划产生的结果类型。</typeparam>
        </member>
        <member name="T:System.Reactive.Subjects.ReplaySubject`1">
            <summary>表示对象既是可观察序列又是观察者。根据缓冲区修剪政策，每个通知都会广播给所有订阅观察者和后续观察者。</summary>
            <typeparam name="T">主题处理的元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Int32,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>初始化一个新的<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例，其具有指定缓冲区大小，窗口和调度程序。</summary>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <param name="scheduler">调用观察者的调度程序。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。-或-<paramref name="window"/> 小于 TimeSpan.Zero。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Int32,System.TimeSpan)">
            <summary>初始化一个新的<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例，其具有指定缓冲区大小和窗口。</summary>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。-或-<paramref name="window"/> 小于 TimeSpan.Zero。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor">
            <summary>初始化一个新的<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Reactive.Concurrency.IScheduler)">
            <summary>初始化一个新的<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例，其具有指定调度程序。</summary>
            <param name="scheduler">调用观察者的调度程序。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>初始化一个新的<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例，其具有指定缓冲区大小和调度程序。</summary>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <param name="scheduler">调用观察者的调度程序。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Int32)">
            <summary>初始化一个新的<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例，其具有指定缓冲区大小。</summary>
            <param name="bufferSize">重放缓冲区的最大元素计数。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>初始化一个新的<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例，其具有指定窗口和调度程序。</summary>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <param name="scheduler">调用观察者的调度程序。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.TimeSpan)">
            <summary>初始化一个新的<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例，其具有指定窗口。</summary>
            <param name="window">重放缓冲区的最大时间长度。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> 小于 TimeSpan.Zero。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.OnNext(`0)">
            <summary>通知所有订阅的观察者和后续观察者有关指定元素到达序列的信息。</summary>
            <param name="value">要发送给所有观察者的值。</param>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.OnError(System.Exception)">
            <summary>通知所有订阅的观察者和后续观察者有关指定的异常。</summary>
            <param name="error">发送给所有观察者的异常情况。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.OnCompleted">
            <summary>将序列已结束情况通知所有订阅的观察者和后续观察者。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.Subscribe(System.IObserver{`0})">
            <summary>订阅该主题的观察者。</summary>
            <param name="observer">观察者订阅该主题。</param>
            <returns>可用于从主题中取消订阅观察者的可处置对象</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.Dispose">
            <summary>释放当前<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/>类实例使用的所有资源并取消订阅所有观察者。</summary>
        </member>
        <member name="P:System.Reactive.Subjects.ReplaySubject`1.HasObservers">
            <summary>指示主题是否有观察者订阅。</summary>
        </member>
        <member name="T:System.Reactive.Threading.Tasks.NamespaceDoc">
            <summary>该 <b>System.Reactive.Threading.Tasks</b> 命名空间包含转换任务和可观察序列的帮助程序。</summary>
        </member>
        <member name="T:System.Reactive.Threading.Tasks.TaskObservableExtensions">
            <summary>提供一组静态方法，用于将任务转换为可观察序列。</summary>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable(System.Threading.Tasks.Task)">
            <summary>返回一个可观察序列，用于指示任务完成时间。</summary>
            <param name="task">要转换为可观察序列的任务。</param>
            <returns>一个可观察序列，在任务完成时生成单位值，或传播任务生成的异常。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="task"/> 为空。</exception>
            <remarks>如果指定的任务对象支持取消，请考虑改用 <see cref="M:System.Reactive.Linq.Observable.FromAsync(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})"/>。</remarks>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})">
            <summary>返回传播任务结果的可观察序列。</summary>
            <typeparam name="TResult">任务产生的结果类型。</typeparam>
            <param name="task">要转换为可观察序列的任务。</param>
            <returns>一个可观察的序列，用于生成任务的结果，或传播任务生成的异常。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="task"/> 为空。</exception>
            <remarks>如果指定的任务对象支持取消，请考虑改用 <see cref="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})"/>。</remarks>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToTask``1(System.IObservable{``0})">
            <summary>返回将接收可观察序列生成的最后一个值或异常的任务。</summary>
            <typeparam name="TResult">源序列中元素的类型。</typeparam>
            <param name="observable">要转换为任务的可观察序列。</param>
            <returns>将接收由可观察序列生成的最后一个元素或异常的任务。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observable"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToTask``1(System.IObservable{``0},System.Object)">
            <summary>返回将接收可观察序列生成的最后一个值或异常的任务。</summary>
            <typeparam name="TResult">源序列中元素的类型。</typeparam>
            <param name="observable">要转换为任务的可观察序列。</param>
            <param name="state">要用作底层任务 AsyncState 的状态。</param>
            <returns>将接收由可观察序列生成的最后一个元素或异常的任务。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observable"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToTask``1(System.IObservable{``0},System.Threading.CancellationToken)">
            <summary>返回将接收可观察序列生成的最后一个值或异常的任务。</summary>
            <typeparam name="TResult">源序列中元素的类型。</typeparam>
            <param name="observable">要转换为任务的可观察序列。</param>
            <param name="cancellationToken">取消令牌可用于取消任务，从而导致取消订阅可观察序列。</param>
            <returns>将接收由可观察序列生成的最后一个元素或异常的任务。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observable"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToTask``1(System.IObservable{``0},System.Threading.CancellationToken,System.Object)">
            <summary>返回将接收可观察序列生成的最后一个值或异常的任务。</summary>
            <typeparam name="TResult">源序列中元素的类型。</typeparam>
            <param name="observable">要转换为任务的可观察序列。</param>
            <param name="cancellationToken">取消令牌可用于取消任务，从而导致取消订阅可观察序列。</param>
            <param name="state">要用作底层任务 AsyncState 的状态。</param>
            <returns>将接收由可观察序列生成的最后一个元素或异常的任务。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observable"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.TimeInterval`1">
            <summary>表示一个值与时间间隔信息相关。时间间隔可以表示数值的生成时间，相对于先前值的间隔，相对于基数的值的传递时间等。</summary>
            <typeparam name="T">使用时间间隔信息注释的数值类型。</typeparam>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.#ctor(`0,System.TimeSpan)">
            <summary>创建一个时间间隔值。</summary>
            <param name="value">使用时间间隔注释的数值。</param>
            <param name="interval">与数值关联的时间间隔。</param>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.Equals(System.Reactive.TimeInterval{`0})">
            <summary>确定当前 TimeInterval&lt;T&gt; 的数值和间隔是否与指定的 TimeInterval&lt;T&gt; 相同。</summary>
            <param name="other">要与当前 TimeInterval&lt;T&gt; 值比较的对象。</param>
            <returns>如果两个 TimeInterval&lt;T&gt; 值具有相同的值和间隔,则为真;否则为假。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.op_Equality(System.Reactive.TimeInterval{`0},System.Reactive.TimeInterval{`0})">
            <summary>确定两个指定的 TimeInterval&lt;T&gt; 值是否具有相同的值和间隔。</summary>
            <param name="first">第一个要比较的 TimeInterval&lt;T&gt; 值。</param>
            <param name="second">第二个要比较的 TimeInterval&lt;T&gt; 值。</param>
            <returns>如果第一个 TimeInterval&lt;T&gt; 的数值和间隔与第二个 TimeInterval&lt;T&gt; 相同，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.op_Inequality(System.Reactive.TimeInterval{`0},System.Reactive.TimeInterval{`0})">
            <summary>确定两个指定的 TimeInterval&lt;T&gt; 的值和间隔是否不相同。</summary>
            <param name="first">第一个要比较的 TimeInterval&lt;T&gt; 值。</param>
            <param name="second">第二个要比较的 TimeInterval&lt;T&gt; 值。</param>
            <returns>如果第一个 TimeInterval&lt;T&gt; 的数值或间隔第二个 TimeInterval&lt;T&gt; 不同，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.Equals(System.Object)">
            <summary>确定指定的 System.Objec 是否与当前 TimeInterval&lt;T&gt; 相等。</summary>
            <param name="obj">要与当前 TimeInterval&lt;T&gt; 进行比较的 System.Object。</param>
            <returns>如果指定的 System.Object 与当前 TimeInterval&lt;T&gt; 相等，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.GetHashCode">
            <summary>返回当前 TimeInterval&lt;T&gt; 值的散列码。</summary>
            <returns>当前 TimeInterval&lt;T&gt; 值的散列码。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.ToString">
            <summary>返回当前 TimeInterval&lt;T&gt; 值的字符串表示。</summary>
            <returns>当前 TimeInterval&lt;T&gt; 值的字符串表示。</returns>
        </member>
        <member name="P:System.Reactive.TimeInterval`1.Value">
            <summary>获取值。</summary>
        </member>
        <member name="P:System.Reactive.TimeInterval`1.Interval">
            <summary>获取间隔。</summary>
        </member>
        <member name="T:System.Reactive.Timestamped`1">
            <summary>表示带有时间戳的值。时间戳通常表示接收值的时间，使用 Ischeduler 时钟获取当前时间。</summary>
            <typeparam name="T">添加时间戳的值的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Timestamped`1.#ctor(`0,System.DateTimeOffset)">
            <summary>创建一个添加时间戳的值。</summary>
            <param name="value">使用时间戳注释的值。</param>
            <param name="timestamp">与值关联的时间戳。</param>
        </member>
        <member name="M:System.Reactive.Timestamped`1.Equals(System.Reactive.Timestamped{`0})">
            <summary>确定当前 Timestamped&lt;T&gt; 的数值和时间戳是否与指定的 Timestamped&lt;T&gt; 相同。</summary>
            <param name="other">要与当前 Timestamped&lt;T&gt; 值比较的对象。</param>
            <returns>如果两个 Timestamped&lt;T&gt; 值具有相同的值和时间戳，则为真;否则为假。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.op_Equality(System.Reactive.Timestamped{`0},System.Reactive.Timestamped{`0})">
            <summary>确定两个指定的 Timestamped&lt;T&gt; 值是否具有相同的值和时间戳。</summary>
            <param name="first">第一个要比较的 Timestamped&lt;T&gt; 值。</param>
            <param name="second">第二个要比较的 Timestamped&lt;T&gt; 值。</param>
            <returns>如果第一个 Timestamped&lt;T&gt; 的数值和时间戳与第二个 Timestamped&lt;T&gt; 相同，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.op_Inequality(System.Reactive.Timestamped{`0},System.Reactive.Timestamped{`0})">
            <summary>确定两个指定 Timestamped&lt;T&gt; 的值和时间戳是否不同。</summary>
            <param name="first">第一个要比较的 Timestamped&lt;T&gt; 值。</param>
            <param name="second">第二个要比较的 Timestamped&lt;T&gt; 值。</param>
            <returns>如果第一个 Timestamped&lt;T&gt; 的数值或时间戳与第二个 Timestamped&lt;T&gt; 不同，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.Equals(System.Object)">
            <summary>确定指定的 System.Object 是否与当前 Timestamped&lt;T&gt; 相等。</summary>
            <param name="obj">要与当前 Timestamped&lt;T&gt; 进行比较的 System.Object。</param>
            <returns>如果指定的 System.Object 与当前 Timestamped&lt;T&gt; 相等，则为真；否则为假。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.GetHashCode">
            <summary>返回当前 Timestamped&lt;T&gt; 值的散列码。</summary>
            <returns>当前 Timestamped&lt;T&gt; 值的散列码。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.ToString">
            <summary>返回当前 Timestamped&lt;T&gt; 值的字符串表示。</summary>
            <returns>当前 Timestamped&lt;T&gt; 值的字符串表示。</returns>
        </member>
        <member name="P:System.Reactive.Timestamped`1.Value">
            <summary>获取值。</summary>
        </member>
        <member name="P:System.Reactive.Timestamped`1.Timestamp">
            <summary>获取时间戳。</summary>
        </member>
        <member name="T:System.Reactive.Timestamped">
            <summary>一个辅助类，其中包含用于创建 Timestamped&lt;T&gt; 类实例的工厂方法。</summary>
        </member>
        <member name="M:System.Reactive.Timestamped.Create``1(``0,System.DateTimeOffset)">
            <summary>创建 Timestamped&lt;T&gt; 的实例。这是语法糖，它使用类型推断来避免在构造函数调用中指定类型，这在使用匿名类型时非常有用。</summary>
            <param name="value">使用时间戳注释的值。</param>
            <param name="timestamp">与值关联的时间戳。</param>
            <returns>创建新的带时间戳的值。</returns>
        </member>
        <member name="T:System.Reactive.Strings_Linq">
            <summary>强类型资源类，用于查找本地化字符串等。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.ResourceManager">
            <summary>返回该类使用的缓存 ResourceManager 实例。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.Culture">
            <summary>使用此强类型资源类覆盖当前线程的 CurrentUICulture 属性以查找所有资源。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.COULD_NOT_FIND_INSTANCE_EVENT">
            <summary>查找类似于 Could not find event ‘{0}’ on object of type ‘{1}’.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.COULD_NOT_FIND_STATIC_EVENT">
            <summary>查找类似于 Could not find event ‘{0}’ on type ‘{1}’.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_ADD_METHOD_SHOULD_TAKE_ONE_PARAMETER">
            <summary>查找类似于 Add method should take 1 parameter.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_ARGS_NOT_ASSIGNABLE">
            <summary>查找类似于 The second parameter of the event delegate must be assignable to ‘{0}’..的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_MISSING_ADD_METHOD">
            <summary>查找类似于 Event 的本地化字符串缺少 add 方法..</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_MISSING_REMOVE_METHOD">
            <summary>查找类似于 Event 的本地化字符串缺少 remove 方法..</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_MUST_RETURN_VOID">
            <summary>查找类似于 The event delegate must have a void return type.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_PATTERN_REQUIRES_TWO_PARAMETERS">
            <summary>查找类似于 The event delegate must have exactly two parameters.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_REMOVE_METHOD_SHOULD_TAKE_ONE_PARAMETER">
            <summary>查找类似于 Remove method should take 1 parameter.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_SENDER_NOT_ASSIGNABLE">
            <summary>查找类似于 The first parameter of the event delegate must be assignable to ‘{0}’..的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_WINRT_REMOVE_METHOD_SHOULD_TAKE_ERT">
            <summary>查找类似于 Remove method of a WinRT event should take an EventRegistrationToken..的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.MORE_THAN_ONE_ELEMENT">
            <summary>查找类似于 Sequence contains more than one element.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.MORE_THAN_ONE_MATCHING_ELEMENT">
            <summary>查找类似于 Sequence contains more than one matching element.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.NO_ELEMENTS">
            <summary>查找类似于 Sequence contains no elements.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.NO_MATCHING_ELEMENTS">
            <summary>查找类似于 Sequence contains no matching element.. 的本地化字符串</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.CANT_ADVANCE_WHILE_RUNNING">
            <summary>查找类似于 {0} cannot be called when the scheduler is already running. 的本地化字符串尝试使用睡眠而不是..</summary>
        </member>
    </members>
</doc>