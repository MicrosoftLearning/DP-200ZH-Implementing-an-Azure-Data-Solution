<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>System.Reactive.Core</name>
    </assembly>
    <members>
        <member name="T:System.Reactive.PlatformServices.NamespaceDoc">
            <summary>该 <b>System.Reactive.PlatformServices</b> 命名空间包含 Reactive Extensions 的运行时基础结构使用的接口和类。不打算直接从用户代码中使用它们，并且在将来的产品版本中它们可能有所变化。</summary>
        </member>
        <member name="T:System.ObservableExtensions">
            <summary>提供一组静态方法，用于将委托订阅至可观察项。</summary>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0})">
            <summary>订阅至可观察序列而不指定任何处理程序。此方法仅可用于评估其可观察序列的副作用。</summary>
            <typeparam name="T">源序列中元素的类型。 </typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <returns>用于取消订阅可观察序列的 IDisposable 对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0})">
            <summary>为可观察序列订阅元素处理程序。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <returns>用于取消订阅可观察序列的 IDisposable 对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0},System.Action{System.Exception})">
            <summary>为可观察序列订阅元素处理程序和异常处理程序。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onError">在可观察序列异常终止时调用的操作。</param>
            <returns>用于取消订阅可观察序列的 IDisposable 对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onError"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0},System.Action)">
            <summary>为可观察序列订阅元素处理程序和完成处理程序。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onCompleted">在可观察序列正常终止时调用的动作。</param>
            <returns>用于取消订阅可观察序列的 IDisposable 对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0},System.Action{System.Exception},System.Action)">
            <summary>为可观察序列订阅元素处理程序、异常处理程序和完成处理程序。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onError">在可观察序列异常终止时调用的动作。</param>
            <param name="onCompleted">在可观察序列正常终止时调用的动作。</param>
            <returns>用于取消订阅可观察序列的 IDisposable 对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onError"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.IObserver{``0},System.Threading.CancellationToken)">
            <summary>使用 CancellationToken 为可观察序列订阅观察者以支持取消订阅。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="observer">观察者订阅序列。</param>
            <param name="token">可以发信号来从源序列取消订阅的 CancellationToken。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="observer"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Threading.CancellationToken)">
            <summary>订阅可观察序列而不指定任何处理程序，使用CancellationToken来支持取消订阅。此方法仅可用于评估其可观察序列的副作用。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="token">可以发信号来从源序列取消订阅的 CancellationToken。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0},System.Threading.CancellationToken)">
            <summary>为可观察序列订阅元素处理程序，使用CancellationToken以支持取消订阅。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="token">可以发信号来从源序列取消订阅的 CancellationToken。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0},System.Action{System.Exception},System.Threading.CancellationToken)">
            <summary>为可观察序列订阅元素处理程序和异常处理程序，使用CancellationToken以支持取消订阅。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onError">在可观察序列异常终止时调用的动作。</param>
            <param name="token">可以发信号来从源序列取消订阅的 CancellationToken。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onError"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0},System.Action,System.Threading.CancellationToken)">
            <summary>为可观察序列订阅元素处理程序和完成处理程序，使用CancellationToken以支持取消订阅。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onCompleted">在可观察序列正常终止时调用的动作。</param>
            <param name="token">可以发信号来从源序列取消订阅的 CancellationToken。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0},System.Action{System.Exception},System.Action,System.Threading.CancellationToken)">
            <summary>为可观察序列订阅元素处理程序、异常处理程序和完成处理程序，使用CancellationToken以支持取消订阅。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="onNext">调用可观察序列中每个元素的操作。</param>
            <param name="onError">在可观察序列异常终止时调用的动作。</param>
            <param name="onCompleted">在可观察序列正常终止时调用的动作。</param>
            <param name="token">可以发信号来从源序列取消订阅的 CancellationToken。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="onNext"/>或<paramref name="onError"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.ObservableExtensions.SubscribeSafe``1(System.IObservable{``0},System.IObserver{``0})">
            <summary>订阅指定的源，在将 Subscribe 方法调用到观察者的 OnError 通道期间重新路由同步异常。当编写查询运算符时通常使用此方法。</summary>
            <typeparam name="T">源序列中元素的类型。</typeparam>
            <param name="source">待订阅的可观察序列。</param>
            <param name="observer">将传递给可观察序列并用于异常传播的观察者。</param>
            <returns>用于取消订阅可观察序列的 IDisposable 对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="observer"/>为空。</exception>
        </member>
        <member name="T:System.Reactive.Observer">
            <summary>提供一组用于创建观察者的静态方法。</summary>
        </member>
        <member name="M:System.Reactive.Observer.ToObserver``1(System.Action{System.Reactive.Notification{``0}})">
            <summary>创建来自观察者的通知回调。</summary>
            <typeparam name="T">观察者收到的元素类型。</typeparam>
            <param name="handler">处理通知的操作。</param>
            <returns>使用与接收的每条消息对应的通知来调用指定处理程序的观察者对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="handler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.ToNotifier``1(System.IObserver{``0})">
            <summary>创建来自观察者的通知回调。</summary>
            <typeparam name="T">观察者收到的元素类型。</typeparam>
            <param name="observer">观察者对象。</param>
            <returns>将输入通知输送给基础观察者的操作。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.Create``1(System.Action{``0})">
            <summary>从指定的 OnNext 操作创建观察者。</summary>
            <typeparam name="T">观察者收到的元素类型。</typeparam>
            <param name="onNext">观察者的 OnNext 操作实现。</param>
            <returns>使用给定操作实现的观察者对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="onNext"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.Create``1(System.Action{``0},System.Action{System.Exception})">
            <summary>从指定的 OnNext 和 OnError 操作创建观察者。</summary>
            <typeparam name="T">观察者收到的元素类型。</typeparam>
            <param name="onNext">观察者的 OnNext 操作实现。</param>
            <param name="onError">观察者的 OnError 操作实现。</param>
            <returns>使用给定操作实现的观察者对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="onNext"/> 或<paramref name="onError"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.Create``1(System.Action{``0},System.Action)">
            <summary>从指定的 OnNext 和 OnCompleted 操作创建观察者。</summary>
            <typeparam name="T">观察者收到的元素类型。</typeparam>
            <param name="onNext">观察者的 OnNext 操作实现。</param>
            <param name="onCompleted">观察者的 OnCompleted 操作实现。</param>
            <returns>使用给定操作实现的观察者对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="onNext"/> 或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.Create``1(System.Action{``0},System.Action{System.Exception},System.Action)">
            <summary>从指定的OnNext、OnError和OnCompleted操作创建观察者。</summary>
            <typeparam name="T">观察者收到的元素类型。</typeparam>
            <param name="onNext">观察者的 OnNext 操作实现。</param>
            <param name="onError">观察者的 OnError 操作实现。</param>
            <param name="onCompleted">观察者的 OnCompleted 操作实现。</param>
            <returns>使用给定操作实现的观察者对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="onNext"/> 或<paramref name="onError"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.AsObserver``1(System.IObserver{``0})">
            <summary>隐藏观察者的身份。</summary>
            <typeparam name="T">源观察者接收的元素类型。</typeparam>
            <param name="observer">隐藏身份的观察者。</param>
            <returns>隐藏指定观察者身份的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.Checked``1(System.IObserver{``0})">
            <summary>检查对观察者的访问是否存在语法违规。这包括检查多个OnError或OnCompleted调用，以及任何观察者方法的重入。如果检测到违规，则从违规的观察者方法调用中删除InvalidOperationException。</summary>
            <typeparam name="T">源观察者接收的元素类型。</typeparam>
            <param name="observer">应检查其回调调用是否存在语法违规的观察者。</param>
            <returns>按照观察者语法检查回调调用的观察者，如果检查通过，则将这些调用转发至指定的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.Synchronize``1(System.IObserver{``0})">
            <summary>同步对观察者的访问，这样无法从多个线程同时调用其回调方法。当协调对观察者的访问时，此重载非常有用。注意仍可以相同线程上进行重入观察者回调。</summary>
            <typeparam name="T">源观察者接收的元素类型。</typeparam>
            <param name="observer">应同步其回调的观察者。</param>
            <returns>以同步的方式向指定的观察者提供回调的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
            <remarks>因为<see cref="T:System.Threading.Monitor">监控</see>用于执行同步，不存在防止同一线程的重入的保护。因此，仍可能出现重叠的观察者回调，按照观察者语法，这是无效行为。为了防止这种行为，请使用 <see cref="M:System.Reactive.Observer.Synchronize``1(System.IObserver{``0},System.Boolean)"/> 重载，将 true 传递至第二个参数。</remarks>
        </member>
        <member name="M:System.Reactive.Observer.Synchronize``1(System.IObserver{``0},System.Boolean)">
            <summary>同步对观察者的访问，这样无法同时调用其回调方法。当协调对观察者的访问时，此重载非常有用。该 <paramref name="preventReentrancy"/> 参数配置用于同步的锁的类型。</summary>
            <typeparam name="T">源观察者接收的元素类型。</typeparam>
            <param name="observer">应同步其回调的观察者。</param>
            <param name="preventReentrancy">如果设置为 true，则重入观察者回调将排队并以顺序方式传递至观察者。</param>
            <returns>以同步的方式向指定的观察者提供回调的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
            <remarks>当 <paramref name="preventReentrancy"/> 参数设置为false 时，<see cref="M:System.Reactive.Observer.Synchronize``1(System.IObserver{``0})"/>对于使用<see cref="T:System.Threading.Monitor">监控</see>进行同步的重载，行为是相同的。当 <paramref name="preventReentrancy"/> 参数设置为 true 时，如果进行重入调用，则使用 <see cref="T:System.Reactive.Concurrency.AsyncLock"/> 对指定观察者的调用进行排队</remarks>
        </member>
        <member name="M:System.Reactive.Observer.Synchronize``1(System.IObserver{``0},System.Object)">
            <summary>同步对观察者的访问，这样多个线程无法同时调用其回调方法，使用指定的门对象来应用基于<see cref="T:System.Threading.Monitor">监控</see>的锁。当协调通过在公共门对象上进行同步来访问共享状态的多个观察者时，此重载非常有用。注意仍可以相同线程上进行重入观察者回调。</summary>
            <typeparam name="T">源观察者接收的元素类型。</typeparam>
            <param name="observer">应同步其回调的观察者。</param>
            <param name="gate">门对象用于同步每个观察者调用。</param>
            <returns>以同步的方式向指定的观察者提供回调的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 或<paramref name="gate"/>为空。</exception>
            <remarks>因为<see cref="T:System.Threading.Monitor">监控</see>用于执行同步，不存在防止同一线程的重入的保护。因此，仍可能出现重叠的观察者回调，按照观察者语法，这是无效行为。为了防止这种行为，请使用 <see cref="M:System.Reactive.Observer.Synchronize``1(System.IObserver{``0},System.Reactive.Concurrency.AsyncLock)"/> 重载。</remarks>
        </member>
        <member name="M:System.Reactive.Observer.Synchronize``1(System.IObserver{``0},System.Reactive.Concurrency.AsyncLock)">
            <summary>同步对观察者的访问，这样无法同时调用其回调方法，使用指定的异步锁来防止并发和重入访问。当协调通过同步公共异步锁来访问共享状态的多个观察者时，此重载非常有用。</summary>
            <typeparam name="T">源观察者接收的元素类型。</typeparam>
            <param name="observer">应同步其回调的观察者。</param>
            <param name="asyncLock">门对象用于同步每个观察者调用。</param>
            <returns>以同步的方式向指定的观察者提供回调的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 或<paramref name="asyncLock"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.NotifyOn``1(System.IObserver{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>在给定的计划程序上规划观察者调用方法。</summary>
            <typeparam name="T">源观察者接收的元素类型。</typeparam>
            <param name="observer">待为其规划消息的观察者。</param>
            <param name="scheduler">用于规划观察者消息的计划程序。</param>
            <returns>在给定计划程序上规划消息的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.NotifyOn``1(System.IObserver{``0},System.Threading.SynchronizationContext)">
            <summary>在给定的同步上下文上规划观察者调用的方法。</summary>
            <typeparam name="T">源观察者接收的元素类型。</typeparam>
            <param name="observer">待为其规划消息的观察者。</param>
            <param name="context">用于规划观察者消息的同步上下文。</param>
            <returns>在给定的同步上下文中规划其消息的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 或<paramref name="context"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.ToProgress``1(System.IObserver{``0})">
            <summary>将观察者转换为进度对象。</summary>
            <typeparam name="T">源观察者接收的进度对象的类型。</typeparam>
            <param name="observer">待转换的观察者。</param>
            <returns>其报告消息对应于观察者的 OnNext 消息的进度对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.ToProgress``1(System.IObserver{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>使用指定的计划程序来调用进度报告方法，将观察者转换为进度对象。</summary>
            <typeparam name="T">源观察者接收的进度对象的类型。</typeparam>
            <param name="observer">待转换的观察者。</param>
            <param name="scheduler">用于报告进度的计划程序。</param>
            <returns>其报告消息对应于观察者的 OnNext 消息的进度对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Observer.ToObserver``1(System.IProgress{``0})">
            <summary>将进度对象转换为观察者。</summary>
            <typeparam name="T">进度报告器接收的进度对象的类型。</typeparam>
            <param name="progress">待转换的进度对象。</param>
            <returns>其 OnNext 消息对应于进度对象的报告消息的观察者。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="progress"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.AnonymousObservable`1">
            <summary>用于创建 Iobservable 的类&lt;T&gt;来自基于委托的订阅方法实现的实例。</summary>
            <typeparam name="T">序列中元素的类型。</typeparam>
        </member>
        <member name="T:System.Reactive.ObservableBase`1">
            <summary>用于 Iobservable 实现的抽象基类&lt;T&gt;接口。</summary>
            <remarks>如果您不需要命名类型来创建可观察序列（即：您更需要实例而非可重用类型），则使用Observable.Create方法创建带指定订阅行为的可观察序列。</remarks>
            <typeparam name="T">序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.ObservableBase`1.Subscribe(System.IObserver{`0})">
            <summary>将给定的观察者订阅至可观察序列。</summary>
            <param name="observer">将从可观察序列接收通知的观察者。</param>
            <returns>显示观察者对可观察序列的订阅情况的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.ObservableBase`1.SubscribeCore(System.IObserver{`0})">
            <summary>实现具有可观察序列的核心订阅逻辑的此方法。</summary>
            <param name="observer">向其发送通知的观察者。</param>
            <returns>显示观察者对可观察序列的订阅情况的一次性对象。</returns>
        </member>
        <member name="M:System.Reactive.AnonymousObservable`1.#ctor(System.Func{System.IObserver{`0},System.IDisposable})">
            <summary>从指定的订阅函数创建可观察的序列对象。</summary>
            <param name="subscribe">订阅方法实现。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribe"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.AnonymousObservable`1.SubscribeCore(System.IObserver{`0})">
            <summary>调用提供至构造函数的订阅函数。</summary>
            <param name="observer">向其发送通知的观察者。</param>
            <returns>显示观察者对可观察序列的订阅情况的一次性对象。</returns>
        </member>
        <member name="T:System.Reactive.AnonymousObserver`1">
            <summary>用于创建 Iobserver 的类&lt;T&gt;来自基于委托的 On * 方法实现的实例。</summary>
            <typeparam name="T">序列中元素的类型。</typeparam>
        </member>
        <member name="T:System.Reactive.ObserverBase`1">
            <summary>用于 IObserver 实现的抽象基类&lt;T&gt;接口。</summary>
            <remarks>此基类强制执行观察者的语法，其中 OnError 和 OnCompleted 是终端消息。</remarks>
            <typeparam name="T">序列中元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.#ctor">
            <summary>创建处于非停止状态的新观察者。</summary>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.OnNext(`0)">
            <summary>向观察者通知序列中的新元素。</summary>
            <param name="value">序列中的下一个元素。</param>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.OnNextCore(`0)">
            <summary>实现此方法以响应序列中新元素的接收。</summary>
            <param name="value">序列中的下一个元素。</param>
            <remarks>只有在观察者尚未停止时才调用此方法。</remarks>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.OnError(System.Exception)">
            <summary>向观察者通知发生了异常。</summary>
            <param name="error">发生的错误。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.OnErrorCore(System.Exception)">
            <summary>实现此方法以响应异常的发生。</summary>
            <param name="error">发生的错误。</param>
            <remarks>只有在观察者尚未停止时才调用此方法，此方法会导致观察者停止。</remarks>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.OnCompleted">
            <summary>向观察者通知序列的结束。</summary>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.OnCompletedCore">
            <summary>实现此方法以响应序列的结束。</summary>
            <remarks>只有在观察者尚未停止时才调用此方法，此方法会导致观察者停止。</remarks>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.Dispose">
            <summary>处理观察者，使其转换到停止状态。</summary>
        </member>
        <member name="M:System.Reactive.ObserverBase`1.Dispose(System.Boolean)">
            <summary>IDisposable 的核心实现。</summary>
            <param name="disposing">如果 Dispose 调用由 IDisposable.Dispose 方法触发，则为 true;否则为 false。如果它由终结器触发，则为 false。</param>
        </member>
        <member name="M:System.Reactive.AnonymousObserver`1.#ctor(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>从指定的OnNext、OnError和OnCompleted操作创建观察者。</summary>
            <param name="onNext">观察者的 OnNext 操作实现。</param>
            <param name="onError">观察者的 OnError 操作实现。</param>
            <param name="onCompleted">观察者的 OnCompleted 操作实现。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="onNext"/> 或<paramref name="onError"/>或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.AnonymousObserver`1.#ctor(System.Action{`0})">
            <summary>从指定的 OnNext 操作创建观察者。</summary>
            <param name="onNext">观察者的 OnNext 操作实现。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="onNext"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.AnonymousObserver`1.#ctor(System.Action{`0},System.Action{System.Exception})">
            <summary>从指定的 OnNext 和 OnError 操作创建观察者。</summary>
            <param name="onNext">观察者的 OnNext 操作实现。</param>
            <param name="onError">观察者的 OnError 操作实现。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="onNext"/> 或<paramref name="onError"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.AnonymousObserver`1.#ctor(System.Action{`0},System.Action)">
            <summary>从指定的 OnNext 和 OnCompleted 操作创建观察者。</summary>
            <param name="onNext">观察者的 OnNext 操作实现。</param>
            <param name="onCompleted">观察者的 OnCompleted 操作实现。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="onNext"/> 或<paramref name="onCompleted"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.AnonymousObserver`1.OnNextCore(`0)">
            <summary>调用 onNext 操作。</summary>
            <param name="value">序列中的下一个元素。</param>
        </member>
        <member name="M:System.Reactive.AnonymousObserver`1.OnErrorCore(System.Exception)">
            <summary>调用 onError 操作。</summary>
            <param name="error">发生的错误。</param>
        </member>
        <member name="M:System.Reactive.AnonymousObserver`1.OnCompletedCore">
            <summary>调用 onCompleted 操作。</summary>
        </member>
        <member name="T:System.Reactive.AnonymousSafeObserver`1">
            <summary>该类将 ObserverBase、AnonymousObserver 和 SafeObserver 中的逻辑融合到一个类中。当需要保护观察者时，SafeObserver.Create 可以在检测到其输入时创建的此类型的实例是AnonymousObserver，最终用户在使用接受On *处理程序的委托的订阅扩展方法时通常使用该实例。通过融合，我们使调用堆栈深度更短，这有助于调试和一些性能。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.AsyncLock">
            <summary>异步锁。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.AsyncLock.Wait(System.Action)">
            <summary>对待执行操作进行排队。如果调用方获取锁并成为所有者，则该队列得以处理。如果已拥有锁，则操作会被排队并由所有者处理。</summary>
            <param name="action">对待执行操作进行排队。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.AsyncLock.Dispose">
            <summary>清除队列中的工作项并删除正在排队的其他工作。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.ConcurrencyAbstractionLayer">
            <summary>（基础结构）并发抽象层。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.ConcurrencyAbstractionLayer.Current">
            <summary>获取当前CAL。如果未设置CAL，则其被初始化为默认值。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.IConcurrencyAbstractionLayer">
            <summary>（基础结构）并发抽象层接口。</summary>
            <remarks>此类型由Rx基础结构使用，不适用于公共使用或实现。不保证类型功能的前向兼容性及其用途。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.IConcurrencyAbstractionLayer.StartTimer(System.Action{System.Object},System.Object,System.TimeSpan)">
            <summary>对在指定的相对时间执行的方法进行排队。</summary>
            <param name="action">待执行的方法。</param>
            <param name="state">待传递至方法的状态。</param>
            <param name="dueTime">待执行方法的时间</param>
            <returns>可用于停止计时器的一次性对象。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.IConcurrencyAbstractionLayer.StartPeriodicTimer(System.Action,System.TimeSpan)">
            <summary>基于指定的时间段对定期执行的方法进行排队。</summary>
            <param name="action">执行方法;应对于可重入性是安全的。</param>
            <param name="period">定期运行方法的时间段。</param>
            <returns>可用于停止计时器的一次性对象。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.IConcurrencyAbstractionLayer.QueueUserWorkItem(System.Action{System.Object},System.Object)">
            <summary>对待执行的方法进行排队。</summary>
            <param name="action">待执行的方法。</param>
            <param name="state">待传递至方法的状态。</param>
            <returns>可用于取消排队方法的一次性对象。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.IConcurrencyAbstractionLayer.Sleep(System.TimeSpan)">
            <summary>阻止睡眠操作。</summary>
            <param name="timeout">进行睡眠的时间。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.IConcurrencyAbstractionLayer.StartStopwatch">
            <summary>启动新的秒表对象。</summary>
            <returns>新的秒表对象；在请求时启动。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.IConcurrencyAbstractionLayer.StartThread(System.Action{System.Object},System.Object)">
            <summary>启动新的长期运行线程。</summary>
            <param name="action">待执行的方法。</param>
            <param name="state">待传递至方法的状态。</param>
        </member>
        <member name="P:System.Reactive.Concurrency.IConcurrencyAbstractionLayer.SupportsLongRunning">
            <summary>了解是否支持长时间运行的计划。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.Scheduler">
            <summary>提供一组静态属性以访问常用的计划程序。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.DisableOptimizations(System.Reactive.Concurrency.IScheduler)">
            <summary>返回代表原始计划程序的计划程序，而不进行任何基于接口的优化（例如：长时间运行的计划）。</summary>
            <param name="scheduler">用于禁用所有优化的计划程序。</param>
            <returns>原始计划程序的代理，但未启用任何优化。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.DisableOptimizations(System.Reactive.Concurrency.IScheduler,System.Type[])">
            <summary>返回代表原始计划程序的计划程序，而不指定一组基于接口的优化（例如：长时间运行的计划）。</summary>
            <param name="scheduler">用于禁用指定的优化的计划程序。</param>
            <param name="optimizationInterfaces">必须禁用的优化接口的类型。</param>
            <returns>原始计划程序的代理，但未启用指定的优化。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="optimizationInterfaces"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Catch``1(System.Reactive.Concurrency.IScheduler,System.Func{``0,System.Boolean})">
            <summary>返回包装原始计划程序的计划程序，为计划的操作添加异常处理。</summary>
            <typeparam name="TException">待检查的例外的类型。</typeparam>
            <param name="scheduler">用于为其应用异常过滤器的计划程序。</param>
            <param name="handler">如果发现异常，则运行处理程序。如果处理程序返回 false，则重新抛出异常。</param>
            <returns>原始计划程序周围的包装器，强制执行异常处理。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="handler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.SchedulePeriodic``1(System.Reactive.Concurrency.IScheduler,``0,System.TimeSpan,System.Func{``0,``0})">
            <summary>通过动态发现计划程序的功能来规划定期工作。如果计划程序支持定期计划，则该请求将被转发到定期计划实现。如果计划程序提供秒表功能，则将使用带秒表的递归计划来模拟周期性任务，以纠正时间滑动。否则，将使用递归计划模拟周期性任务。</summary>
            <typeparam name="TState">传递至计划操作的状态类型。</typeparam>
            <param name="scheduler">运行定期工作的计划程序。</param>
            <param name="state">在第一次迭代时将初始状态传递至操作。</param>
            <param name="period">定期运行工作的时间段。</param>
            <param name="action">可能更新状态的待执行的操作。</param>
            <returns>用于取消计划的反复操作的一次性对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.SchedulePeriodic``1(System.Reactive.Concurrency.IScheduler,``0,System.TimeSpan,System.Action{``0})">
            <summary>通过动态发现计划程序的功能来规划定期工作。如果计划程序支持定期计划，则该请求将被转发到定期计划实现。如果计划程序提供秒表功能，则将使用带秒表的递归计划来模拟周期性任务，以纠正时间滑动。否则，将使用递归计划模拟周期性任务。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">操作调度程序。</param>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="period">定期运行工作的时间段。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划的反复操作的一次性对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.SchedulePeriodic(System.Reactive.Concurrency.IScheduler,System.TimeSpan,System.Action)">
            <summary>通过动态发现计划程序的功能来规划定期工作。如果计划程序支持定期计划，则该请求将被转发到定期计划实现。如果计划程序提供秒表功能，则将使用带秒表的递归计划来模拟周期性任务，以纠正时间滑动。否则，将使用递归计划模拟周期性任务。</summary>
            <param name="scheduler">操作调度程序。</param>
            <param name="period">定期运行工作的时间段。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划的反复操作的一次性对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.StartStopwatch(System.Reactive.Concurrency.IScheduler)">
            <summary>通过动态发现计划程序的功能来启动新的秒表对象。如果计划程序提供秒表功能，则请求将转发到秒表提供程序实现。否则，将使用计划程序的绝对时间概念模拟秒表。</summary>
            <param name="scheduler">用于获取秒表的计划程序。</param>
            <returns>新的秒表对象；在请求时启动。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
            <remarks>生成的秒表对象可能具有非单调行为。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.AsLongRunning(System.Reactive.Concurrency.IScheduler)">
            <summary>返回指定计划程序的 ISchedulerLongRunning 实现，如果没有此类实现可用，则返回 null。</summary>
            <param name="scheduler">用于获取 ISchedulerLongRunning 实现的计划程序。</param>
            <returns>计划程序的 ISchedulerLongRunning 实现（如可用）;否则为null。</returns>
            <remarks>此帮助程序方法可供查询运算符作者，以便使用所需的 IServiceProvider 模式发现计划程序服务，该模式允许拦截或重新定义计划程序服务。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.AsStopwatchProvider(System.Reactive.Concurrency.IScheduler)">
            <summary>返回指定计划程序的 IStopwatchProvider 实现，如果没有此类实现可用，则返回 null。</summary>
            <param name="scheduler">用于获取 IStopwatchProvider 实现的计划程序。</param>
            <returns>计划程序的 IStopwatchProvider 实现（如可用）;否则为 null。</returns>
            <remarks>
            <para>此帮助程序方法可供查询运算符作者，以便使用所需的 IServiceProvider 模式发现计划程序服务，该模式允许拦截或重新定义计划程序服务。</para>
            <para>如果需要秒表，<see cref="M:System.Reactive.Concurrency.Scheduler.StartStopwatch(System.Reactive.Concurrency.IScheduler)"/>考虑使用，但可以使用基于计划程序时钟的模拟秒表。建议使用此方法来最大限度地使用秒表提供程序计划程序服务，如果未找到此工具，则调用方将回退到不使用秒表。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.AsPeriodic(System.Reactive.Concurrency.IScheduler)">
            <summary>返回指定计划程序的 IStopwatchProvider 实现，如果没有此类实现可用，则返回 null。</summary>
            <param name="scheduler">用于获取 IStopwatchProvider 实现的计划程序。</param>
            <returns>计划程序的 IStopwatchProvider 实现（如可用）;否则为 null。</returns>
            <remarks>
            <para>此帮助程序方法可供查询运算符作者，以便使用所需的 IServiceProvider 模式发现计划程序服务，该模式允许拦截或重新定义计划程序服务。</para>
            <para>在需要定期计划的情况下，考虑使用 Ischeduler 的 Scheduler.SchedulePeriodic 扩展方法，并且需要使用其他计划程序服务来模拟周期性行为。建议使用此方法来最大限度地使用定期计划服务，如果未找到此工具，则调用方将回退到不使用定期计划。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Yield(System.Reactive.Concurrency.IScheduler)">
            <summary>将计划程序上当前工作项的执行移至计划程序上的另一个工作项。调用方应等待调用Yield的结果来安排当前工作项的剩余部分（称为延续）。</summary>
            <param name="scheduler">用于完成工作的计划程序。</param>
            <returns>需要等待，用于计划延续的计划程序操作对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Yield(System.Reactive.Concurrency.IScheduler,System.Threading.CancellationToken)">
            <summary>将计划程序上当前工作项的执行移至计划程序上的另一个工作项。调用方应等待调用Yield的结果来安排当前工作项的剩余部分（称为延续）。</summary>
            <param name="scheduler">用于完成工作的计划程序。</param>
            <param name="cancellationToken">取消令牌来取消延续的运行。</param>
            <returns>需要等待，用于计划延续的计划程序操作对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Sleep(System.Reactive.Concurrency.IScheduler,System.TimeSpan)">
            <summary>在指定的持续时间中，暂停在计划程序上执行当前工作项。在指定的持续时间中，调用方应等待调用Sleep的结果来安排当前工作项的剩余部分（称为延续）。</summary>
            <param name="scheduler">用于完成工作的计划程序。</param>
            <param name="dueTime">应运行延续的时间。</param>
            <returns>需要等待，用于计划延续的计划程序操作对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Sleep(System.Reactive.Concurrency.IScheduler,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>在指定的持续时间中，暂停在计划程序上执行当前工作项。在指定的持续时间中，调用方应等待调用Sleep的结果来安排当前工作项的剩余部分（称为延续）。</summary>
            <param name="scheduler">用于完成工作的计划程序。</param>
            <param name="dueTime">应运行延续的时间。</param>
            <param name="cancellationToken">取消令牌来取消延续的运行。</param>
            <returns>需要等待，用于计划延续的计划程序操作对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Sleep(System.Reactive.Concurrency.IScheduler,System.DateTimeOffset)">
            <summary>在指定的持续时间中，暂停在计划程序上执行当前工作项。在指定的持续时间中，调用方应等待调用Sleep的结果来安排当前工作项的剩余部分（称为延续）。</summary>
            <param name="scheduler">用于完成工作的计划程序。</param>
            <param name="dueTime">应运行延续的时间。</param>
            <returns>需要等待，用于计划延续的计划程序操作对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Sleep(System.Reactive.Concurrency.IScheduler,System.DateTimeOffset,System.Threading.CancellationToken)">
            <summary>在指定的持续时间中，暂停在计划程序上执行当前工作项。在指定的持续时间中，调用方应等待调用Sleep的结果来安排当前工作项的剩余部分（称为延续）。</summary>
            <param name="scheduler">用于完成工作的计划程序。</param>
            <param name="dueTime">应运行延续的时间。</param>
            <param name="cancellationToken">取消令牌来取消延续的运行。</param>
            <returns>需要等待，用于计划延续的计划程序操作对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync``1(System.Reactive.Concurrency.IScheduler,``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="state">待传递至异步方法的状态。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync``1(System.Reactive.Concurrency.IScheduler,``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="state">待传递至异步方法的状态。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync(System.Reactive.Concurrency.IScheduler,System.Func{System.Reactive.Concurrency.IScheduler,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync(System.Reactive.Concurrency.IScheduler,System.Func{System.Reactive.Concurrency.IScheduler,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync``1(System.Reactive.Concurrency.IScheduler,``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="state">待传递至异步方法的状态。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync``1(System.Reactive.Concurrency.IScheduler,``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="state">待传递至异步方法的状态。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync(System.Reactive.Concurrency.IScheduler,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync(System.Reactive.Concurrency.IScheduler,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync``1(System.Reactive.Concurrency.IScheduler,``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="state">待传递至异步方法的状态。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync``1(System.Reactive.Concurrency.IScheduler,``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="state">待传递至异步方法的状态。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync(System.Reactive.Concurrency.IScheduler,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleAsync(System.Reactive.Concurrency.IScheduler,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>使用异步方法来计划工作，允许以命令式编码风格进行协作计划。</summary>
            <param name="scheduler">用于计划工作的计划程序。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <param name="action">运行工作的异步方法，使用Yield和Sleep操作进行协作计划并注入取消点。</param>
            <returns>允许取消合作取消点上的未完成工作或通过传递给异步方法的取消令牌来取消未完成工作的一次性对象。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Normalize(System.TimeSpan)">
            <summary>将指定的 TimeSpan 值标准化为正值。</summary>
            <param name="timeSpan">待标准化的 TimeSpan 值。</param>
            <returns>指定的 TimeSpan 值是否为零或正;如果为否，TimeSpan.Zero。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule(System.Reactive.Concurrency.IScheduler,System.Action{System.Action})">
            <summary>计划待递归执行的操作。</summary>
            <param name="scheduler">用于执行递归操作的计划程序。</param>
            <param name="action">待以递归方式执行的操作。传递至操作的参数用于触发操作的递归计划。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule``1(System.Reactive.Concurrency.IScheduler,``0,System.Action{``0,System.Action{``0}})">
            <summary>计划待递归执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于执行递归操作的计划程序。</param>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">待以递归方式执行的操作。传递至操作的最后一个参数用于触发操作的递归计划，传递递归调用状态。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule(System.Reactive.Concurrency.IScheduler,System.TimeSpan,System.Action{System.Action{System.TimeSpan}})">
            <summary>计划在指定的相对到期时间后以递归方式执行的操作。</summary>
            <param name="scheduler">用于执行递归操作的计划程序。</param>
            <param name="action">待以递归方式执行的操作。传递至操作的参数用于在指定的相对时间中触发操作的递归计划。</param>
            <param name="dueTime">首次执行操作之后的相对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule``1(System.Reactive.Concurrency.IScheduler,``0,System.TimeSpan,System.Action{``0,System.Action{``0,System.TimeSpan}})">
            <summary>计划在指定的相对到期时间后以递归方式执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于执行递归操作的计划程序。</param>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">待以递归方式执行的操作。传递至操作的最后一个参数用于触发操作的递归计划，传递递归到期时间和调用状态。</param>
            <param name="dueTime">首次执行操作之后的相对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule(System.Reactive.Concurrency.IScheduler,System.DateTimeOffset,System.Action{System.Action{System.DateTimeOffset}})">
            <summary>计划在指定的绝对到期时间时以递归方式执行的操作。</summary>
            <param name="scheduler">用于执行递归操作的计划程序。</param>
            <param name="action">待以递归方式执行的操作。传递至操作的参数用于在指定的绝对时间中触发操作的递归计划。</param>
            <param name="dueTime">首次执行操作的绝对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule``1(System.Reactive.Concurrency.IScheduler,``0,System.DateTimeOffset,System.Action{``0,System.Action{``0,System.DateTimeOffset}})">
            <summary>计划在指定的绝对到期时间时以递归方式执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="scheduler">用于执行递归操作的计划程序。</param>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">待以递归方式执行的操作。传递至操作的最后一个参数用于触发操作的递归计划，传递递归到期时间和调用状态。</param>
            <param name="dueTime">首次执行操作的绝对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule(System.Reactive.Concurrency.IScheduler,System.Action)">
            <summary>安排要执行的操作。</summary>
            <param name="scheduler">操作调度程序。</param>
            <param name="action">待执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule(System.Reactive.Concurrency.IScheduler,System.TimeSpan,System.Action)">
            <summary>计划在指定的相对到期时间后执行的操作。</summary>
            <param name="scheduler">操作调度程序。</param>
            <param name="action">待执行的操作。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.Schedule(System.Reactive.Concurrency.IScheduler,System.DateTimeOffset,System.Action)">
            <summary>计划在指定的绝对到期时间时执行的操作。</summary>
            <param name="scheduler">操作调度程序。</param>
            <param name="action">待执行的操作。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Scheduler.ScheduleLongRunning(System.Reactive.Concurrency.ISchedulerLongRunning,System.Action{System.Reactive.Disposables.ICancelable})">
            <summary>安排要执行的操作。</summary>
            <param name="scheduler">操作调度程序。</param>
            <param name="action">待执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="P:System.Reactive.Concurrency.Scheduler.Now">
            <summary>根据本地机器的系统时钟获取当前时间。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.Scheduler.Immediate">
            <summary>获取在当前线程上立即计划工作的计划程序。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.Scheduler.CurrentThread">
            <summary>获取在当前线程上立即计划工作的计划程序。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.Scheduler.Default">
            <summary>获取在平台的默认计划程序上计划工作的计划程序。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.Scheduler.ThreadPool">
            <summary>获取在线程池上计划工作的计划程序。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.Scheduler.NewThread">
            <summary>获取使用默认线程创建选项计划新线程上的工作的计划程序。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.Scheduler.TaskPool">
            <summary>获取使用默认的 TaskScheduler 计划任务并行库 (TPL) 任务池的工作的计划程序。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.LocalScheduler">
            <summary>机器本地计划程序的抽象基类，使用本地系统时钟进行基于时间的操作。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.MAXERRORRATIO">
            <summary>计时器偏移的最大错误率。我们已发现机器每天偏移 10s，大约为 10E-4 的顺序，所以我们允许额外的边际。此值用于计算长期队列计时器的提前到达，该计时器将重新评估短期队列的工作。示例：-------------------------------...---------------------*-----$ ^ ^ | |早期到期 0.999 1.0 我们在早期和到期之间也规定了不长不短的最少时间，所以我们有足够的时间将工作转换至短期，并且按惯例使用目的地计划程序来管理其队列等。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.s_gate">
            <summary>用于保护队列并同步计划决策和系统时钟变更管理的门。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.s_longTerm">
            <summary>长期工作队列。包含在排队时计算的超出SHORTTERM的工作。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.s_nextLongTermTimer">
            <summary>将重新评估和分配长期队列中的第一个项目的长期计时器的一次性资源。用于使“处理目前项并分配新项”逻辑更简易的的串行一次性项。未处理一次性项本身。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.s_nextLongTermWorkItem">
            <summary>当前长期计时器正在运行的长期队列头部的项目。用于检测队列中的更改，并决定是否应替换或是否能继续使用当前计时器（因为没有将早期的长期工作添加到队列中）。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.s_shortTerm">
            <summary>短期工作队列。包含即将到期的工作、在排队时计算的工作或重新评估长期队列时导致工作项迁移的工作。保留该队列，以便能在发生系统时钟更改时将短期项目重新定位回长期队列。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.s_shortTermWork">
            <summary>所有当前短期工作计划调用的一次性句柄集，在系统时钟更改时能取消这些句柄。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.SHORTTERM">
            <summary>确定项目为短期工作或从长期转为短期的阈值。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.LONGTOSHORT">
            <summary>在为短期工作重新评估队列前待触发的长期计时器的最小阈值。选择此值小于SHORTTERM，以确保触发计时器并且将工作转换至短期队列。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.RETRYSHORT">
            <summary>用于确定与绝对到期时间相比，短期计时器何时过早触发的阈值。这为计划工作的早期完成提供了最后的机会保护，这可能在操作系统时间调整时发生（参见 GetSystemTimeAdjustment）。</summary>
        </member>
        <member name="F:System.Reactive.Concurrency.LocalScheduler.MAXSUPPORTEDTIMER">
            <summary><see cref="T:System.Threading.Timer"/>支持的最长间隔。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.Enqueue``1(System.Reactive.Concurrency.IScheduler,``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>将绝对时间计划工作排入计时器队列或短期工作列表中。</summary>
            <param name="scheduler">用于运行工作的计划程序。通常这是从调用方的角度而言 (LocalScheduler.Schedule)，但参数保持不变，因为我们在所有 Rx 本地计划程序中都有单一的（静态）计时器队列。</param>
            <param name="state">待传递至操作的状态。</param>
            <param name="dueTime">用于运行工作的绝对时间。计时器队列负责执行接近指定时间的工作，同时考虑系统时钟的变化。</param>
            <param name="action">可能递归至计划程序中的待运行的操作。</param>
            <returns>防止工作运行的一次性对象。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.ScheduleShortTermWork(System.Reactive.Concurrency.LocalScheduler.WorkItem)">
            <summary>计划短期内到期的工作。结果是对基础计划程序的相对计划调用，以获得短期 TimeSpan 值。如果系统时钟在此期间发生变化，则尝试取消并重新评估短期工作。</summary>
            <param name="item">待在短期内计划的工作项目。调用方负责确定工作确实是短期的。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.ExecuteNextShortTermWorkItem(System.Reactive.Concurrency.IScheduler,System.IDisposable)">
            <summary>回调处理下一个短期工作项。</summary>
            <param name="scheduler">基础计划程序提供的递归计划程序。</param>
            <param name="cancel">用于标识触发计时器的工作的一次性项（参阅使用代码）。</param>
            <returns>空的一次性项。通过原始WorkItem连接递归工作取消。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.ScheduleLongTermWork(System.Reactive.Concurrency.LocalScheduler.WorkItem)">
            <summary>计划长期到期的工作。这导致工作排队等待最终转换至短期工作列表。</summary>
            <param name="item">待在长期中计划的工作项目。调用方负责确定工作确实是长期的。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.UpdateLongTermProcessingTimer">
            <summary>更新负责将工作从长期队列的头部转换至短期工作列表的长期计时器。</summary>
            <remarks>应在计划程序锁下调用。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.EvaluateLongTermQueue(System.Object)">
            <summary>评估长期队列，将短期工作转换至短期列表，并相应地调整新的长期处理计时器。</summary>
            <param name="state">忽略。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.SystemClockChanged(System.Object,System.Reactive.PlatformServices.SystemClockChangedEventArgs)">
            <summary>当观察系统时钟更改时调用回调，以便调整和重新评估内部计划队列。</summary>
            <param name="args">目前未使用。</param>
            <param name="sender">目前未使用。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.Schedule``1(``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排要执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.Schedule``1(``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>分配在 dueTime 后执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.Schedule``1(``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>分配在 dueTime 时执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <param name="dueTime">执行操作的绝对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.StartStopwatch">
            <summary>启动一个新的秒表对象。</summary>
            <returns>新的秒表对象；在请求时启动。</returns>
            <remarks>平台特定的计划程序实现应重新实现 IStopwatchProvider，以提供更有效的 Istopwatch 实现（如适用）。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.LocalScheduler.GetService(System.Type)">
            <summary>按接口类型查找调度程序服务。基类实现为派生类实现的每个计划程序接口返回所请求的服务。为了更好地控制服务发现，派生类型可以覆盖此方法。</summary>
            <param name="serviceType">要查找的调度程序服务接口类型。</param>
            <returns>实现所请求服务的对象（如果可用）;否则为空。</returns>
        </member>
        <member name="P:System.Reactive.Concurrency.LocalScheduler.Now">
            <summary>获取计划程序的当前时间概念。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.LocalScheduler.WorkItem">
            <summary>显示绝对时间计划程序中的工作项。</summary>
            <remarks>此类型与 ScheduledItem（计划项目）非常相似，但我们需要不同的Invoke（调用）签名以允许自定义目标计划程序（例如：当以递归方式计划上下文中调用时，请参阅 ExecuteNextShortTermWorkItem）。</remarks>
        </member>
        <member name="T:System.Reactive.Concurrency.LocalScheduler.WorkItem`1">
            <summary>显示关闭计划程序调用状态的工作项。子类型用于具有计划程序队列的公共类型。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.CurrentThreadScheduler">
            <summary>显示在当前线程上计划工作单元的对象。</summary>
            <seealso cref="P:System.Reactive.Concurrency.Scheduler.CurrentThread">通过此静态属性公开的此类型单个实例。</seealso>
        </member>
        <member name="M:System.Reactive.Concurrency.CurrentThreadScheduler.Schedule``1(``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排在 dueTime 之后执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="P:System.Reactive.Concurrency.CurrentThreadScheduler.Instance">
            <summary>获取当前线程计划程序的单个实例。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.CurrentThreadScheduler.ScheduleRequired">
            <summary>获取指示调用方是否必须调用Schedule（计划）方法的数值。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.CurrentThreadScheduler.IsScheduleRequired">
            <summary>获取指示调用方是否必须调用Schedule（计划）方法的数值。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.ImmediateScheduler">
            <summary>显示在当前线程上计划立即运行的工作单元的对象。</summary>
            <seealso cref="P:System.Reactive.Concurrency.Scheduler.Immediate">通过此静态属性公开的此类型单个实例。</seealso>
        </member>
        <member name="M:System.Reactive.Concurrency.ImmediateScheduler.Schedule``1(``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排要执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.ImmediateScheduler.Schedule``1(``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排在 dueTime 之后执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="P:System.Reactive.Concurrency.ImmediateScheduler.Instance">
            <summary>获取即刻计划程序的单个实例。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.ScheduledItem`1">
            <summary>计划工作项的抽象基类。</summary>
            <typeparam name="TAbsolute">绝对时间表示类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.#ctor(`0,System.Collections.Generic.IComparer{`0})">
            <summary>创建待在指定时间运行的新计划工作项。</summary>
            <param name="dueTime">必须执行工作项的绝对时间。</param>
            <param name="comparer">比较器用于基于计划的时间比较工作项。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.Invoke">
            <summary>调用工作项。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.InvokeCore">
            <summary>实现此方法以执行工作项调用，返回一次性对象以进行深度取消。</summary>
            <returns>用于取消工作项和/或派生工作项的一次性对象。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.CompareTo(System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>基于绝对时间值将工作项与另一个工作项进行比较。</summary>
            <param name="other">用于与当前工作项进行比较的工作项。</param>
            <returns>这个工作项与指定工作项之间的相对排序。</returns>
            <remarks>不等式运算符被重载以提供与 Icomparable 实现一致的结果。等式运算符实现传统的引用等式语义。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.op_LessThan(System.Reactive.Concurrency.ScheduledItem{`0},System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>确定指定的 ScheduledItem &lt;Tabsolute&gt; 对象是否在第二个指定的 ScheduledItem&lt;TAbsolute&gt; 对象之前到期。</summary>
            <param name="left">第一个待比较的对象。</param>
            <param name="right">第二个待比较的对象。</param>
            <returns>如果左侧的 DueTime（到期时间）值早于右侧的 DueTime 值，则返回 true;否则返回 false。</returns>
            <remarks>此运算符提供与 Icomparable 实现一致的结果。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.op_LessThanOrEqual(System.Reactive.Concurrency.ScheduledItem{`0},System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>确定指定的 ScheduledItem &lt;Tabsolute&gt; 对象是否在第二个指定的 ScheduledItem&lt;TAbsolute&gt; 对象之前或同时到期。</summary>
            <param name="left">第一个待比较的对象。</param>
            <param name="right">第二个待比较的对象。</param>
            <returns>如果左侧的 DueTime（到期时间）值早于右侧的 DueTime 值或与之相同，则返回 true;否则返回 false。</returns>
            <remarks>此运算符提供与 Icomparable 实现一致的结果。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.op_GreaterThan(System.Reactive.Concurrency.ScheduledItem{`0},System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>确定指定的 ScheduledItem &lt;Tabsolute&gt; 对象是否在第二个指定的 ScheduledItem&lt;TAbsolute&gt; 对象之后到期。</summary>
            <param name="left">第一个待比较的对象。</param>
            <param name="right">第二个待比较的对象。</param>
            <returns>如果左侧的 DueTime（到期时间）值晚于右侧的 DueTime 值，则返回 true;否则返回 false。</returns>
            <remarks>此运算符提供与 Icomparable 实现一致的结果。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.op_GreaterThanOrEqual(System.Reactive.Concurrency.ScheduledItem{`0},System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>确定指定的 ScheduledItem &lt;Tabsolute&gt; 对象是否在第二个指定的 ScheduledItem&lt;TAbsolute&gt; 对象之后或同时到期。</summary>
            <param name="left">第一个待比较的对象。</param>
            <param name="right">第二个待比较的对象。</param>
            <returns>如果左侧的 DueTime（到期时间）值晚于右侧的 DueTime 值或与之相同，则返回 true;否则返回 false。</returns>
            <remarks>此运算符提供与 Icomparable 实现一致的结果。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.op_Equality(System.Reactive.Concurrency.ScheduledItem{`0},System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>确定是否存在相等的两个指定的 &lt;TAbsolute, Tvalue&gt; 对象。</summary>
            <param name="left">第一个待比较的对象。</param>
            <param name="right">第二个待比较的对象。</param>
            <returns>如果两个 ScheduledItem&lt;TAbsolute, Tvalue&gt; 相等，则为 true;否则为 false。</returns>
            <remarks>此运算符不提供与 IComparable 实现一致的结果。相反，它实现了引用相等。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.op_Inequality(System.Reactive.Concurrency.ScheduledItem{`0},System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>确定是否存在不相等的两个指定的 &lt;TAbsolute, Tvalue&gt; 对象。</summary>
            <param name="left">第一个待比较的对象。</param>
            <param name="right">第二个待比较的对象。</param>
            <returns>如果两个 ScheduledItem&lt;TAbsolute, Tvalue&gt; 不相等，则为 true;否则为 false。</returns>
            <remarks>此运算符不提供与 IComparable 实现一致的结果。相反，它实现了引用相等。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.Equals(System.Object)">
            <summary>确定是否存在 ScheduledItem&lt;TAbsolute&gt; 对象等于指定对象。</summary>
            <param name="obj">待与当前的 ScheduledItem&lt;TAbsolute&gt; 进行比较的对象。</param>
            <returns>如果对象参数为 ScheduledItem&lt;TAbsolute&gt; 对象并等于当前的 ScheduledItem&lt;TAbsolute&gt; 对象，则为 true;否则为 false。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.GetHashCode">
            <summary>返回当前 ScheduledItem&lt;TAbsolute&gt; 对象的哈希代码。</summary>
            <returns>32位有符号整数的哈希代码。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`1.Cancel">
            <summary>通过尽快处理 InvokeCore 返回的资源来取消工作项。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.ScheduledItem`1.DueTime">
            <summary>获取项目调用到期的绝对时间。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.ScheduledItem`1.IsCanceled">
            <summary>获取工作项是否接收取消请求。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.ScheduledItem`2">
            <summary>显示基于 IScheduler.Schedule 方法调用的实体化的计划工作项。</summary>
            <typeparam name="TAbsolute">绝对时间表示类型。</typeparam>
            <typeparam name="TValue">传递至计划操作的状态类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`2.#ctor(System.Reactive.Concurrency.IScheduler,`1,System.Func{System.Reactive.Concurrency.IScheduler,`1,System.IDisposable},`0,System.Collections.Generic.IComparer{`0})">
            <summary>创建实体化的工作项。</summary>
            <param name="scheduler">用于调用计划操作的递归计划程序。</param>
            <param name="state">待传递至计划操作的状态。</param>
            <param name="action">计划的操作。</param>
            <param name="dueTime">运行计划操作的时间。</param>
            <param name="comparer">比较器用于基于计划的时间比较工作项。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>或<paramref name="comparer"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`2.#ctor(System.Reactive.Concurrency.IScheduler,`1,System.Func{System.Reactive.Concurrency.IScheduler,`1,System.IDisposable},`0)">
            <summary>创建实体化的工作项。</summary>
            <param name="scheduler">用于调用计划操作的递归计划程序。</param>
            <param name="state">待传递至计划操作的状态。</param>
            <param name="action">计划的操作。</param>
            <param name="dueTime">运行计划操作的时间。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="action"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.ScheduledItem`2.InvokeCore">
            <summary>使用提供的递归计划程序和状态调用计划的操作。</summary>
            <returns>计划操作返回的取消资源。</returns>
        </member>
        <member name="T:System.Reactive.Concurrency.SchedulerOperation">
            <summary>显示可等待的计划程序操作。等待对象会导致延续被发布回原始计划程序的工作队列。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerOperation.ConfigureAwait(System.Boolean)">
            <summary>控制是否在原始同步上下文上运行延续（默认为 false）。</summary>
            <param name="continueOnCapturedContext">如果在捕获的同步上下文上运行延续，则为 true;否则为 false（默认）。</param>
            <returns>具有已配置的等待行为的计划程序操作对象。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerOperation.GetAwaiter">
            <summary>获取计划程序操作的 awaiter，用于发布回延续。</summary>
            <returns>Awaiter 用于计划程序操作。</returns>
        </member>
        <member name="T:System.Reactive.Concurrency.SchedulerOperationAwaiter">
            <summary>（基础结构）为 C＃await 和 Visual Basic Await 表达式生成的代码所使用的计划程序操作 awaiter 类型。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerOperationAwaiter.GetResult">
            <summary>完成计划程序操作，在请求取消的情况下发出 OperationCanceledException。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerOperationAwaiter.OnCompleted(System.Action)">
            <summary>使用计划程序操作注册延续。</summary>
            <param name="continuation">继续在原始计划程序上运行。</param>
        </member>
        <member name="P:System.Reactive.Concurrency.SchedulerOperationAwaiter.IsCompleted">
            <summary>指示计划程序操作是否已完成。除非已经请求取消，否则返回 false。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.SchedulerQueue`1">
            <summary>用于维护按绝对时间排序的计划项目的高效的计划程序队列。</summary>
            <typeparam name="TAbsolute">绝对时间表示类型。</typeparam>
            <remarks>这种类型不是线程安全的;用户应确保正确同步。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerQueue`1.#ctor">
            <summary>创建具有默认初始容量的新计划程序队列。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerQueue`1.#ctor(System.Int32)">
            <summary>创建具有指定初始容量的新计划程序队列。</summary>
            <param name="capacity">计划程序队列的初始容量。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerQueue`1.Enqueue(System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>对待计划的指定工作项进行排队。</summary>
            <param name="scheduledItem">待安排的工作项目。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerQueue`1.Remove(System.Reactive.Concurrency.ScheduledItem{`0})">
            <summary>从计划程序队列中删除指定的工作项。</summary>
            <param name="scheduledItem">待从计划程序队列中删除的工作项。</param>
            <returns>如果找到该项，则为 true;否则为 false。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerQueue`1.Dequeue">
            <summary>从计划程序队列中取消排队下一个工作项。</summary>
            <returns>计划程序队列中的下一个工作项（已删除）。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.SchedulerQueue`1.Peek">
            <summary>查看计划程序队列中的下一个工作项。</summary>
            <returns>计划程序队列中的下一个工作项（未删除）。</returns>
        </member>
        <member name="P:System.Reactive.Concurrency.SchedulerQueue`1.Count">
            <summary>获取计划程序队列中的计划项目数量。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.Synchronization">
            <summary>为可观察序列提供基本同步和计划服务。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.Synchronization.SubscribeOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>包装源序列，以便在指定的计划程序上运行其订阅和取消订阅逻辑。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="scheduler">计划程序执行订阅和取消订阅操作。</param>
            <returns>订阅和取消订阅发生在指定计划程序上的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
            <remarks>只有订阅源序列和处理订阅源序列的副作用才会在指定的计划程序上运行。为了在指定的计划程序上调用观察者回调，例如将回调处理卸载至专用线程，请使用 <see cref="M:System.Reactive.Concurrency.Synchronization.ObserveOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)"/>。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.Synchronization.SubscribeOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)">
            <summary>包装源序列，以便在指定的同步上下文运行订阅和取消订阅逻辑。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="context">用于执行订阅和取消订阅操作的同步上下文。</param>
            <returns>订阅和取消订阅发生在指定同步上下文的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="context"/>为空。</exception>
            <remarks>只有订阅源序列和处理订阅源序列的副作用才会在指定的同步上下文上运行。为了在指定的同步上下文上调用观察者回调，例如将回调发布至由同步上下文显示的UI线程，请使用 <see cref="M:System.Reactive.Concurrency.Synchronization.ObserveOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)"/>。</remarks>
        </member>
        <member name="M:System.Reactive.Concurrency.Synchronization.ObserveOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>包装源序列，以便在指定的计划程序上运行观察者回调。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="scheduler">用于通知观察者的计划程序。</param>
            <returns>观察发生在指定计划程序上的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="scheduler"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Synchronization.ObserveOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)">
            <summary>包装源序列，以便在指定的同步上下文运行观察者回调。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="context">同步上下文通知观察者。</param>
            <returns>观察发生在指定同步上下文中的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="context"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Synchronization.Synchronize``1(System.IObservable{``0})">
            <summary>包装源序列以确保正确地对观察者回调进行序列化。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <returns>对观察者的传出调用进行同步的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.Synchronization.Synchronize``1(System.IObservable{``0},System.Object)">
            <summary>包装源序列以确保使用指定的门对象对观察者回调进行同步。</summary>
            <typeparam name="TSource">源序列中元素的类型。</typeparam>
            <param name="source">源序列。</param>
            <param name="gate">门对象用于同步每个观察者调用。</param>
            <returns>在给定门对象上同步观察者的传出调用的源序列。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> 或<paramref name="gate"/>为空。</exception>
        </member>
        <member name="T:System.Reactive.Producer`1">
            <summary>用于实现查询运算符的基类，与使用 Observable.Create 相比，具有性能优势。</summary>
            <typeparam name="TSource">结果序列元素的类型。</typeparam>
        </member>
        <member name="T:System.Reactive.IProducer`1">
            <summary>具有方差注释的界面;在 SubscribeSafe 中检测功能时，允许使用更佳的类型检查。</summary>
            <typeparam name="TSource">结果序列元素的类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Producer`1.Subscribe(System.IObserver{`0})">
            <summary>公开可见的订阅方法。</summary>
            <param name="observer">向其发送通知的观察者。生成方的实现必须确保观察者的正确消息语法。</param>
            <returns>用于取消订阅的 IDisposable。这会导致基础层收到取消订阅的通知，从而阻止其他消息被发送至观察者。</returns>
        </member>
        <member name="M:System.Reactive.Producer`1.Run(System.IObserver{`0},System.IDisposable,System.Action{System.IDisposable})">
            <summary>查询运算符的核心实现，调用生成方对象的新订阅。</summary>
            <param name="observer">向其发送通知的观察者。生成方的实现必须确保观察者的正确消息语法。</param>
            <param name="cancel">从运行调用返回的订阅一次性对象被传递的传递方式使其可以被转发至接收器，允许其在发送最终消息时（或由于其他原因而过早地）处理订阅。</param>
            <param name="setSink">进行回调，从而将接收器对象传送至订阅者，允许消费者将 Dispose 呼叫转移至接收器，这样能停止处理。</param>
            <returns>表示操作员用于处理事件的所有资源和/或订阅的一次性项。</returns>
            <remarks>在 OnError 或 OnCompleted 调用时使用自动分离行为，传递至该方法的该 <paramref name="observer">观察者</paramref> 未受到保护。。实现必须确保适当的资源处理并强制执行消息语法。</remarks>
        </member>
        <member name="T:System.Reactive.Sink`1">
            <summary>用于实现查询运算符的基类，提供了可用于将传出的观察者静音的轻量级接收器。</summary>
            <typeparam name="TSource">结果序列元素的类型。</typeparam>
            <remarks>接收器的实现负责在相关的观察者上强制执行消息语法。在发送终端消息时，应进行配对Dispose调用以触发相关资源的取消并使传出观察者静音。</remarks>
        </member>
        <member name="T:System.Reactive.Concurrency.SynchronizationContextScheduler">
            <summary>显示提供的用于计划工作单元的对象 <seealso cref="T:System.Threading.SynchronizationContext"/>。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.SynchronizationContextScheduler.#ctor(System.Threading.SynchronizationContext)">
            <summary>创建 <see cref="T:System.Threading.SynchronizationContext"/> 提供的用于计划工作单元的对象。</summary>
            <param name="context">用于计划工作单元的同步上下文。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="context"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.SynchronizationContextScheduler.#ctor(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>创建 <see cref="T:System.Threading.SynchronizationContext"/> 提供的用于计划工作单元的对象。</summary>
            <param name="context">用于计划工作单元的同步上下文。</param>
            <param name="alwaysPost">无论调用方是否在相同同步上下文中，配置计划是否始终发布至同步上下文。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="context"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.SynchronizationContextScheduler.Schedule``1(``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排要执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.SynchronizationContextScheduler.Schedule``1(``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排在 dueTime 之后执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="T:System.Reactive.Concurrency.DefaultScheduler">
            <summary>显示在平台的默认计划程序上计划工作单元的对象。</summary>
            <seealso cref="P:System.Reactive.Concurrency.Scheduler.Default">通过此静态属性公开的此类型单个实例。</seealso>
        </member>
        <member name="M:System.Reactive.Concurrency.DefaultScheduler.Schedule``1(``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>安排要执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.DefaultScheduler.Schedule``1(``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>使用 System.Threading.Timer 对象计划在 dueTime 后执行的操作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">传递给待执行操作的状态。</param>
            <param name="action">要执行的操作。</param>
            <param name="dueTime">执行操作之后的相对时间。</param>
            <returns>用于取消计划操作的可释放对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.DefaultScheduler.SchedulePeriodic``1(``0,System.TimeSpan,System.Func{``0,``0})">
            <summary>使用 System.Threading.Timer 对象计划定期工作。</summary>
            <typeparam name="TState">传递给计划操作的状态类型。</typeparam>
            <param name="state">在第一次迭代时将初始状态传递至操作。</param>
            <param name="period">定期运行工作的时间段。</param>
            <param name="action">可能更新状态的待执行的操作。</param>
            <returns>用于取消计划的反复操作的一次性对象（尽力服务）。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> 小于 TimeSpan.Zero。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.DefaultScheduler.GetService(System.Type)">
            <summary>按接口类型查找调度程序服务。</summary>
            <param name="serviceType">要查找的调度程序服务接口类型。</param>
            <returns>实现所请求服务的对象（如果可用）;否则为空。</returns>
        </member>
        <member name="P:System.Reactive.Concurrency.DefaultScheduler.Instance">
            <summary>获取默认计划程序的单个实例。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.AnonymousDisposable">
            <summary>显示基于操作的一次性项。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.AnonymousDisposable.#ctor(System.Action)">
            <summary>使用用于处理的给定操作构建新的一次性项。</summary>
            <param name="dispose">在调用Dispose时将运行的处理操作。</param>
        </member>
        <member name="M:System.Reactive.Disposables.AnonymousDisposable.Dispose">
            <summary>当且仅当当前实例尚未处理时才调用处理操作。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.AnonymousDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.BooleanDisposable">
            <summary>显示可以检查处置状态的一次性资源。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.BooleanDisposable.#ctor">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.BooleanDisposable"/> 类的新实例。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.BooleanDisposable.Dispose">
            <summary>将状态设置为已处理，可以通过观察者 <see cref="P:System.Reactive.Disposables.BooleanDisposable.IsDisposed"/> 属性进行设置。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.BooleanDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.CancellationDisposable">
            <summary>显示具有关联的一次性资源， <seealso cref="T:System.Threading.CancellationToken"/> 该关联将在处置时设置为取消请求状态。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.CancellationDisposable.#ctor(System.Threading.CancellationTokenSource)">
            <summary>初始化<see cref="T:System.Reactive.Disposables.CancellationDisposable"/>类的新实例 <seealso cref="T:System.Threading.CancellationTokenSource"/>。</summary>
            <param name="cts"><seealso cref="T:System.Threading.CancellationTokenSource"/> 用于取消。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="cts"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.CancellationDisposable.#ctor">
            <summary>初始化<see cref="T:System.Reactive.Disposables.CancellationDisposable"/>类的新实例 <seealso cref="T:System.Threading.CancellationTokenSource"/>。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.CancellationDisposable.Dispose">
            <summary>取消基础层 <seealso cref="T:System.Threading.CancellationTokenSource"/>。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.CancellationDisposable.Token">
            <summary>获取由 CancellationDisposable 使用的 <see cref="T:System.Threading.CancellationToken"/> 。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.CancellationDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.CompositeDisposable">
            <summary>显示配置在一起的一组一次性资源。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.#ctor">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> 类的新实例，其最初没有包含一次性项。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.#ctor(System.Int32)">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> 类的新实例，其具有指定数量的一次性项。</summary>
            <param name="capacity">新 CompositeDisposable 最初可以存储的一次性项数量。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> 小于零。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.#ctor(System.IDisposable[])">
            <summary>从一组一次性项初始化 <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> 类的新实例。</summary>
            <param name="disposables">将被共同处理的一次性项。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposables"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.#ctor(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>从一组一次性项初始化<see cref="T:System.Reactive.Disposables.CompositeDisposable"/>类的新实例。</summary>
            <param name="disposables">将被共同处理的一次性项。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposables"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.Add(System.IDisposable)">
            <summary>如果配置了 CompositeDisposable，则将一次性项添加至 CompositeDisposable 或配置一次性项。</summary>
            <param name="item">待添加的一次性项。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.Remove(System.IDisposable)">
            <summary>从 CompositeDisposable 中删除并处理第一次出现的一次性项。</summary>
            <param name="item">待删除的一次性项。</param>
            <returns>如果找到则为 true；否则为 false。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.Dispose">
            <summary>处置组中的所有一次性项并将其从组中删除。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.Clear">
            <summary>从 CompositeDisposable 中删除并处理所有一次性项，但不处理 CompositeDisposable。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.Contains(System.IDisposable)">
            <summary>确定 CompositeDisposable 是否包含特定的一次性项。</summary>
            <param name="item">待搜索的一次性项。</param>
            <returns>如果找到一次性项，则为 true；否则为 false。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.CopyTo(System.IDisposable[],System.Int32)">
            <summary>将 CompositeDisposable 中包含的一次性项从特定的数组下标开始复制至数组。</summary>
            <param name="array">用于将包含的一次性项复制至其中的数组。</param>
            <param name="arrayIndex">用于将组中的第一个一次性项复制至其中的目标下标。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> 为空。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> 小于零。-或 - <paramref name="arrayIndex"/> 大于或等于数组长度。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.GetEnumerator">
            <summary>返回循环访问 CompositeDisposable 的枚举器。</summary>
            <returns>用于循环访问一次性项的枚举器。</returns>
        </member>
        <member name="M:System.Reactive.Disposables.CompositeDisposable.System#Collections#IEnumerable#GetEnumerator">
            <summary>返回循环访问 CompositeDisposable 的枚举器。</summary>
            <returns>用于循环访问一次性项的枚举器。</returns>
        </member>
        <member name="P:System.Reactive.Disposables.CompositeDisposable.Count">
            <summary>获取 CompositeDisposable 中包含的一次性项的数量。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.CompositeDisposable.IsReadOnly">
            <summary>始终返回 false。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.CompositeDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.ContextDisposable">
            <summary>显示其处理调用将发布至指定处的一次性资源 <seealso cref="T:System.Threading.SynchronizationContext"/>。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.ContextDisposable.#ctor(System.Threading.SynchronizationContext,System.IDisposable)">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.ContextDisposable"/> 类的新实例，其使用指定的 <see cref="T:System.Threading.SynchronizationContext"/> 处置指定的一次性资源。</summary>
            <param name="context">待执行处理的上下文。</param>
            <param name="disposable">处理在给定的同步上下文上运行的 Dispose 操作。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="context"/> 或<paramref name="disposable"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.ContextDisposable.Dispose">
            <summary>在提供的 <see cref="T:System.Threading.SynchronizationContext"/> 上处理基础一次性项。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.ContextDisposable.Context">
            <summary>获取提供的 <see cref="T:System.Threading.SynchronizationContext"/>。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.ContextDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.DefaultDisposable">
            <summary>显示无需处理的一次性项。</summary>
        </member>
        <member name="F:System.Reactive.Disposables.DefaultDisposable.Instance">
            <summary>单个默认一次性项。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.DefaultDisposable.Dispose">
            <summary>无操作。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.Disposable">
            <summary>提供一组用于创建 Disposables 的静态方法。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.Disposable.Create(System.Action)">
            <summary>创建在处理时调用指定的操作的一次性项。</summary>
            <param name="dispose">在第一次调用时运行的操作 <see cref="M:System.IDisposable.Dispose"/>。保证最多运行操作一次。</param>
            <returns>处理时执行给定操作的一次性项。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dispose"/> 为空。</exception>
        </member>
        <member name="P:System.Reactive.Disposables.Disposable.Empty">
            <summary>获取无需处理的一次性项。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.MultipleAssignmentDisposable">
            <summary>显示可以将基础一次性资源转换为另一个一次性资源的一次性资源。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.MultipleAssignmentDisposable.#ctor">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.MultipleAssignmentDisposable"/> 类的新实例，其没有当前的基础一次性项。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.MultipleAssignmentDisposable.Dispose">
            <summary>处理基础一次性项和所有未来的替代品。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.MultipleAssignmentDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.MultipleAssignmentDisposable.Disposable">
            <summary>获取或设置基础一次性项。处理后，获取此属性的结果不确定。</summary>
            <remarks>如果已处理 MutableDisposable，则分配此属性会导致立即处理给定的一次性项。</remarks>
        </member>
        <member name="T:System.Reactive.Disposables.RefCountDisposable">
            <summary>显示一次性资源，此资源仅在已处理所有从属一次性对象时才处理其基础一次性资源。<see cref="M:System.Reactive.Disposables.RefCountDisposable.GetDisposable"> </see></summary>
        </member>
        <member name="M:System.Reactive.Disposables.RefCountDisposable.#ctor(System.IDisposable)">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.RefCountDisposable"/> 类的新实例，其具有指定一次性项。</summary>
            <param name="disposable">基础一次性项。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposable"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.RefCountDisposable.GetDisposable">
            <summary>返回从属的一次性项，当处理它时，基础一次性项的引用计数减少。</summary>
            <returns>从属一次性项有助于参考计数管理基础一次性项的使用寿命。</returns>
        </member>
        <member name="M:System.Reactive.Disposables.RefCountDisposable.Dispose">
            <summary>只有在处理完所有从属一次性项后才能处理基础一次性项。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.RefCountDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.ScheduledDisposable">
            <summary>显示将按指定的方式计划其处置调用的一次性资源 <seealso cref="T:System.Reactive.Concurrency.IScheduler"/>。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.ScheduledDisposable.#ctor(System.Reactive.Concurrency.IScheduler,System.IDisposable)">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.ScheduledDisposable"/> 类的新实例，其使用 <see cref="T:System.Reactive.Concurrency.IScheduler"/> 处理一次性项。</summary>
            <param name="scheduler">将处理一次性资源的计划程序。</param>
            <param name="disposable">待在给定的计划程序上处置的一次性资源。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> 或<paramref name="disposable"/>为空。</exception>
        </member>
        <member name="M:System.Reactive.Disposables.ScheduledDisposable.Dispose">
            <summary>在提供的计划程序上处理包装的一次性。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.ScheduledDisposable.Scheduler">
            <summary>获取将处理一次性资源的计划程序。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.ScheduledDisposable.Disposable">
            <summary>获取基础一次性项。处理后，结果不确定。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.ScheduledDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="T:System.Reactive.Disposables.SerialDisposable">
            <summary>显示一次性资源，此资源的基础一次性资源可由另一种一次性资源代替，从而导致自动处理先前的基础可支配资源。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.SerialDisposable.#ctor">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.SerialDisposable"/> 类的新实例。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.SerialDisposable.Dispose">
            <summary>处理基础一次性项和所有未来的替代品。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.SerialDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.SerialDisposable.Disposable">
            <summary>获取或设置基础一次性项。</summary>
            <remarks>如果已处理 SerialDisposable，则分配此属性会导致立即处理给定的一次性项。分配此属性来处理先前的一次性对象。</remarks>
        </member>
        <member name="T:System.Reactive.Disposables.SingleAssignmentDisposable">
            <summary>显示一次性资源，该资源仅允许单独分配其基础一次性资源。如果已设置基础一次性资源，将来尝试设置基础一次性资源将引发 <see cref="T:System.InvalidOperationException"/>。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.SingleAssignmentDisposable.#ctor">
            <summary>初始化 <see cref="T:System.Reactive.Disposables.SingleAssignmentDisposable"/> 类的新实例。</summary>
        </member>
        <member name="M:System.Reactive.Disposables.SingleAssignmentDisposable.Dispose">
            <summary>处理基础一次性项。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.SingleAssignmentDisposable.IsDisposed">
            <summary>获取指示对象是否已被处理的值。</summary>
        </member>
        <member name="P:System.Reactive.Disposables.SingleAssignmentDisposable.Disposable">
            <summary>获取或设置基础一次性项。处理后，获取此属性的结果不确定。</summary>
            <exception cref="T:System.InvalidOperationException">如果已分配 SingleAssignmentDisposable，则引发。</exception>
        </member>
        <member name="T:System.Reactive.PlatformServices.IExceptionServices">
            <summary>（基础结构）重新引发异常的服务。</summary>
            <remarks>此类型由Rx基础结构使用，不适用于公共使用或实现。不保证类型功能的前向兼容性及其用途。</remarks>
        </member>
        <member name="M:System.Reactive.PlatformServices.IExceptionServices.Rethrow(System.Exception)">
            <summary>重新引发指定的异常。</summary>
            <param name="exception">重新引发的异常。</param>
        </member>
        <member name="T:System.Reactive.PlatformServices.HostLifecycleService">
            <summary>（基础结构）提供对主机生命周期管理服务的访问。</summary>
        </member>
        <member name="M:System.Reactive.PlatformServices.HostLifecycleService.AddRef">
            <summary>添加对主机生命周期管理器的引用，使其发送通知。</summary>
        </member>
        <member name="M:System.Reactive.PlatformServices.HostLifecycleService.Release">
            <summary>删除对主机生命周期管理器的引用，如果删除的引用是最后一个，则使其停止发送通知。</summary>
        </member>
        <member name="E:System.Reactive.PlatformServices.HostLifecycleService.Suspending">
            <summary>主机暂停应用时引发的事件。</summary>
        </member>
        <member name="E:System.Reactive.PlatformServices.HostLifecycleService.Resuming">
            <summary>主机恢复应用时引发的事件。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.IHostLifecycleNotifications">
            <summary>（基础结构）提供有关主机生命周期事件的通知。</summary>
        </member>
        <member name="E:System.Reactive.PlatformServices.IHostLifecycleNotifications.Suspending">
            <summary>主机暂停时引发的事件。</summary>
        </member>
        <member name="E:System.Reactive.PlatformServices.IHostLifecycleNotifications.Resuming">
            <summary>主机恢复时引发的事件。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.HostSuspendingEventArgs">
            <summary>（基础结构）主机暂停事件的事件参数。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.HostResumingEventArgs">
            <summary>（基础结构）主机恢复事件的事件参数。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.IPlatformEnlightenmentProvider">
            <summary>（基础结构）启示提供程序的界面。</summary>
            <remarks>此类型由Rx基础结构使用，不适用于公共使用或实现。不保证类型功能的前向兼容性及其用途。</remarks>
        </member>
        <member name="M:System.Reactive.PlatformServices.IPlatformEnlightenmentProvider.GetService``1(System.Object[])">
            <summary>（基础结构）尝试获取指定的服务。</summary>
            <typeparam name="T">服务类型</typeparam>
            <param name="args">可选的参数集。</param>
            <returns>服务实例，如果未找到则为 null。</returns>
        </member>
        <member name="T:System.Reactive.PlatformServices.PlatformEnlightenmentProvider">
            <summary>（基础结构）提供程序，用于平台特定的框架启示。</summary>
            <remarks>此类型由Rx基础结构使用，不适用于公共使用或实现。</remarks>
        </member>
        <member name="P:System.Reactive.PlatformServices.PlatformEnlightenmentProvider.Current">
            <summary>（基础结构）获取当前的启示提供程序。如果尚未加载，则访问此属性会触发提供程序解析。</summary>
            <remarks>此成员由Rx基础结构使用，不适用于公共使用或实现。</remarks>
        </member>
        <member name="T:System.Reactive.PlatformServices.SystemClock">
            <summary>（基础结构）提供对本地系统时钟服务的访问。</summary>
            <remarks>此类型由Rx基础结构使用，不适用于公共使用或实现。不保证类型功能的前向兼容性及其用途。</remarks>
        </member>
        <member name="M:System.Reactive.PlatformServices.SystemClock.AddRef">
            <summary>添加对系统时钟监视器的引用，使其发送通知。</summary>
            <exception cref="T:System.NotSupportedException">当系统不支持发送时钟更改通知时引发。</exception>
        </member>
        <member name="M:System.Reactive.PlatformServices.SystemClock.Release">
            <summary>删除对系统时钟监视器的引用，如果删除的引用是最后一个，则使其停止发送通知。</summary>
        </member>
        <member name="P:System.Reactive.PlatformServices.SystemClock.UtcNow">
            <summary>获取本地系统时钟时间。</summary>
        </member>
        <member name="E:System.Reactive.PlatformServices.SystemClock.SystemClockChanged">
            <summary>如果通过 AddRef 调用指示存在兴趣，则检测到系统时钟更改时引发的事件。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.ISystemClock">
            <summary>（基础结构）提供对本地系统时钟的访问。</summary>
            <remarks>此类型由Rx基础结构使用，不适用于公共使用或实现。不保证类型功能的前向兼容性及其用途。</remarks>
        </member>
        <member name="P:System.Reactive.PlatformServices.ISystemClock.UtcNow">
            <summary>获取当前时间。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.INotifySystemClockChanged">
            <summary>（基础结构）提供机制来通知本地计划程序有关系统时钟更改的信息。</summary>
            <remarks>此类型由Rx基础结构使用，不适用于公共使用或实现。不保证类型功能的前向兼容性及其用途。</remarks>
        </member>
        <member name="E:System.Reactive.PlatformServices.INotifySystemClockChanged.SystemClockChanged">
            <summary>检测到系统时钟更改时引发的事件。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.SystemClockChangedEventArgs">
            <summary>（基础结构）系统时钟更改通知的事件参数。</summary>
            <remarks>此类型由Rx基础结构使用，不适用于公共使用或实现。不保证类型功能的前向兼容性及其用途。</remarks>
        </member>
        <member name="M:System.Reactive.PlatformServices.SystemClockChangedEventArgs.#ctor">
            <summary>创建具有未知新旧时间的新系统时钟通知对象。</summary>
        </member>
        <member name="M:System.Reactive.PlatformServices.SystemClockChangedEventArgs.#ctor(System.DateTimeOffset,System.DateTimeOffset)">
            <summary>创建具有指定的新旧时间的新系统时钟通知对象。</summary>
            <param name="oldTime">系统时钟更改前的时间，如果未知，则为 DateTimeOffset.MinValue。</param>
            <param name="newTime">系统时钟更改后的时间，如果未知，则为 DateTimeOffset.MaxValue。</param>
        </member>
        <member name="P:System.Reactive.PlatformServices.SystemClockChangedEventArgs.OldTime">
            <summary>获取系统时钟更改前的时间，如果未知，则获取 DateTimeOffset.MinValue。</summary>
        </member>
        <member name="P:System.Reactive.PlatformServices.SystemClockChangedEventArgs.NewTime">
            <summary>获取系统时钟更改后的时间，如果未知，则获取 DateTimeOffset.MaxValue。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.DefaultSystemClock">
            <summary>（基础结构）提供对本地系统时钟的访问。</summary>
        </member>
        <member name="P:System.Reactive.PlatformServices.DefaultSystemClock.UtcNow">
            <summary>获取当前时间。</summary>
        </member>
        <member name="T:System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor">
            <summary>（基础结构）基于周期性计时器监视系统时钟的更改。</summary>
        </member>
        <member name="M:System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor.#ctor(System.TimeSpan)">
            <summary>使用指定的轮询频率为系统时钟更改创建新的监视器。</summary>
            <param name="period">系统时钟更改的轮询频率。</param>
        </member>
        <member name="E:System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor.SystemClockChanged">
            <summary>检测到系统时钟更改时引发的事件。</summary>
        </member>
        <member name="T:System.Reactive.NotificationKind">
            <summary>指示通知的类型。</summary>
        </member>
        <member name="F:System.Reactive.NotificationKind.OnNext">
            <summary>显示 OnNext 通知。</summary>
        </member>
        <member name="F:System.Reactive.NotificationKind.OnError">
            <summary>显示 OnError 通知。</summary>
        </member>
        <member name="F:System.Reactive.NotificationKind.OnCompleted">
            <summary>显示 OnCompleted 通知。</summary>
        </member>
        <member name="T:System.Reactive.Notification`1">
            <summary>显示向观察者发出的通知。</summary>
            <typeparam name="T">观察者收到的元素类型。</typeparam>
        </member>
        <member name="M:System.Reactive.Notification`1.#ctor">
            <summary>派生类型使用的默认构造函数。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.Equals(System.Reactive.Notification{`0})">
            <summary>确定当前 Notification&lt;T&gt; 对象是否具有与指定 Notification&lt;T&gt; 值相同的观察者消息有效负载。</summary>
            <param name="other">待与当前 Notification&lt;T&gt; 对象进行比较的对象。</param>
            <returns>如果两个通知具有相同的观察者消息有效负载，则为 true；否则为 false。</returns>
            <remarks>Notification&lt;T&gt; 对象的相等基于其显示的观察者消息有效负载的相等，包括 Kind 通知和 Value或 Exception（如存在）。这表示两个 Notification&lt;T&gt; 对象可以是相等的，即使它们不显示相同的观察者方法调用，但具有相同的 Kind 并且具有传递至观察者方法的相等参数即可。如果想确定是否有两个 Notification&lt;T&gt; 对象显示相同的观察者方法调用，则使用 Object.ReferenceEquals 相等身份。</remarks>
        </member>
        <member name="M:System.Reactive.Notification`1.op_Equality(System.Reactive.Notification{`0},System.Reactive.Notification{`0})">
            <summary>确定是否指定了两个 Notification &lt;T&gt; 对象具有相同的观察者消息有效负载。</summary>
            <param name="left">待比较的第一个 Notification&lt;T&gt;，或 null。</param>
            <param name="right">待比较的第二个 Notification&lt;T&gt;，或 null。</param>
            <returns>如果第一个 Notification&lt;T&gt; 值与第二个 Notification&lt;T&gt; 值具有相同的观察者消息有效负载，则为 true；否则为 false。</returns>
            <remarks>Notification&lt;T&gt; 对象的相等基于其显示的观察者消息有效负载的相等，包括 Kind 通知和 Value或 Exception（如存在）。这表示两个 Notification&lt;T&gt; 对象可以是相等的，即使它们不显示相同的观察者方法调用，但具有相同的 Kind 并且具有传递至观察者方法的相等参数即可。如果想确定是否有两个 Notification&lt;T&gt; 对象显示相同的观察者方法调用，则使用 Object.ReferenceEquals 相等身份。</remarks>
        </member>
        <member name="M:System.Reactive.Notification`1.op_Inequality(System.Reactive.Notification{`0},System.Reactive.Notification{`0})">
            <summary>确定是否指定了两个 Notification &lt;T&gt; 对象具有不同的观察者消息有效负载。</summary>
            <param name="left">待比较的第一个 Notification&lt;T&gt;，或 null。</param>
            <param name="right">待比较的第二个 Notification&lt;T&gt;，或 null。</param>
            <returns>如果第一个 Notification&lt;T&gt; 值与第二个 Notification&lt;T&gt; 值具有不同的观察者消息有效负载，则为 true；否则为 false。</returns>
            <remarks>Notification&lt;T&gt; 对象的相等基于其显示的观察者消息有效负载的相等，包括 Kind 通知和 Value或 Exception（如存在）。这表示两个 Notification&lt;T&gt; 对象可以是相等的，即使它们不显示相同的观察者方法调用，但具有相同的 Kind 并且具有传递至观察者方法的相等参数即可。如果想确定是否有两个 Notification&lt;T&gt; 对象显示不同的观察者方法调用，则使用 Object.ReferenceEquals 相等身份。</remarks>
        </member>
        <member name="M:System.Reactive.Notification`1.Equals(System.Object)">
            <summary>确定指定的 System.Object 是否等于当前的 Notification&lt;T&gt;。</summary>
            <param name="obj">待与当前的 Notification&lt;T&gt; 进行比较的 System.Object。</param>
            <returns>如果指定的 System.Object 等于当前的 Notification&lt;T&gt;，则为 true；否则为 false。</returns>
            <remarks>Notification&lt;T&gt; 对象的相等基于其显示的观察者消息有效负载的相等，包括 Kind 通知和 Value或 Exception（如存在）。这表示两个 Notification&lt;T&gt; 对象可以是相等的，即使它们不显示相同的观察者方法调用，但具有相同的 Kind 并且具有传递至观察者方法的相等参数即可。如果想确定是否有两个 Notification&lt;T&gt; 对象显示相同的观察者方法调用，则使用 Object.ReferenceEquals 相等身份。</remarks>
        </member>
        <member name="M:System.Reactive.Notification`1.Accept(System.IObserver{`0})">
            <summary>调用与通知对应的观察者方法。</summary>
            <param name="observer">待调用通知的观察者。</param>
        </member>
        <member name="M:System.Reactive.Notification`1.Accept``1(System.Reactive.IObserver{`0,``0})">
            <summary>调用对应于通知的观察者方法并返回产生的结果。</summary>
            <typeparam name="TResult">从观察者的通知处理程序返回的结果类型。</typeparam>
            <param name="observer">待调用通知的观察者。</param>
            <returns>由观察产生的结果。</returns>
        </member>
        <member name="M:System.Reactive.Notification`1.Accept(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>调用与通知对应的委托。</summary>
            <param name="onNext">调用 OnNext 通知的委托。</param>
            <param name="onError">调用 OnError 通知的委托。</param>
            <param name="onCompleted">调用 OnCompleted 通知的委托。</param>
        </member>
        <member name="M:System.Reactive.Notification`1.Accept``1(System.Func{`0,``0},System.Func{System.Exception,``0},System.Func{``0})">
            <summary>调用对应于通知的委托并返回生成的结果。</summary>
            <typeparam name="TResult">从通知处理程序委托返回的结果类型。</typeparam>
            <param name="onNext">调用 OnNext 通知的委托。</param>
            <param name="onError">调用 OnError 通知的委托。</param>
            <param name="onCompleted">调用 OnCompleted 通知的委托。</param>
            <returns>由观察产生的结果。</returns>
        </member>
        <member name="M:System.Reactive.Notification`1.ToObservable">
            <summary>使用立即计划程序返回带单个通知的可观察序列。</summary>
            <returns>在订阅时表示通知行为的可观察序列。</returns>
        </member>
        <member name="M:System.Reactive.Notification`1.ToObservable(System.Reactive.Concurrency.IScheduler)">
            <summary>返回带单个通知的可观察序列。</summary>
            <param name="scheduler">用于发送通知调用的计划程序。</param>
            <returns>在订阅时表示通知行为的可观察序列。</returns>
        </member>
        <member name="P:System.Reactive.Notification`1.Value">
            <summary>返回 OnNext 通知的值或引发异常。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.HasValue">
            <summary>返回指示通知是否具有值的数值。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.Exception">
            <summary>返回 OnError 通知的异常或返回 null。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.Kind">
            <summary>获取显示的通知类型。</summary>
        </member>
        <member name="T:System.Reactive.Notification`1.OnNextNotification">
            <summary>显示对观察者的 OnNext 通知。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnNextNotification.#ctor(`0)">
            <summary>构建新值的通知。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnNextNotification.GetHashCode">
            <summary>返回此实例的哈希代码。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnNextNotification.Equals(System.Reactive.Notification{`0})">
            <summary>指示此实例和指定对象是否相等。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnNextNotification.ToString">
            <summary>返回此实例的字符串表示。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnNextNotification.Accept(System.IObserver{`0})">
            <summary>调用与通知对应的观察者方法。</summary>
            <param name="observer">待调用通知的观察者。</param>
        </member>
        <member name="M:System.Reactive.Notification`1.OnNextNotification.Accept``1(System.Reactive.IObserver{`0,``0})">
            <summary>调用对应于通知的观察者方法并返回产生的结果。</summary>
            <param name="observer">待调用通知的观察者。</param>
            <returns>由观察产生的结果。</returns>
        </member>
        <member name="M:System.Reactive.Notification`1.OnNextNotification.Accept(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>调用与通知对应的委托。</summary>
            <param name="onNext">调用 OnNext 通知的委托。</param>
            <param name="onError">调用 OnError 通知的委托。</param>
            <param name="onCompleted">调用 OnCompleted 通知的委托。</param>
        </member>
        <member name="M:System.Reactive.Notification`1.OnNextNotification.Accept``1(System.Func{`0,``0},System.Func{System.Exception,``0},System.Func{``0})">
            <summary>调用对应于通知的委托并返回生成的结果。</summary>
            <param name="onNext">调用 OnNext 通知的委托。</param>
            <param name="onError">调用 OnError 通知的委托。</param>
            <param name="onCompleted">调用 OnCompleted 通知的委托。</param>
            <returns>由观察产生的结果。</returns>
        </member>
        <member name="P:System.Reactive.Notification`1.OnNextNotification.Value">
            <summary>返回 OnNext 通知的值。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnNextNotification.Exception">
            <summary>返回 null。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnNextNotification.HasValue">
            <summary>返回 true。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnNextNotification.Kind">
            <summary>返回 NotificationKind.OnNext。</summary>
        </member>
        <member name="T:System.Reactive.Notification`1.OnErrorNotification">
            <summary>表示对观察者的 OnError 通知。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnErrorNotification.#ctor(System.Exception)">
            <summary>构建异常通知。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnErrorNotification.GetHashCode">
            <summary>返回此实例的哈希代码。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnErrorNotification.Equals(System.Reactive.Notification{`0})">
            <summary>指示此实例和其他实例是否相等。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnErrorNotification.ToString">
            <summary>返回此实例的字符串表示。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnErrorNotification.Accept(System.IObserver{`0})">
            <summary>调用与通知对应的观察者方法。</summary>
            <param name="observer">待调用通知的观察者。</param>
        </member>
        <member name="M:System.Reactive.Notification`1.OnErrorNotification.Accept``1(System.Reactive.IObserver{`0,``0})">
            <summary>调用对应于通知的观察者方法并返回产生的结果。</summary>
            <param name="observer">待调用通知的观察者。</param>
            <returns>由观察产生的结果。</returns>
        </member>
        <member name="M:System.Reactive.Notification`1.OnErrorNotification.Accept(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>调用与通知对应的委托。</summary>
            <param name="onNext">调用 OnNext 通知的委托。</param>
            <param name="onError">调用 OnError 通知的委托。</param>
            <param name="onCompleted">调用 OnCompleted 通知的委托。</param>
        </member>
        <member name="M:System.Reactive.Notification`1.OnErrorNotification.Accept``1(System.Func{`0,``0},System.Func{System.Exception,``0},System.Func{``0})">
            <summary>调用对应于通知的委托并返回生成的结果。</summary>
            <param name="onNext">调用 OnNext 通知的委托。</param>
            <param name="onError">调用 OnError 通知的委托。</param>
            <param name="onCompleted">调用 OnCompleted 通知的委托。</param>
            <returns>由观察产生的结果。</returns>
        </member>
        <member name="P:System.Reactive.Notification`1.OnErrorNotification.Value">
            <summary>引发异常。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnErrorNotification.Exception">
            <summary>返回异常。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnErrorNotification.HasValue">
            <summary>返回 false。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnErrorNotification.Kind">
            <summary>返回 NotificationKind.OnError。</summary>
        </member>
        <member name="T:System.Reactive.Notification`1.OnCompletedNotification">
            <summary>表示对观察者的 OnCompleted 通知。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnCompletedNotification.#ctor">
            <summary>构建序列结束的通知。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnCompletedNotification.GetHashCode">
            <summary>返回此实例的哈希代码。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnCompletedNotification.Equals(System.Reactive.Notification{`0})">
            <summary>指示此实例和其他实例是否相等。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnCompletedNotification.ToString">
            <summary>返回此实例的字符串表示。</summary>
        </member>
        <member name="M:System.Reactive.Notification`1.OnCompletedNotification.Accept(System.IObserver{`0})">
            <summary>调用与通知对应的观察者方法。</summary>
            <param name="observer">待调用通知的观察者。</param>
        </member>
        <member name="M:System.Reactive.Notification`1.OnCompletedNotification.Accept``1(System.Reactive.IObserver{`0,``0})">
            <summary>调用对应于通知的观察者方法并返回产生的结果。</summary>
            <param name="observer">待调用通知的观察者。</param>
            <returns>由观察产生的结果。</returns>
        </member>
        <member name="M:System.Reactive.Notification`1.OnCompletedNotification.Accept(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>调用与通知对应的委托。</summary>
            <param name="onNext">调用 OnNext 通知的委托。</param>
            <param name="onError">调用 OnError 通知的委托。</param>
            <param name="onCompleted">调用 OnCompleted 通知的委托。</param>
        </member>
        <member name="M:System.Reactive.Notification`1.OnCompletedNotification.Accept``1(System.Func{`0,``0},System.Func{System.Exception,``0},System.Func{``0})">
            <summary>调用对应于通知的委托并返回生成的结果。</summary>
            <param name="onNext">调用 OnNext 通知的委托。</param>
            <param name="onError">调用 OnError 通知的委托。</param>
            <param name="onCompleted">调用 OnCompleted 通知的委托。</param>
            <returns>由观察产生的结果。</returns>
        </member>
        <member name="P:System.Reactive.Notification`1.OnCompletedNotification.Value">
            <summary>引发 InvalidOperationException。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnCompletedNotification.Exception">
            <summary>返回 null。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnCompletedNotification.HasValue">
            <summary>返回 false。</summary>
        </member>
        <member name="P:System.Reactive.Notification`1.OnCompletedNotification.Kind">
            <summary>返回 NotificationKind.OnCompleted。</summary>
        </member>
        <member name="T:System.Reactive.Notification">
            <summary>提供一组用于构建通知的静态方法。</summary>
        </member>
        <member name="M:System.Reactive.Notification.CreateOnNext``1(``0)">
            <summary>创建表示对观察者的 OnNext 通知的对象。</summary>
            <typeparam name="T">观察者收到的元素类型。在将通知非实物化为可观察序列时，该类型用作序列的元素类型。</typeparam>
            <param name="value">通知中包含的值。</param>
            <returns>包含值的 OnNext 通知。</returns>
        </member>
        <member name="M:System.Reactive.Notification.CreateOnError``1(System.Exception)">
            <summary>创建表示对观察者的 OnError 通知的对象。</summary>
            <typeparam name="T">观察者收到的元素类型。在将通知非实物化为可观察序列时，该类型用作序列的元素类型。</typeparam>
            <param name="error">通知中包含的异常。</param>
            <returns>包含异常的 OnError 通知。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> 为空。</exception>
        </member>
        <member name="M:System.Reactive.Notification.CreateOnCompleted``1">
            <summary>创建表示对观察者的 OnCompleted 通知的对象。</summary>
            <typeparam name="T">观察者收到的元素类型。在将通知非实物化为可观察序列时，该类型用作序列的元素类型。</typeparam>
            <returns>OnCompleted 通知。</returns>
        </member>
        <member name="T:System.Reactive.Unit">
            <summary>表示具有单个值的类型。此类型通常用于表示成功完成空白返回方法 （C＃） 或 Sub 过程 （Visual Basic）。</summary>
        </member>
        <member name="M:System.Reactive.Unit.Equals(System.Reactive.Unit)">
            <summary>确定指定的 Unit 值是否等于当前 Unit。因为 Unit 具有单一值，所以它总是返回 true。</summary>
            <param name="other">待与当前 Unit 值进行比较的对象。</param>
            <returns>因为 Unit 具有单一值，所以它总是返回 true。</returns>
        </member>
        <member name="M:System.Reactive.Unit.Equals(System.Object)">
            <summary>确定指定的 System.Object 是否等于当前 Unit。</summary>
            <param name="obj">待与当前的 Unit 进行比较的 System.Object。</param>
            <returns>如果指定的 System.Object 是 Unit 值，则返回 true；否则返回 false。</returns>
        </member>
        <member name="M:System.Reactive.Unit.GetHashCode">
            <summary>返回当前 Unit 值的哈希代码。</summary>
            <returns>当前 Unit 值的哈希代码。</returns>
        </member>
        <member name="M:System.Reactive.Unit.ToString">
            <summary>返回当前 Unit 值的字符串表示。</summary>
            <returns>当前 Unit 值的字符串表示。</returns>
        </member>
        <member name="M:System.Reactive.Unit.op_Equality(System.Reactive.Unit,System.Reactive.Unit)">
            <summary>确定两个指定的 Unit 值是否相等。因为 Unit 具有单一值，所以它总是返回 true。</summary>
            <param name="first">待比较的第一个单位值。</param>
            <param name="second">待比较的第二个单位值。</param>
            <returns>因为 Unit 具有单一值，所以它总是返回 true。</returns>
        </member>
        <member name="M:System.Reactive.Unit.op_Inequality(System.Reactive.Unit,System.Reactive.Unit)">
            <summary>确定两个指定的 Unit 值是否不相等。因为 Unit 具有单一值，因此始终返回 false。</summary>
            <param name="first">待比较的第一个单位值。</param>
            <param name="second">待比较的第二个单位值。</param>
            <returns>因为 Unit 具有单一值，因此始终返回 false。</returns>
        </member>
        <member name="P:System.Reactive.Unit.Default">
            <summary>获取单个单元值。</summary>
        </member>
        <member name="T:System.Reactive.Strings_Core">
            <summary>强类型资源类，用于查找本地化字符串等。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.ResourceManager">
            <summary>返回此类使用的缓存 ResourceManager 实例。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.Culture">
            <summary>使用此强类型资源类覆盖当前线程的 CurrentUICulture 属性以进行所有资源查找。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.CANT_OBTAIN_SCHEDULER">
            <summary>查找类似于使用计划程序的本地化字符串。由于重构 API 表面并消除平台特定的依赖项，所以不再支持 {0} 属性。请为您的目标平台纳入 System.Reactive.PlatformServices，并使用 {0} 计划程序类型。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.COMPLETED_NO_VALUE">
            <summary>查找不具有值的类似于 OnCompleted 通知的本地化字符..</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.DISPOSABLE_ALREADY_ASSIGNED">
            <summary>查找已被分配的类似于 Disposable 的本地化字符串..</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.FAILED_CLOCK_MONITORING">
            <summary>查找类似于无法启动监视系统时钟更改的本地化字符串..</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.HEAP_EMPTY">
            <summary>查找类似于 Heap 为空的本地化字符串..</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.REENTRANCY_DETECTED">
            <summary>查找已被检测到的类似于 Reentrancy 的本地化字符串..</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.OBSERVER_TERMINATED">
            <summary>查找已终止的类似于 Observer 的本地化字符串..</summary>
        </member>
        <member name="P:System.Reactive.Strings_Core.SCHEDULER_OPERATION_ALREADY_AWAITED">
            <summary>查找已等待的类似于此计划程序操作的本地化字符串...</summary>
        </member>
    </members>
</doc>